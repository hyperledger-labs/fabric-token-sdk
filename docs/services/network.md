# Network Service

The [`token/services/network`](./../../token/services/network) service acts as a bridge, hiding the intricate details of the underlying ledger technology (like Fabric or Orion) from developers.
This service leverages a driver-based design, allowing developers to create new drivers for additional ledger platforms.
Currently, Fabric and Orion are supported out of the box.

### Fabric Driver

The Fabric driver for the network service is located in the package `token/services/network/fabric`.
This driver assumes that the `Token Chaincode` (located in the package `token/services/network/fabric/tcc`)
is available in the Fabric network. This chaincode provides multiple functionalities that the Fabric driver uses.
Namely:
- `Public Parameters Lifecycle`. The public parameters govern the behaviour of the token chaincode. That is, how
  token requests are processed and translated, who can issue tokens, who must audit before committing the token transaction, etc.
- `Approval`. This is one of the essential steps in the lifecycle of a token transaction,
  as we have seen in the previous section. The Token Chaincode validates the received token request and, if valid, translates
  it into the Read/Write Set (RW Set) format understood by Fabric.
  Notice that the Token Chaincode can only check the validity of the transaction. Though, double spending can only verified
  at committing time. To do so, the RW Set is generated in a way to trigger [`MVCC`](https://hyperledger-fabric.readthedocs.io/en/release-1.3/arch-deep-dive.html#the-endorsing-peer-simulates-a-transaction-and-produces-an-endorsement-signature)
  conflicts in case of double spending.
  An approval in this case is just the endorsement over the RW Set.

To commit a token transaction, the Fabric network driver first derives a Fabric transaction with the RW Set
obtained from the approval phase. Then, this Fabric transaction is sent to the Fabric ordering service.

The following figure illustrates the token transaction lifecycle for Fabric:

![fabric_ttx_lifecycle.png](./../imgs/fabric_ttx_lifecycle.png)

Let us explore now what happens when the Fabric transaction gets committed.
We expect to see the tokens created by the transaction appearing in the `Token Vault` of the owners.
The following picture shows how this happens:

![commit_process.png](./../imgs/commit_process.png)

In more details:
1. In background, each business party listens to the `Delivery Service` events generated by its Fabric peer partner.
   When the Fabric peer commits a token transaction `Tx`, the FSC node gets informed.
2. The `Delivery Client` informs the `Committer` that `Tx` is available.
3. If `Tx` is deemed valid by Fabric, then the `Committer` further manipulates the RW Set by invoking all registered
   `RW Set Processors` before the RW Set gets committed into the local Token Vault. If `Tx` is invalid, the transaction is
   discarded.
4. The Token SDK installs one of these processors, the `Token RW Set Processor`. This processor extracts all the token
   related information and augments the RW Set with additional information to speed up the token selection process, among other things.
5. Finally, the RW Set, after processing, is committed to the vault.

Only at this point, the tokens created by the transaction become available via the `Token Vault Service` we have discussed above.

### Orion Driver

The Orion driver is similar to the Fabric driver because also Orion manages RW Sets.
Though, in Orion there is no concept of chaincode or stored routines.
To solve this problem, the Orion driver assumes the existence of a `Custodian` (another FSC node) that sits in front of Orion
and handles the `approval` and `commit` steps.

Here is the pictorial representation of the lifecycle of a token transaction for Orion:

![orion_ttx_lifecycle.png](./../imgs/orion_ttx_lifecycle.png)
