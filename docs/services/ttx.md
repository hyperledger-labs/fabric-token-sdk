## The TTX Service

The `token transaction service`, or simply `ttx service`, helps developers assemble token requests and ultimately transactions for the backend.
This package is backend agnostic and relies on the `network service` for backend-specific operations.
This service leverages the FSC's view framework. Therefore, the package consists of a series of `Views` and support `structs`.

Here is a pictorial representation of the lifecycle of a token transaction with Fabric as the backend.

![fabric_ttx_lifecycle.png](../imgs/fabric_ttx_lifecycle.png)

### Transaction Creation

A new transaction can be built from scratch or deserialized from a byte array.

To instantiate a transaction from scratch, the developer needs:
- The TMS ID (network, channel, namespace) of the TMS for which the transaction needs to be created.
  This means that the system is configured with that TMS and the relative Fabric network is also configured.
  If the TMS ID is not specified, the TMSP returns the default TMS, if available.
  If a TMS instance has not been created yet, it gets created on the fly.
- The `Network` instance from the network service.
  This means that the system is configured with a backend that can be located using the TMS ID.
- If the transaction is anonymous, the network service is asked to return an anonymous identity.
  This identity is just the public part that will appear in the Fabric transaction.
  This anonymous identity is generated by the FSC stack.
  Moreover, the FSC `sig service` can produce valid signatures of any message for this identity.
  The constructor of the transaction then generates:
- A Transaction ID that can be used for both a Fabric transaction and a Token Request as an anchor.
- `NewRequest` is invoked on the TMS, which returns an instance of an empty token request.

When a transaction is created,
it adds a hook to the FSC view context such that if an error occurs, all resources used by the transaction are released (e.g., locked tokens).

### Request Recipient Identities

To both issue and transfer tokens, the initiator of these operations needs to know the recipient identity to assign to the newly created token.
For concreteness, let us imagine the following scenario: Alice wants to transfer a token of type `TOK` and quantity `1` to Bob.
Alice needs to request Bob's recipient identity.
The ttx package offers the initiator view `RequestRecipientIdentityView` and responding view `RespondRequestRecipientIdentityView`.
These views define an interactive protocol at the end of which Alice learns Bob's recipient identity.

The views assume that Alice and Bob already know each other and their FSC stack is configured to enable the opening of an FSC communication session.

Then, `RequestRecipientIdentityView` does the following:
- Prepares a `RecipientRequest` message containing the TMS ID and Wallet ID.
- Opens an FSC communication session to Bob, passing Bob's identifier (as registered in Alice's FSC endpoint service) to the FSC stack.
- Sends the marshaled version of `RecipientRequest`.
- Waits for a message to come back.

By virtue of the FSC view framework, Bob executes `RespondRequestRecipientIdentityView` that does the following:
- Receives the `RecipientRequest` on the default FSC session.
- Validates it by checking that a TMS with the passed ID exists and a wallet with the passed ID exists.
  To do so, the view asks the TMSP to retrieve the requested TMS.
  By using the TMS's WalletManager, the view checks that an owner wallet with the requested ID exists.
  If the TMS or the wallet does not exist, then an error is returned to the initiator.
- Invokes the function `GetRecipientData` on the owner wallet.
  The owner wallet then generates on the fly (or picks from a cache, if available) an instance of `driver.RecipientData`.
  It contains an identity and its audit information. The identity is an Idemix pseudonym. The rest of the fields are empty for the assumed token driver.
  If this operation is successful, a row in the table `IdentityInfo` is added with the content of `driver.RecipientData`.
  Another row in the table `IdentitySigners` is added to signal that this identity belongs to the node that created it.
  Another row is added to the `KeyStore` table with the secret key bound to the `identity` (the Idemix pseudonym).
- Sends `RecipientData` back on the default FSC session.
- Updates the FSC endpoint service by binding `RecipientData.identity` to its own FSC node identity.

Then, `RequestRecipientIdentityView` does the following:
- Reads `RecipientData` from the session.
- Registers it in the `WalletManager`, which checks that the information contained in `RecipientData` is correct and compatible with the public parameters.
  The registration results in a row added to the `IdentityInfo` table.
- Finally, it records that `RecipientData.Identity` belongs to Bob by updating the FSC endpoint service.

### Token Operations

A token request supports two fundamental types of operations: Issue and Transfer.
These are sufficient to perform a redeem and other variants of the fundamental operations.
A transaction helps to assemble these operations. A transaction can contain multiple operations at the same time.
They are either all committed or none.

#### Issue Operation

The transaction has an `Issue` function to assemble an `Issue` action.
These are the requirements:
- A TMS instance for a given ID retrievable from the TMS Provider.
- An issuer wallet retrievable from the TMS's Wallet Manager for a given wallet identifier.
  To have such a wallet, there must be a row in the `IdentityConfigurations` table whose ID matches the wallet identifier and whose type is `Issuer`.
- A token type among those supported (any string works).
- The quantity to put in the issued token.

When invoked, the function invokes the corresponding `Issue` function on the `TokenRequest` (Token API) that does the following:
- Validates the inputs. For instance, the quantity must be <= `MaxTokenValue`.
- Retrieves an Issuer identity from the issuer wallet via a call to `GetIssuerIdentity` for the request type.
  Currently, the same identity is returned no matter the type. The identity returned corresponds to that in a row of the `IdentityInfo` table.
  When creating an issuer wallet, the wallet manager immediately adds a row to the `IdentityInfo` table. The issuer wallet doesn't support pseudonyms.
- Uses the `IssueService` from the Driver API to generate an issue action as per the Token Driver identified by the TMS's public parameters.
- The issue action and its metadata are added to the token request as serialized action and metadata.

### Transfer Operation

The transaction has a `Transfer` function to assemble a `Transfer` action.
These are the requirements:
- A TMS instance for a given ID retrievable from the TMS Provider.
- An owner wallet retrievable from the TMS's Wallet Manager for a given wallet identifier.
  To have such a wallet, there must be a row in the `IdentityConfigurations` table whose ID matches the wallet identifier and whose type is `Owner`.
- A token type among those supported (any string works).
- Pairs of <quantity, recipient identity>. For each pair, a token will be added to the action with the corresponding quantity and recipient identity as owner.

When invoked, the function invokes the corresponding `Transfer` function on the `TokenRequest` (Token API) that does the following:
- Validates the inputs. For instance, the quantities must be <= `MaxTokenValue`.
- Obtains a new `Selector` anchored to the ID of the transaction from the TMS's `SelectorManager` (Driver API).
- Invokes the `Selector`'s `Select` function to choose enough tokens to cover the total amount to transfer from the selected owner wallet.
  When selecting tokens, the selector picks them from the `Tokens` table such that they are spendable (`is_deleted` is false and `is_spendable` is true).
  When a token is picked to be used, the selector tries to acquire a lock over it by inserting a row in the `TokenLocks` table.
  If the insert is successful, then the token is reserved for this selector. If not, the selector tries another token.
- If the selector does not manage to get enough tokens to cover the demand, then an error is returned and all the locked tokens are released. This way, they can be used by other selectors.
- Uses the `TransferService` from the Driver API to generate a transaction action as per the Token Driver identified by the TMS's public parameters.
- The transfer action and its metadata are added to the token request as serialized action and metadata.

**Remark**: A redeem operation is not offered directly by the Token Request (Token API) because it is just a transfer to an `empty` recipient identity.
The transaction contains a `Redeem` function to hide this aspect from the developer.

### Collect Endorsements

Once a transaction has been filled with all the necessary actions, its token request needs to be equipped with a series of signatures.
Namely:
- For each token spent by the transaction, a signature valid under the owner field of that token.
- A signature from one of the issuers if the transaction contains issue actions.
- A signature from one of the auditors if the auditors are set.
- A signature from the endorsers/approvers of the namespace this transaction refers too. (Recall that TMS ID contains a namespace field that matches the namespace in Fabric).

The identities of the valid issuers and auditors are set in the public parameters.
In addition to the above, all the recipients of tokens need to receive the token request to extract from it the metadata required to spend the freshly created tokens.

The `CollectEndorsementsView` is responsible for performing all the above operations.
Let us describe them in more detail. The view takes a transaction as input and does the following:

- For each transfer action, collect the identities that must sign them (the owner of all the tokens spent).
- For each deduplicated identity collected, does the following:
    - If the node owns that identity, then sign the token request directly.
      The TMS's SigService (Token API) is used to check this (the presence of a signer for that identity signals that the node is the issuer itself).
    - If the node does not own that identity, then the view asks for a `remote signature`.
      In this case, the view asks the FSC stack to open a session towards that identity.
      We assume that the node's FSC endpoint service has been instructed about how to locate the node that owns that identity (See `Request Recipient Identities` for an example).
      The node sends a `SignatureRequest` message to the remote party.
      The remote party's FSC view manager is programmed to respond with a view that at some point of its execution must use the `ReceiveTransactionView`.
      This view can be used to receive either the marshaled version of a transaction or a `SignatureRequest` message.
      In both cases, `ReceiveTransactionView` returns a `Transaction`.
      The remote party can inspect the transaction and use the `AcceptView` to respond with the expected signature.
    - The node checks the signature received. If the signature is valid, the node continues; otherwise, it returns an error.
- The same thing is done for each issue action.
- Collect the signature from the auditor. The process is similar to the above. The auditor must use the `AuditApproveView` to approve the token request and send back its signature.
- Collect the endorsement/approval from the Fabric Endorsers of the given namespace (in the TMS ID).
  This operation is delegated to the `network service` that is in charge of dealing with the Fabric process to obtain an endorsement.
  Given the TMS ID, the relative network service is located and the function `RequestApproval` is invoked.
  The result of this operation is an instance of the network struct `Envelope`. This instance is attached to the transaction.
- Store the `transaction records` corresponding to the current version of the token request.
  This operation trigger a series of DB operations that will update the `Transactions DB` and `Tokens DB`.
  Moreover, a finality listener is added to the network service corresponding to the transaction's TMS ID (via a call to `AddFinalityListener`).
  This signals the network to alert when a notification comes about the status of the transaction.
  When the notification comes, the status of the row corresponding to the current token request is updated to `Valid` or `Deleted`.
- (distribution step) For each recipient, the owner of a token, the view opens a session to the node that owns that identity.
  The view send to this node the serialized version of the transaction stripping out from the metadata information that do not belong to that identity.
  Indeed, imagine that Alice sends tokens to Bob and Charlie at the same time. Bob doesn't need to know which tokens Alice is using nor that Charlie has also received something.

The `AcceptView` is invoked inside a responding view for a given business process.
It is used every time a party receives tokens.
When invoking this view, it is expected to invoke `ReceiveTransactionView` first to receive either a transaction or a `SignatureRequest` message.
This view does the following:
- Respond to all the requests of signatures as defined in the token request. Don't forget that the token request must be inspected before calling the AcceptView.
  This means that for each expected `SignatureRequest`, the view checks that it matches one of the expected.
    - Then, via the TMS's `SigService`, it obtains a signer for the identity whose signature is requested.
    - Generates the signature and sends it back via the default session.
- Then, the view calls the `ReceiveTransactionView` to receive the transaction that the initiator sends during the execution of `CollectEndorsementsView` (distribution step).
- Store the `transaction records` corresponding to the current version of the token request.
  This operation trigger a series of DB operations that will update the `Transactions DB` and `Tokens DB`.
  Moreover, a finality listener is added to the network service corresponding to the transaction's TMS ID (via a call to `AddFinalityListener`).
  This signals the network to alert when a notification comes about the status of the transaction.
  When the notification comes, the status of the row corresponding to the current token request is updated to `Valid` or `Deleted`.
- Send back an acknowledgement by signing with the FSC default identity the serialized version of the transaction.

Recall that also a recipient (who does not need to sign the token request) will receive the transaction.
The `AcceptView` handles also this case by managing the case that no SignatureRequest messages are sent.

The `AuditApproveView` is invoked inside a responding view for a given auditing business process.
The auditor is supposed to invoke `ReceiveTransactionView` first to receive the transaction to audit.
The auditor will perform all the required business checks and if no error occurs during the check,
the auditor will invoke the `AuditApproveView`.
The view does the following:
- Store the `transaction records` corresponding to the current version of the token request.
  This operation trigger a series of DB operations that will update the `Audit Transactions DB` and `Tokens DB`.
  Moreover, a finality listener is added to the network service corresponding to the transaction's TMS ID (via a call to `AddFinalityListener`).
  This signals the network to alert when a notification comes about the status of the transaction.
  When the notification comes, the status of the row corresponding to the current token request is updated to `Valid` or `Deleted`.
- Retrieves an Auditor identity from the auditor wallet via a call to `GetAuditorIdentity`.
  Currently, the same identity is returned no matter the type. The identity returned corresponds to that in a row of the `IdentityInfo` table.
  When creating an auditor wallet, the wallet manager immediately adds a row to the `IdentityInfo` table. The auditor wallet doesn't support pseudonyms.
  To have such a wallet, there must be a row in the `IdentityConfigurations` table whose ID matches the wallet identifier and whose type is `Auditor`.

### Ordering a Transaction

Once a transaction gets endorsed via the use of the `CollectEndorsementsView`, then it is ready to be ordered.

The `OrderingView` performs this operation. It takes a transaction as input and does the following:
- Get the network from the `network service` using the transaction's TMS ID.
- Invoke the network's `Broadcast` function that takes in input a network envelope.
  This is translated to a call to the FSC broadcast service for the given Fabric network.

### Finality of a Transaction

If the developers want to know the status of a given transaction, they can either query the Transactions store or invoke the `FinalityView`.
This view takes as input either a transaction or a transaction ID and does the following:
- Check the status of the Request with the given transaction ID in the Transactions DB.
  If the status is either `Valid` or `Invalid`, then the view returns immediately without and with an error respectively.
- Otherwise, the status is `Pending` and the view adds a listener to the Transactions DB to get notified when the request's status changes.
- If a timeout occurs, an error is returned.
- If a notification arrives, an error is returned if the status is `Invalid`; no error if the status is `Valid`.
