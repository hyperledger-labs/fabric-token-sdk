// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-smart-client/integration/nwo/api"
	"github.com/hyperledger-labs/fabric-smart-client/integration/nwo/common"
	"github.com/hyperledger-labs/fabric-token-sdk/integration/nwo/token/generators"
	"github.com/hyperledger-labs/fabric-token-sdk/integration/nwo/token/topology"
	"github.com/onsi/gomega/gexec"
)

type TokenPlatform struct {
	GetBuilderStub        func() api.Builder
	getBuilderMutex       sync.RWMutex
	getBuilderArgsForCall []struct {
	}
	getBuilderReturns struct {
		result1 api.Builder
	}
	getBuilderReturnsOnCall map[int]struct {
		result1 api.Builder
	}
	GetContextStub        func() api.Context
	getContextMutex       sync.RWMutex
	getContextArgsForCall []struct {
	}
	getContextReturns struct {
		result1 api.Context
	}
	getContextReturnsOnCall map[int]struct {
		result1 api.Context
	}
	GetCryptoMaterialGeneratorStub        func(string) generators.CryptoMaterialGenerator
	getCryptoMaterialGeneratorMutex       sync.RWMutex
	getCryptoMaterialGeneratorArgsForCall []struct {
		arg1 string
	}
	getCryptoMaterialGeneratorReturns struct {
		result1 generators.CryptoMaterialGenerator
	}
	getCryptoMaterialGeneratorReturnsOnCall map[int]struct {
		result1 generators.CryptoMaterialGenerator
	}
	GetPublicParamsGeneratorsStub        func(string) generators.PublicParamsGenerator
	getPublicParamsGeneratorsMutex       sync.RWMutex
	getPublicParamsGeneratorsArgsForCall []struct {
		arg1 string
	}
	getPublicParamsGeneratorsReturns struct {
		result1 generators.PublicParamsGenerator
	}
	getPublicParamsGeneratorsReturnsOnCall map[int]struct {
		result1 generators.PublicParamsGenerator
	}
	PublicParametersStub        func(*topology.TMS) []byte
	publicParametersMutex       sync.RWMutex
	publicParametersArgsForCall []struct {
		arg1 *topology.TMS
	}
	publicParametersReturns struct {
		result1 []byte
	}
	publicParametersReturnsOnCall map[int]struct {
		result1 []byte
	}
	PublicParametersDirStub        func() string
	publicParametersDirMutex       sync.RWMutex
	publicParametersDirArgsForCall []struct {
	}
	publicParametersDirReturns struct {
		result1 string
	}
	publicParametersDirReturnsOnCall map[int]struct {
		result1 string
	}
	PublicParametersFileStub        func(*topology.TMS) string
	publicParametersFileMutex       sync.RWMutex
	publicParametersFileArgsForCall []struct {
		arg1 *topology.TMS
	}
	publicParametersFileReturns struct {
		result1 string
	}
	publicParametersFileReturnsOnCall map[int]struct {
		result1 string
	}
	TokenDirStub        func() string
	tokenDirMutex       sync.RWMutex
	tokenDirArgsForCall []struct {
	}
	tokenDirReturns struct {
		result1 string
	}
	tokenDirReturnsOnCall map[int]struct {
		result1 string
	}
	TokenGenStub        func(common.Command) (*gexec.Session, error)
	tokenGenMutex       sync.RWMutex
	tokenGenArgsForCall []struct {
		arg1 common.Command
	}
	tokenGenReturns struct {
		result1 *gexec.Session
		result2 error
	}
	tokenGenReturnsOnCall map[int]struct {
		result1 *gexec.Session
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TokenPlatform) GetBuilder() api.Builder {
	fake.getBuilderMutex.Lock()
	ret, specificReturn := fake.getBuilderReturnsOnCall[len(fake.getBuilderArgsForCall)]
	fake.getBuilderArgsForCall = append(fake.getBuilderArgsForCall, struct {
	}{})
	stub := fake.GetBuilderStub
	fakeReturns := fake.getBuilderReturns
	fake.recordInvocation("GetBuilder", []interface{}{})
	fake.getBuilderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) GetBuilderCallCount() int {
	fake.getBuilderMutex.RLock()
	defer fake.getBuilderMutex.RUnlock()
	return len(fake.getBuilderArgsForCall)
}

func (fake *TokenPlatform) GetBuilderCalls(stub func() api.Builder) {
	fake.getBuilderMutex.Lock()
	defer fake.getBuilderMutex.Unlock()
	fake.GetBuilderStub = stub
}

func (fake *TokenPlatform) GetBuilderReturns(result1 api.Builder) {
	fake.getBuilderMutex.Lock()
	defer fake.getBuilderMutex.Unlock()
	fake.GetBuilderStub = nil
	fake.getBuilderReturns = struct {
		result1 api.Builder
	}{result1}
}

func (fake *TokenPlatform) GetBuilderReturnsOnCall(i int, result1 api.Builder) {
	fake.getBuilderMutex.Lock()
	defer fake.getBuilderMutex.Unlock()
	fake.GetBuilderStub = nil
	if fake.getBuilderReturnsOnCall == nil {
		fake.getBuilderReturnsOnCall = make(map[int]struct {
			result1 api.Builder
		})
	}
	fake.getBuilderReturnsOnCall[i] = struct {
		result1 api.Builder
	}{result1}
}

func (fake *TokenPlatform) GetContext() api.Context {
	fake.getContextMutex.Lock()
	ret, specificReturn := fake.getContextReturnsOnCall[len(fake.getContextArgsForCall)]
	fake.getContextArgsForCall = append(fake.getContextArgsForCall, struct {
	}{})
	stub := fake.GetContextStub
	fakeReturns := fake.getContextReturns
	fake.recordInvocation("GetContext", []interface{}{})
	fake.getContextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) GetContextCallCount() int {
	fake.getContextMutex.RLock()
	defer fake.getContextMutex.RUnlock()
	return len(fake.getContextArgsForCall)
}

func (fake *TokenPlatform) GetContextCalls(stub func() api.Context) {
	fake.getContextMutex.Lock()
	defer fake.getContextMutex.Unlock()
	fake.GetContextStub = stub
}

func (fake *TokenPlatform) GetContextReturns(result1 api.Context) {
	fake.getContextMutex.Lock()
	defer fake.getContextMutex.Unlock()
	fake.GetContextStub = nil
	fake.getContextReturns = struct {
		result1 api.Context
	}{result1}
}

func (fake *TokenPlatform) GetContextReturnsOnCall(i int, result1 api.Context) {
	fake.getContextMutex.Lock()
	defer fake.getContextMutex.Unlock()
	fake.GetContextStub = nil
	if fake.getContextReturnsOnCall == nil {
		fake.getContextReturnsOnCall = make(map[int]struct {
			result1 api.Context
		})
	}
	fake.getContextReturnsOnCall[i] = struct {
		result1 api.Context
	}{result1}
}

func (fake *TokenPlatform) GetCryptoMaterialGenerator(arg1 string) generators.CryptoMaterialGenerator {
	fake.getCryptoMaterialGeneratorMutex.Lock()
	ret, specificReturn := fake.getCryptoMaterialGeneratorReturnsOnCall[len(fake.getCryptoMaterialGeneratorArgsForCall)]
	fake.getCryptoMaterialGeneratorArgsForCall = append(fake.getCryptoMaterialGeneratorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetCryptoMaterialGeneratorStub
	fakeReturns := fake.getCryptoMaterialGeneratorReturns
	fake.recordInvocation("GetCryptoMaterialGenerator", []interface{}{arg1})
	fake.getCryptoMaterialGeneratorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) GetCryptoMaterialGeneratorCallCount() int {
	fake.getCryptoMaterialGeneratorMutex.RLock()
	defer fake.getCryptoMaterialGeneratorMutex.RUnlock()
	return len(fake.getCryptoMaterialGeneratorArgsForCall)
}

func (fake *TokenPlatform) GetCryptoMaterialGeneratorCalls(stub func(string) generators.CryptoMaterialGenerator) {
	fake.getCryptoMaterialGeneratorMutex.Lock()
	defer fake.getCryptoMaterialGeneratorMutex.Unlock()
	fake.GetCryptoMaterialGeneratorStub = stub
}

func (fake *TokenPlatform) GetCryptoMaterialGeneratorArgsForCall(i int) string {
	fake.getCryptoMaterialGeneratorMutex.RLock()
	defer fake.getCryptoMaterialGeneratorMutex.RUnlock()
	argsForCall := fake.getCryptoMaterialGeneratorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenPlatform) GetCryptoMaterialGeneratorReturns(result1 generators.CryptoMaterialGenerator) {
	fake.getCryptoMaterialGeneratorMutex.Lock()
	defer fake.getCryptoMaterialGeneratorMutex.Unlock()
	fake.GetCryptoMaterialGeneratorStub = nil
	fake.getCryptoMaterialGeneratorReturns = struct {
		result1 generators.CryptoMaterialGenerator
	}{result1}
}

func (fake *TokenPlatform) GetCryptoMaterialGeneratorReturnsOnCall(i int, result1 generators.CryptoMaterialGenerator) {
	fake.getCryptoMaterialGeneratorMutex.Lock()
	defer fake.getCryptoMaterialGeneratorMutex.Unlock()
	fake.GetCryptoMaterialGeneratorStub = nil
	if fake.getCryptoMaterialGeneratorReturnsOnCall == nil {
		fake.getCryptoMaterialGeneratorReturnsOnCall = make(map[int]struct {
			result1 generators.CryptoMaterialGenerator
		})
	}
	fake.getCryptoMaterialGeneratorReturnsOnCall[i] = struct {
		result1 generators.CryptoMaterialGenerator
	}{result1}
}

func (fake *TokenPlatform) GetPublicParamsGenerators(arg1 string) generators.PublicParamsGenerator {
	fake.getPublicParamsGeneratorsMutex.Lock()
	ret, specificReturn := fake.getPublicParamsGeneratorsReturnsOnCall[len(fake.getPublicParamsGeneratorsArgsForCall)]
	fake.getPublicParamsGeneratorsArgsForCall = append(fake.getPublicParamsGeneratorsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetPublicParamsGeneratorsStub
	fakeReturns := fake.getPublicParamsGeneratorsReturns
	fake.recordInvocation("GetPublicParamsGenerators", []interface{}{arg1})
	fake.getPublicParamsGeneratorsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) GetPublicParamsGeneratorsCallCount() int {
	fake.getPublicParamsGeneratorsMutex.RLock()
	defer fake.getPublicParamsGeneratorsMutex.RUnlock()
	return len(fake.getPublicParamsGeneratorsArgsForCall)
}

func (fake *TokenPlatform) GetPublicParamsGeneratorsCalls(stub func(string) generators.PublicParamsGenerator) {
	fake.getPublicParamsGeneratorsMutex.Lock()
	defer fake.getPublicParamsGeneratorsMutex.Unlock()
	fake.GetPublicParamsGeneratorsStub = stub
}

func (fake *TokenPlatform) GetPublicParamsGeneratorsArgsForCall(i int) string {
	fake.getPublicParamsGeneratorsMutex.RLock()
	defer fake.getPublicParamsGeneratorsMutex.RUnlock()
	argsForCall := fake.getPublicParamsGeneratorsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenPlatform) GetPublicParamsGeneratorsReturns(result1 generators.PublicParamsGenerator) {
	fake.getPublicParamsGeneratorsMutex.Lock()
	defer fake.getPublicParamsGeneratorsMutex.Unlock()
	fake.GetPublicParamsGeneratorsStub = nil
	fake.getPublicParamsGeneratorsReturns = struct {
		result1 generators.PublicParamsGenerator
	}{result1}
}

func (fake *TokenPlatform) GetPublicParamsGeneratorsReturnsOnCall(i int, result1 generators.PublicParamsGenerator) {
	fake.getPublicParamsGeneratorsMutex.Lock()
	defer fake.getPublicParamsGeneratorsMutex.Unlock()
	fake.GetPublicParamsGeneratorsStub = nil
	if fake.getPublicParamsGeneratorsReturnsOnCall == nil {
		fake.getPublicParamsGeneratorsReturnsOnCall = make(map[int]struct {
			result1 generators.PublicParamsGenerator
		})
	}
	fake.getPublicParamsGeneratorsReturnsOnCall[i] = struct {
		result1 generators.PublicParamsGenerator
	}{result1}
}

func (fake *TokenPlatform) PublicParameters(arg1 *topology.TMS) []byte {
	fake.publicParametersMutex.Lock()
	ret, specificReturn := fake.publicParametersReturnsOnCall[len(fake.publicParametersArgsForCall)]
	fake.publicParametersArgsForCall = append(fake.publicParametersArgsForCall, struct {
		arg1 *topology.TMS
	}{arg1})
	stub := fake.PublicParametersStub
	fakeReturns := fake.publicParametersReturns
	fake.recordInvocation("PublicParameters", []interface{}{arg1})
	fake.publicParametersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) PublicParametersCallCount() int {
	fake.publicParametersMutex.RLock()
	defer fake.publicParametersMutex.RUnlock()
	return len(fake.publicParametersArgsForCall)
}

func (fake *TokenPlatform) PublicParametersCalls(stub func(*topology.TMS) []byte) {
	fake.publicParametersMutex.Lock()
	defer fake.publicParametersMutex.Unlock()
	fake.PublicParametersStub = stub
}

func (fake *TokenPlatform) PublicParametersArgsForCall(i int) *topology.TMS {
	fake.publicParametersMutex.RLock()
	defer fake.publicParametersMutex.RUnlock()
	argsForCall := fake.publicParametersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenPlatform) PublicParametersReturns(result1 []byte) {
	fake.publicParametersMutex.Lock()
	defer fake.publicParametersMutex.Unlock()
	fake.PublicParametersStub = nil
	fake.publicParametersReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *TokenPlatform) PublicParametersReturnsOnCall(i int, result1 []byte) {
	fake.publicParametersMutex.Lock()
	defer fake.publicParametersMutex.Unlock()
	fake.PublicParametersStub = nil
	if fake.publicParametersReturnsOnCall == nil {
		fake.publicParametersReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.publicParametersReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *TokenPlatform) PublicParametersDir() string {
	fake.publicParametersDirMutex.Lock()
	ret, specificReturn := fake.publicParametersDirReturnsOnCall[len(fake.publicParametersDirArgsForCall)]
	fake.publicParametersDirArgsForCall = append(fake.publicParametersDirArgsForCall, struct {
	}{})
	stub := fake.PublicParametersDirStub
	fakeReturns := fake.publicParametersDirReturns
	fake.recordInvocation("PublicParametersDir", []interface{}{})
	fake.publicParametersDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) PublicParametersDirCallCount() int {
	fake.publicParametersDirMutex.RLock()
	defer fake.publicParametersDirMutex.RUnlock()
	return len(fake.publicParametersDirArgsForCall)
}

func (fake *TokenPlatform) PublicParametersDirCalls(stub func() string) {
	fake.publicParametersDirMutex.Lock()
	defer fake.publicParametersDirMutex.Unlock()
	fake.PublicParametersDirStub = stub
}

func (fake *TokenPlatform) PublicParametersDirReturns(result1 string) {
	fake.publicParametersDirMutex.Lock()
	defer fake.publicParametersDirMutex.Unlock()
	fake.PublicParametersDirStub = nil
	fake.publicParametersDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *TokenPlatform) PublicParametersDirReturnsOnCall(i int, result1 string) {
	fake.publicParametersDirMutex.Lock()
	defer fake.publicParametersDirMutex.Unlock()
	fake.PublicParametersDirStub = nil
	if fake.publicParametersDirReturnsOnCall == nil {
		fake.publicParametersDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.publicParametersDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TokenPlatform) PublicParametersFile(arg1 *topology.TMS) string {
	fake.publicParametersFileMutex.Lock()
	ret, specificReturn := fake.publicParametersFileReturnsOnCall[len(fake.publicParametersFileArgsForCall)]
	fake.publicParametersFileArgsForCall = append(fake.publicParametersFileArgsForCall, struct {
		arg1 *topology.TMS
	}{arg1})
	stub := fake.PublicParametersFileStub
	fakeReturns := fake.publicParametersFileReturns
	fake.recordInvocation("PublicParametersFile", []interface{}{arg1})
	fake.publicParametersFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) PublicParametersFileCallCount() int {
	fake.publicParametersFileMutex.RLock()
	defer fake.publicParametersFileMutex.RUnlock()
	return len(fake.publicParametersFileArgsForCall)
}

func (fake *TokenPlatform) PublicParametersFileCalls(stub func(*topology.TMS) string) {
	fake.publicParametersFileMutex.Lock()
	defer fake.publicParametersFileMutex.Unlock()
	fake.PublicParametersFileStub = stub
}

func (fake *TokenPlatform) PublicParametersFileArgsForCall(i int) *topology.TMS {
	fake.publicParametersFileMutex.RLock()
	defer fake.publicParametersFileMutex.RUnlock()
	argsForCall := fake.publicParametersFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenPlatform) PublicParametersFileReturns(result1 string) {
	fake.publicParametersFileMutex.Lock()
	defer fake.publicParametersFileMutex.Unlock()
	fake.PublicParametersFileStub = nil
	fake.publicParametersFileReturns = struct {
		result1 string
	}{result1}
}

func (fake *TokenPlatform) PublicParametersFileReturnsOnCall(i int, result1 string) {
	fake.publicParametersFileMutex.Lock()
	defer fake.publicParametersFileMutex.Unlock()
	fake.PublicParametersFileStub = nil
	if fake.publicParametersFileReturnsOnCall == nil {
		fake.publicParametersFileReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.publicParametersFileReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TokenPlatform) TokenDir() string {
	fake.tokenDirMutex.Lock()
	ret, specificReturn := fake.tokenDirReturnsOnCall[len(fake.tokenDirArgsForCall)]
	fake.tokenDirArgsForCall = append(fake.tokenDirArgsForCall, struct {
	}{})
	stub := fake.TokenDirStub
	fakeReturns := fake.tokenDirReturns
	fake.recordInvocation("TokenDir", []interface{}{})
	fake.tokenDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenPlatform) TokenDirCallCount() int {
	fake.tokenDirMutex.RLock()
	defer fake.tokenDirMutex.RUnlock()
	return len(fake.tokenDirArgsForCall)
}

func (fake *TokenPlatform) TokenDirCalls(stub func() string) {
	fake.tokenDirMutex.Lock()
	defer fake.tokenDirMutex.Unlock()
	fake.TokenDirStub = stub
}

func (fake *TokenPlatform) TokenDirReturns(result1 string) {
	fake.tokenDirMutex.Lock()
	defer fake.tokenDirMutex.Unlock()
	fake.TokenDirStub = nil
	fake.tokenDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *TokenPlatform) TokenDirReturnsOnCall(i int, result1 string) {
	fake.tokenDirMutex.Lock()
	defer fake.tokenDirMutex.Unlock()
	fake.TokenDirStub = nil
	if fake.tokenDirReturnsOnCall == nil {
		fake.tokenDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tokenDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TokenPlatform) TokenGen(arg1 common.Command) (*gexec.Session, error) {
	fake.tokenGenMutex.Lock()
	ret, specificReturn := fake.tokenGenReturnsOnCall[len(fake.tokenGenArgsForCall)]
	fake.tokenGenArgsForCall = append(fake.tokenGenArgsForCall, struct {
		arg1 common.Command
	}{arg1})
	stub := fake.TokenGenStub
	fakeReturns := fake.tokenGenReturns
	fake.recordInvocation("TokenGen", []interface{}{arg1})
	fake.tokenGenMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenPlatform) TokenGenCallCount() int {
	fake.tokenGenMutex.RLock()
	defer fake.tokenGenMutex.RUnlock()
	return len(fake.tokenGenArgsForCall)
}

func (fake *TokenPlatform) TokenGenCalls(stub func(common.Command) (*gexec.Session, error)) {
	fake.tokenGenMutex.Lock()
	defer fake.tokenGenMutex.Unlock()
	fake.TokenGenStub = stub
}

func (fake *TokenPlatform) TokenGenArgsForCall(i int) common.Command {
	fake.tokenGenMutex.RLock()
	defer fake.tokenGenMutex.RUnlock()
	argsForCall := fake.tokenGenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenPlatform) TokenGenReturns(result1 *gexec.Session, result2 error) {
	fake.tokenGenMutex.Lock()
	defer fake.tokenGenMutex.Unlock()
	fake.TokenGenStub = nil
	fake.tokenGenReturns = struct {
		result1 *gexec.Session
		result2 error
	}{result1, result2}
}

func (fake *TokenPlatform) TokenGenReturnsOnCall(i int, result1 *gexec.Session, result2 error) {
	fake.tokenGenMutex.Lock()
	defer fake.tokenGenMutex.Unlock()
	fake.TokenGenStub = nil
	if fake.tokenGenReturnsOnCall == nil {
		fake.tokenGenReturnsOnCall = make(map[int]struct {
			result1 *gexec.Session
			result2 error
		})
	}
	fake.tokenGenReturnsOnCall[i] = struct {
		result1 *gexec.Session
		result2 error
	}{result1, result2}
}

func (fake *TokenPlatform) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getBuilderMutex.RLock()
	defer fake.getBuilderMutex.RUnlock()
	fake.getContextMutex.RLock()
	defer fake.getContextMutex.RUnlock()
	fake.getCryptoMaterialGeneratorMutex.RLock()
	defer fake.getCryptoMaterialGeneratorMutex.RUnlock()
	fake.getPublicParamsGeneratorsMutex.RLock()
	defer fake.getPublicParamsGeneratorsMutex.RUnlock()
	fake.publicParametersMutex.RLock()
	defer fake.publicParametersMutex.RUnlock()
	fake.publicParametersDirMutex.RLock()
	defer fake.publicParametersDirMutex.RUnlock()
	fake.publicParametersFileMutex.RLock()
	defer fake.publicParametersFileMutex.RUnlock()
	fake.tokenDirMutex.RLock()
	defer fake.tokenDirMutex.RUnlock()
	fake.tokenGenMutex.RLock()
	defer fake.tokenGenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TokenPlatform) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
