// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network/common/rws/translator"
	"github.com/hyperledger-labs/fabric-token-sdk/token/token"
)

type IssueAction struct {
	GetInputsStub        func() []*token.ID
	getInputsMutex       sync.RWMutex
	getInputsArgsForCall []struct {
	}
	getInputsReturns struct {
		result1 []*token.ID
	}
	getInputsReturnsOnCall map[int]struct {
		result1 []*token.ID
	}
	GetIssuerStub        func() []byte
	getIssuerMutex       sync.RWMutex
	getIssuerArgsForCall []struct {
	}
	getIssuerReturns struct {
		result1 []byte
	}
	getIssuerReturnsOnCall map[int]struct {
		result1 []byte
	}
	GetMetadataStub        func() map[string][]byte
	getMetadataMutex       sync.RWMutex
	getMetadataArgsForCall []struct {
	}
	getMetadataReturns struct {
		result1 map[string][]byte
	}
	getMetadataReturnsOnCall map[int]struct {
		result1 map[string][]byte
	}
	GetSerialNumbersStub        func() []string
	getSerialNumbersMutex       sync.RWMutex
	getSerialNumbersArgsForCall []struct {
	}
	getSerialNumbersReturns struct {
		result1 []string
	}
	getSerialNumbersReturnsOnCall map[int]struct {
		result1 []string
	}
	GetSerializedInputsStub        func() ([][]byte, error)
	getSerializedInputsMutex       sync.RWMutex
	getSerializedInputsArgsForCall []struct {
	}
	getSerializedInputsReturns struct {
		result1 [][]byte
		result2 error
	}
	getSerializedInputsReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 error
	}
	GetSerializedOutputsStub        func() ([][]byte, error)
	getSerializedOutputsMutex       sync.RWMutex
	getSerializedOutputsArgsForCall []struct {
	}
	getSerializedOutputsReturns struct {
		result1 [][]byte
		result2 error
	}
	getSerializedOutputsReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 error
	}
	IsAnonymousStub        func() bool
	isAnonymousMutex       sync.RWMutex
	isAnonymousArgsForCall []struct {
	}
	isAnonymousReturns struct {
		result1 bool
	}
	isAnonymousReturnsOnCall map[int]struct {
		result1 bool
	}
	IsGraphHidingStub        func() bool
	isGraphHidingMutex       sync.RWMutex
	isGraphHidingArgsForCall []struct {
	}
	isGraphHidingReturns struct {
		result1 bool
	}
	isGraphHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	NumOutputsStub        func() int
	numOutputsMutex       sync.RWMutex
	numOutputsArgsForCall []struct {
	}
	numOutputsReturns struct {
		result1 int
	}
	numOutputsReturnsOnCall map[int]struct {
		result1 int
	}
	SerializeStub        func() ([]byte, error)
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct {
	}
	serializeReturns struct {
		result1 []byte
		result2 error
	}
	serializeReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *IssueAction) GetInputs() []*token.ID {
	fake.getInputsMutex.Lock()
	ret, specificReturn := fake.getInputsReturnsOnCall[len(fake.getInputsArgsForCall)]
	fake.getInputsArgsForCall = append(fake.getInputsArgsForCall, struct {
	}{})
	stub := fake.GetInputsStub
	fakeReturns := fake.getInputsReturns
	fake.recordInvocation("GetInputs", []interface{}{})
	fake.getInputsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *IssueAction) GetInputsCallCount() int {
	fake.getInputsMutex.RLock()
	defer fake.getInputsMutex.RUnlock()
	return len(fake.getInputsArgsForCall)
}

func (fake *IssueAction) GetInputsCalls(stub func() []*token.ID) {
	fake.getInputsMutex.Lock()
	defer fake.getInputsMutex.Unlock()
	fake.GetInputsStub = stub
}

func (fake *IssueAction) GetInputsReturns(result1 []*token.ID) {
	fake.getInputsMutex.Lock()
	defer fake.getInputsMutex.Unlock()
	fake.GetInputsStub = nil
	fake.getInputsReturns = struct {
		result1 []*token.ID
	}{result1}
}

func (fake *IssueAction) GetInputsReturnsOnCall(i int, result1 []*token.ID) {
	fake.getInputsMutex.Lock()
	defer fake.getInputsMutex.Unlock()
	fake.GetInputsStub = nil
	if fake.getInputsReturnsOnCall == nil {
		fake.getInputsReturnsOnCall = make(map[int]struct {
			result1 []*token.ID
		})
	}
	fake.getInputsReturnsOnCall[i] = struct {
		result1 []*token.ID
	}{result1}
}

func (fake *IssueAction) GetIssuer() []byte {
	fake.getIssuerMutex.Lock()
	ret, specificReturn := fake.getIssuerReturnsOnCall[len(fake.getIssuerArgsForCall)]
	fake.getIssuerArgsForCall = append(fake.getIssuerArgsForCall, struct {
	}{})
	stub := fake.GetIssuerStub
	fakeReturns := fake.getIssuerReturns
	fake.recordInvocation("GetIssuer", []interface{}{})
	fake.getIssuerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *IssueAction) GetIssuerCallCount() int {
	fake.getIssuerMutex.RLock()
	defer fake.getIssuerMutex.RUnlock()
	return len(fake.getIssuerArgsForCall)
}

func (fake *IssueAction) GetIssuerCalls(stub func() []byte) {
	fake.getIssuerMutex.Lock()
	defer fake.getIssuerMutex.Unlock()
	fake.GetIssuerStub = stub
}

func (fake *IssueAction) GetIssuerReturns(result1 []byte) {
	fake.getIssuerMutex.Lock()
	defer fake.getIssuerMutex.Unlock()
	fake.GetIssuerStub = nil
	fake.getIssuerReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *IssueAction) GetIssuerReturnsOnCall(i int, result1 []byte) {
	fake.getIssuerMutex.Lock()
	defer fake.getIssuerMutex.Unlock()
	fake.GetIssuerStub = nil
	if fake.getIssuerReturnsOnCall == nil {
		fake.getIssuerReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.getIssuerReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *IssueAction) GetMetadata() map[string][]byte {
	fake.getMetadataMutex.Lock()
	ret, specificReturn := fake.getMetadataReturnsOnCall[len(fake.getMetadataArgsForCall)]
	fake.getMetadataArgsForCall = append(fake.getMetadataArgsForCall, struct {
	}{})
	stub := fake.GetMetadataStub
	fakeReturns := fake.getMetadataReturns
	fake.recordInvocation("GetMetadata", []interface{}{})
	fake.getMetadataMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *IssueAction) GetMetadataCallCount() int {
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	return len(fake.getMetadataArgsForCall)
}

func (fake *IssueAction) GetMetadataCalls(stub func() map[string][]byte) {
	fake.getMetadataMutex.Lock()
	defer fake.getMetadataMutex.Unlock()
	fake.GetMetadataStub = stub
}

func (fake *IssueAction) GetMetadataReturns(result1 map[string][]byte) {
	fake.getMetadataMutex.Lock()
	defer fake.getMetadataMutex.Unlock()
	fake.GetMetadataStub = nil
	fake.getMetadataReturns = struct {
		result1 map[string][]byte
	}{result1}
}

func (fake *IssueAction) GetMetadataReturnsOnCall(i int, result1 map[string][]byte) {
	fake.getMetadataMutex.Lock()
	defer fake.getMetadataMutex.Unlock()
	fake.GetMetadataStub = nil
	if fake.getMetadataReturnsOnCall == nil {
		fake.getMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string][]byte
		})
	}
	fake.getMetadataReturnsOnCall[i] = struct {
		result1 map[string][]byte
	}{result1}
}

func (fake *IssueAction) GetSerialNumbers() []string {
	fake.getSerialNumbersMutex.Lock()
	ret, specificReturn := fake.getSerialNumbersReturnsOnCall[len(fake.getSerialNumbersArgsForCall)]
	fake.getSerialNumbersArgsForCall = append(fake.getSerialNumbersArgsForCall, struct {
	}{})
	stub := fake.GetSerialNumbersStub
	fakeReturns := fake.getSerialNumbersReturns
	fake.recordInvocation("GetSerialNumbers", []interface{}{})
	fake.getSerialNumbersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *IssueAction) GetSerialNumbersCallCount() int {
	fake.getSerialNumbersMutex.RLock()
	defer fake.getSerialNumbersMutex.RUnlock()
	return len(fake.getSerialNumbersArgsForCall)
}

func (fake *IssueAction) GetSerialNumbersCalls(stub func() []string) {
	fake.getSerialNumbersMutex.Lock()
	defer fake.getSerialNumbersMutex.Unlock()
	fake.GetSerialNumbersStub = stub
}

func (fake *IssueAction) GetSerialNumbersReturns(result1 []string) {
	fake.getSerialNumbersMutex.Lock()
	defer fake.getSerialNumbersMutex.Unlock()
	fake.GetSerialNumbersStub = nil
	fake.getSerialNumbersReturns = struct {
		result1 []string
	}{result1}
}

func (fake *IssueAction) GetSerialNumbersReturnsOnCall(i int, result1 []string) {
	fake.getSerialNumbersMutex.Lock()
	defer fake.getSerialNumbersMutex.Unlock()
	fake.GetSerialNumbersStub = nil
	if fake.getSerialNumbersReturnsOnCall == nil {
		fake.getSerialNumbersReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getSerialNumbersReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *IssueAction) GetSerializedInputs() ([][]byte, error) {
	fake.getSerializedInputsMutex.Lock()
	ret, specificReturn := fake.getSerializedInputsReturnsOnCall[len(fake.getSerializedInputsArgsForCall)]
	fake.getSerializedInputsArgsForCall = append(fake.getSerializedInputsArgsForCall, struct {
	}{})
	stub := fake.GetSerializedInputsStub
	fakeReturns := fake.getSerializedInputsReturns
	fake.recordInvocation("GetSerializedInputs", []interface{}{})
	fake.getSerializedInputsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *IssueAction) GetSerializedInputsCallCount() int {
	fake.getSerializedInputsMutex.RLock()
	defer fake.getSerializedInputsMutex.RUnlock()
	return len(fake.getSerializedInputsArgsForCall)
}

func (fake *IssueAction) GetSerializedInputsCalls(stub func() ([][]byte, error)) {
	fake.getSerializedInputsMutex.Lock()
	defer fake.getSerializedInputsMutex.Unlock()
	fake.GetSerializedInputsStub = stub
}

func (fake *IssueAction) GetSerializedInputsReturns(result1 [][]byte, result2 error) {
	fake.getSerializedInputsMutex.Lock()
	defer fake.getSerializedInputsMutex.Unlock()
	fake.GetSerializedInputsStub = nil
	fake.getSerializedInputsReturns = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *IssueAction) GetSerializedInputsReturnsOnCall(i int, result1 [][]byte, result2 error) {
	fake.getSerializedInputsMutex.Lock()
	defer fake.getSerializedInputsMutex.Unlock()
	fake.GetSerializedInputsStub = nil
	if fake.getSerializedInputsReturnsOnCall == nil {
		fake.getSerializedInputsReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 error
		})
	}
	fake.getSerializedInputsReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *IssueAction) GetSerializedOutputs() ([][]byte, error) {
	fake.getSerializedOutputsMutex.Lock()
	ret, specificReturn := fake.getSerializedOutputsReturnsOnCall[len(fake.getSerializedOutputsArgsForCall)]
	fake.getSerializedOutputsArgsForCall = append(fake.getSerializedOutputsArgsForCall, struct {
	}{})
	stub := fake.GetSerializedOutputsStub
	fakeReturns := fake.getSerializedOutputsReturns
	fake.recordInvocation("GetSerializedOutputs", []interface{}{})
	fake.getSerializedOutputsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *IssueAction) GetSerializedOutputsCallCount() int {
	fake.getSerializedOutputsMutex.RLock()
	defer fake.getSerializedOutputsMutex.RUnlock()
	return len(fake.getSerializedOutputsArgsForCall)
}

func (fake *IssueAction) GetSerializedOutputsCalls(stub func() ([][]byte, error)) {
	fake.getSerializedOutputsMutex.Lock()
	defer fake.getSerializedOutputsMutex.Unlock()
	fake.GetSerializedOutputsStub = stub
}

func (fake *IssueAction) GetSerializedOutputsReturns(result1 [][]byte, result2 error) {
	fake.getSerializedOutputsMutex.Lock()
	defer fake.getSerializedOutputsMutex.Unlock()
	fake.GetSerializedOutputsStub = nil
	fake.getSerializedOutputsReturns = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *IssueAction) GetSerializedOutputsReturnsOnCall(i int, result1 [][]byte, result2 error) {
	fake.getSerializedOutputsMutex.Lock()
	defer fake.getSerializedOutputsMutex.Unlock()
	fake.GetSerializedOutputsStub = nil
	if fake.getSerializedOutputsReturnsOnCall == nil {
		fake.getSerializedOutputsReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 error
		})
	}
	fake.getSerializedOutputsReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *IssueAction) IsAnonymous() bool {
	fake.isAnonymousMutex.Lock()
	ret, specificReturn := fake.isAnonymousReturnsOnCall[len(fake.isAnonymousArgsForCall)]
	fake.isAnonymousArgsForCall = append(fake.isAnonymousArgsForCall, struct {
	}{})
	stub := fake.IsAnonymousStub
	fakeReturns := fake.isAnonymousReturns
	fake.recordInvocation("IsAnonymous", []interface{}{})
	fake.isAnonymousMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *IssueAction) IsAnonymousCallCount() int {
	fake.isAnonymousMutex.RLock()
	defer fake.isAnonymousMutex.RUnlock()
	return len(fake.isAnonymousArgsForCall)
}

func (fake *IssueAction) IsAnonymousCalls(stub func() bool) {
	fake.isAnonymousMutex.Lock()
	defer fake.isAnonymousMutex.Unlock()
	fake.IsAnonymousStub = stub
}

func (fake *IssueAction) IsAnonymousReturns(result1 bool) {
	fake.isAnonymousMutex.Lock()
	defer fake.isAnonymousMutex.Unlock()
	fake.IsAnonymousStub = nil
	fake.isAnonymousReturns = struct {
		result1 bool
	}{result1}
}

func (fake *IssueAction) IsAnonymousReturnsOnCall(i int, result1 bool) {
	fake.isAnonymousMutex.Lock()
	defer fake.isAnonymousMutex.Unlock()
	fake.IsAnonymousStub = nil
	if fake.isAnonymousReturnsOnCall == nil {
		fake.isAnonymousReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAnonymousReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *IssueAction) IsGraphHiding() bool {
	fake.isGraphHidingMutex.Lock()
	ret, specificReturn := fake.isGraphHidingReturnsOnCall[len(fake.isGraphHidingArgsForCall)]
	fake.isGraphHidingArgsForCall = append(fake.isGraphHidingArgsForCall, struct {
	}{})
	stub := fake.IsGraphHidingStub
	fakeReturns := fake.isGraphHidingReturns
	fake.recordInvocation("IsGraphHiding", []interface{}{})
	fake.isGraphHidingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *IssueAction) IsGraphHidingCallCount() int {
	fake.isGraphHidingMutex.RLock()
	defer fake.isGraphHidingMutex.RUnlock()
	return len(fake.isGraphHidingArgsForCall)
}

func (fake *IssueAction) IsGraphHidingCalls(stub func() bool) {
	fake.isGraphHidingMutex.Lock()
	defer fake.isGraphHidingMutex.Unlock()
	fake.IsGraphHidingStub = stub
}

func (fake *IssueAction) IsGraphHidingReturns(result1 bool) {
	fake.isGraphHidingMutex.Lock()
	defer fake.isGraphHidingMutex.Unlock()
	fake.IsGraphHidingStub = nil
	fake.isGraphHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *IssueAction) IsGraphHidingReturnsOnCall(i int, result1 bool) {
	fake.isGraphHidingMutex.Lock()
	defer fake.isGraphHidingMutex.Unlock()
	fake.IsGraphHidingStub = nil
	if fake.isGraphHidingReturnsOnCall == nil {
		fake.isGraphHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isGraphHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *IssueAction) NumOutputs() int {
	fake.numOutputsMutex.Lock()
	ret, specificReturn := fake.numOutputsReturnsOnCall[len(fake.numOutputsArgsForCall)]
	fake.numOutputsArgsForCall = append(fake.numOutputsArgsForCall, struct {
	}{})
	stub := fake.NumOutputsStub
	fakeReturns := fake.numOutputsReturns
	fake.recordInvocation("NumOutputs", []interface{}{})
	fake.numOutputsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *IssueAction) NumOutputsCallCount() int {
	fake.numOutputsMutex.RLock()
	defer fake.numOutputsMutex.RUnlock()
	return len(fake.numOutputsArgsForCall)
}

func (fake *IssueAction) NumOutputsCalls(stub func() int) {
	fake.numOutputsMutex.Lock()
	defer fake.numOutputsMutex.Unlock()
	fake.NumOutputsStub = stub
}

func (fake *IssueAction) NumOutputsReturns(result1 int) {
	fake.numOutputsMutex.Lock()
	defer fake.numOutputsMutex.Unlock()
	fake.NumOutputsStub = nil
	fake.numOutputsReturns = struct {
		result1 int
	}{result1}
}

func (fake *IssueAction) NumOutputsReturnsOnCall(i int, result1 int) {
	fake.numOutputsMutex.Lock()
	defer fake.numOutputsMutex.Unlock()
	fake.NumOutputsStub = nil
	if fake.numOutputsReturnsOnCall == nil {
		fake.numOutputsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numOutputsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *IssueAction) Serialize() ([]byte, error) {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct {
	}{})
	stub := fake.SerializeStub
	fakeReturns := fake.serializeReturns
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *IssueAction) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *IssueAction) SerializeCalls(stub func() ([]byte, error)) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = stub
}

func (fake *IssueAction) SerializeReturns(result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *IssueAction) SerializeReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *IssueAction) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getInputsMutex.RLock()
	defer fake.getInputsMutex.RUnlock()
	fake.getIssuerMutex.RLock()
	defer fake.getIssuerMutex.RUnlock()
	fake.getMetadataMutex.RLock()
	defer fake.getMetadataMutex.RUnlock()
	fake.getSerialNumbersMutex.RLock()
	defer fake.getSerialNumbersMutex.RUnlock()
	fake.getSerializedInputsMutex.RLock()
	defer fake.getSerializedInputsMutex.RUnlock()
	fake.getSerializedOutputsMutex.RLock()
	defer fake.getSerializedOutputsMutex.RUnlock()
	fake.isAnonymousMutex.RLock()
	defer fake.isAnonymousMutex.RUnlock()
	fake.isGraphHidingMutex.RLock()
	defer fake.isGraphHidingMutex.RUnlock()
	fake.numOutputsMutex.RLock()
	defer fake.numOutputsMutex.RUnlock()
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *IssueAction) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ translator.IssueAction = new(IssueAction)
