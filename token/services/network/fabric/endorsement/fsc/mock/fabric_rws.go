// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-smart-client/platform/common/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network/fabric/endorsement/fsc"
)

type FabricRWSet struct {
	AddReadAtStub        func(driver.Namespace, string, driver.RawVersion) error
	addReadAtMutex       sync.RWMutex
	addReadAtArgsForCall []struct {
		arg1 driver.Namespace
		arg2 string
		arg3 driver.RawVersion
	}
	addReadAtReturns struct {
		result1 error
	}
	addReadAtReturnsOnCall map[int]struct {
		result1 error
	}
	AppendRWSetStub        func([]byte, ...driver.Namespace) error
	appendRWSetMutex       sync.RWMutex
	appendRWSetArgsForCall []struct {
		arg1 []byte
		arg2 []driver.Namespace
	}
	appendRWSetReturns struct {
		result1 error
	}
	appendRWSetReturnsOnCall map[int]struct {
		result1 error
	}
	BytesStub        func() ([]byte, error)
	bytesMutex       sync.RWMutex
	bytesArgsForCall []struct {
	}
	bytesReturns struct {
		result1 []byte
		result2 error
	}
	bytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ClearStub        func(driver.Namespace) error
	clearMutex       sync.RWMutex
	clearArgsForCall []struct {
		arg1 driver.Namespace
	}
	clearReturns struct {
		result1 error
	}
	clearReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStateStub        func(driver.Namespace, driver.PKey) error
	deleteStateMutex       sync.RWMutex
	deleteStateArgsForCall []struct {
		arg1 driver.Namespace
		arg2 driver.PKey
	}
	deleteStateReturns struct {
		result1 error
	}
	deleteStateReturnsOnCall map[int]struct {
		result1 error
	}
	DoneStub        func()
	doneMutex       sync.RWMutex
	doneArgsForCall []struct {
	}
	EqualsStub        func(interface{}, ...driver.Namespace) error
	equalsMutex       sync.RWMutex
	equalsArgsForCall []struct {
		arg1 interface{}
		arg2 []driver.Namespace
	}
	equalsReturns struct {
		result1 error
	}
	equalsReturnsOnCall map[int]struct {
		result1 error
	}
	GetDirectStateStub        func(driver.Namespace, driver.PKey) (driver.RawValue, error)
	getDirectStateMutex       sync.RWMutex
	getDirectStateArgsForCall []struct {
		arg1 driver.Namespace
		arg2 driver.PKey
	}
	getDirectStateReturns struct {
		result1 driver.RawValue
		result2 error
	}
	getDirectStateReturnsOnCall map[int]struct {
		result1 driver.RawValue
		result2 error
	}
	GetReadAtStub        func(driver.Namespace, int) (driver.PKey, driver.RawValue, error)
	getReadAtMutex       sync.RWMutex
	getReadAtArgsForCall []struct {
		arg1 driver.Namespace
		arg2 int
	}
	getReadAtReturns struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}
	getReadAtReturnsOnCall map[int]struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}
	GetReadKeyAtStub        func(driver.Namespace, int) (driver.PKey, error)
	getReadKeyAtMutex       sync.RWMutex
	getReadKeyAtArgsForCall []struct {
		arg1 driver.Namespace
		arg2 int
	}
	getReadKeyAtReturns struct {
		result1 driver.PKey
		result2 error
	}
	getReadKeyAtReturnsOnCall map[int]struct {
		result1 driver.PKey
		result2 error
	}
	GetStateStub        func(driver.Namespace, driver.PKey, ...driver.GetStateOpt) (driver.RawValue, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 []driver.GetStateOpt
	}
	getStateReturns struct {
		result1 driver.RawValue
		result2 error
	}
	getStateReturnsOnCall map[int]struct {
		result1 driver.RawValue
		result2 error
	}
	GetStateMetadataStub        func(driver.Namespace, driver.PKey, ...driver.GetStateOpt) (driver.Metadata, error)
	getStateMetadataMutex       sync.RWMutex
	getStateMetadataArgsForCall []struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 []driver.GetStateOpt
	}
	getStateMetadataReturns struct {
		result1 driver.Metadata
		result2 error
	}
	getStateMetadataReturnsOnCall map[int]struct {
		result1 driver.Metadata
		result2 error
	}
	GetWriteAtStub        func(driver.Namespace, int) (driver.PKey, driver.RawValue, error)
	getWriteAtMutex       sync.RWMutex
	getWriteAtArgsForCall []struct {
		arg1 driver.Namespace
		arg2 int
	}
	getWriteAtReturns struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}
	getWriteAtReturnsOnCall map[int]struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}
	IsClosedStub        func() bool
	isClosedMutex       sync.RWMutex
	isClosedArgsForCall []struct {
	}
	isClosedReturns struct {
		result1 bool
	}
	isClosedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsValidStub        func() error
	isValidMutex       sync.RWMutex
	isValidArgsForCall []struct {
	}
	isValidReturns struct {
		result1 error
	}
	isValidReturnsOnCall map[int]struct {
		result1 error
	}
	NamespacesStub        func() []driver.Namespace
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct {
	}
	namespacesReturns struct {
		result1 []driver.Namespace
	}
	namespacesReturnsOnCall map[int]struct {
		result1 []driver.Namespace
	}
	NumReadsStub        func(driver.Namespace) int
	numReadsMutex       sync.RWMutex
	numReadsArgsForCall []struct {
		arg1 driver.Namespace
	}
	numReadsReturns struct {
		result1 int
	}
	numReadsReturnsOnCall map[int]struct {
		result1 int
	}
	NumWritesStub        func(driver.Namespace) int
	numWritesMutex       sync.RWMutex
	numWritesArgsForCall []struct {
		arg1 driver.Namespace
	}
	numWritesReturns struct {
		result1 int
	}
	numWritesReturnsOnCall map[int]struct {
		result1 int
	}
	SetStateStub        func(driver.Namespace, driver.PKey, driver.RawValue) error
	setStateMutex       sync.RWMutex
	setStateArgsForCall []struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 driver.RawValue
	}
	setStateReturns struct {
		result1 error
	}
	setStateReturnsOnCall map[int]struct {
		result1 error
	}
	SetStateMetadataStub        func(driver.Namespace, driver.PKey, driver.Metadata) error
	setStateMetadataMutex       sync.RWMutex
	setStateMetadataArgsForCall []struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 driver.Metadata
	}
	setStateMetadataReturns struct {
		result1 error
	}
	setStateMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FabricRWSet) AddReadAt(arg1 driver.Namespace, arg2 string, arg3 driver.RawVersion) error {
	fake.addReadAtMutex.Lock()
	ret, specificReturn := fake.addReadAtReturnsOnCall[len(fake.addReadAtArgsForCall)]
	fake.addReadAtArgsForCall = append(fake.addReadAtArgsForCall, struct {
		arg1 driver.Namespace
		arg2 string
		arg3 driver.RawVersion
	}{arg1, arg2, arg3})
	stub := fake.AddReadAtStub
	fakeReturns := fake.addReadAtReturns
	fake.recordInvocation("AddReadAt", []interface{}{arg1, arg2, arg3})
	fake.addReadAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) AddReadAtCallCount() int {
	fake.addReadAtMutex.RLock()
	defer fake.addReadAtMutex.RUnlock()
	return len(fake.addReadAtArgsForCall)
}

func (fake *FabricRWSet) AddReadAtCalls(stub func(driver.Namespace, string, driver.RawVersion) error) {
	fake.addReadAtMutex.Lock()
	defer fake.addReadAtMutex.Unlock()
	fake.AddReadAtStub = stub
}

func (fake *FabricRWSet) AddReadAtArgsForCall(i int) (driver.Namespace, string, driver.RawVersion) {
	fake.addReadAtMutex.RLock()
	defer fake.addReadAtMutex.RUnlock()
	argsForCall := fake.addReadAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FabricRWSet) AddReadAtReturns(result1 error) {
	fake.addReadAtMutex.Lock()
	defer fake.addReadAtMutex.Unlock()
	fake.AddReadAtStub = nil
	fake.addReadAtReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) AddReadAtReturnsOnCall(i int, result1 error) {
	fake.addReadAtMutex.Lock()
	defer fake.addReadAtMutex.Unlock()
	fake.AddReadAtStub = nil
	if fake.addReadAtReturnsOnCall == nil {
		fake.addReadAtReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReadAtReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) AppendRWSet(arg1 []byte, arg2 ...driver.Namespace) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.appendRWSetMutex.Lock()
	ret, specificReturn := fake.appendRWSetReturnsOnCall[len(fake.appendRWSetArgsForCall)]
	fake.appendRWSetArgsForCall = append(fake.appendRWSetArgsForCall, struct {
		arg1 []byte
		arg2 []driver.Namespace
	}{arg1Copy, arg2})
	stub := fake.AppendRWSetStub
	fakeReturns := fake.appendRWSetReturns
	fake.recordInvocation("AppendRWSet", []interface{}{arg1Copy, arg2})
	fake.appendRWSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) AppendRWSetCallCount() int {
	fake.appendRWSetMutex.RLock()
	defer fake.appendRWSetMutex.RUnlock()
	return len(fake.appendRWSetArgsForCall)
}

func (fake *FabricRWSet) AppendRWSetCalls(stub func([]byte, ...driver.Namespace) error) {
	fake.appendRWSetMutex.Lock()
	defer fake.appendRWSetMutex.Unlock()
	fake.AppendRWSetStub = stub
}

func (fake *FabricRWSet) AppendRWSetArgsForCall(i int) ([]byte, []driver.Namespace) {
	fake.appendRWSetMutex.RLock()
	defer fake.appendRWSetMutex.RUnlock()
	argsForCall := fake.appendRWSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricRWSet) AppendRWSetReturns(result1 error) {
	fake.appendRWSetMutex.Lock()
	defer fake.appendRWSetMutex.Unlock()
	fake.AppendRWSetStub = nil
	fake.appendRWSetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) AppendRWSetReturnsOnCall(i int, result1 error) {
	fake.appendRWSetMutex.Lock()
	defer fake.appendRWSetMutex.Unlock()
	fake.AppendRWSetStub = nil
	if fake.appendRWSetReturnsOnCall == nil {
		fake.appendRWSetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appendRWSetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) Bytes() ([]byte, error) {
	fake.bytesMutex.Lock()
	ret, specificReturn := fake.bytesReturnsOnCall[len(fake.bytesArgsForCall)]
	fake.bytesArgsForCall = append(fake.bytesArgsForCall, struct {
	}{})
	stub := fake.BytesStub
	fakeReturns := fake.bytesReturns
	fake.recordInvocation("Bytes", []interface{}{})
	fake.bytesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricRWSet) BytesCallCount() int {
	fake.bytesMutex.RLock()
	defer fake.bytesMutex.RUnlock()
	return len(fake.bytesArgsForCall)
}

func (fake *FabricRWSet) BytesCalls(stub func() ([]byte, error)) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = stub
}

func (fake *FabricRWSet) BytesReturns(result1 []byte, result2 error) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = nil
	fake.bytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) BytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = nil
	if fake.bytesReturnsOnCall == nil {
		fake.bytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.bytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) Clear(arg1 driver.Namespace) error {
	fake.clearMutex.Lock()
	ret, specificReturn := fake.clearReturnsOnCall[len(fake.clearArgsForCall)]
	fake.clearArgsForCall = append(fake.clearArgsForCall, struct {
		arg1 driver.Namespace
	}{arg1})
	stub := fake.ClearStub
	fakeReturns := fake.clearReturns
	fake.recordInvocation("Clear", []interface{}{arg1})
	fake.clearMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) ClearCallCount() int {
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	return len(fake.clearArgsForCall)
}

func (fake *FabricRWSet) ClearCalls(stub func(driver.Namespace) error) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = stub
}

func (fake *FabricRWSet) ClearArgsForCall(i int) driver.Namespace {
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	argsForCall := fake.clearArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricRWSet) ClearReturns(result1 error) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = nil
	fake.clearReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) ClearReturnsOnCall(i int, result1 error) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = nil
	if fake.clearReturnsOnCall == nil {
		fake.clearReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) DeleteState(arg1 driver.Namespace, arg2 driver.PKey) error {
	fake.deleteStateMutex.Lock()
	ret, specificReturn := fake.deleteStateReturnsOnCall[len(fake.deleteStateArgsForCall)]
	fake.deleteStateArgsForCall = append(fake.deleteStateArgsForCall, struct {
		arg1 driver.Namespace
		arg2 driver.PKey
	}{arg1, arg2})
	stub := fake.DeleteStateStub
	fakeReturns := fake.deleteStateReturns
	fake.recordInvocation("DeleteState", []interface{}{arg1, arg2})
	fake.deleteStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) DeleteStateCallCount() int {
	fake.deleteStateMutex.RLock()
	defer fake.deleteStateMutex.RUnlock()
	return len(fake.deleteStateArgsForCall)
}

func (fake *FabricRWSet) DeleteStateCalls(stub func(driver.Namespace, driver.PKey) error) {
	fake.deleteStateMutex.Lock()
	defer fake.deleteStateMutex.Unlock()
	fake.DeleteStateStub = stub
}

func (fake *FabricRWSet) DeleteStateArgsForCall(i int) (driver.Namespace, driver.PKey) {
	fake.deleteStateMutex.RLock()
	defer fake.deleteStateMutex.RUnlock()
	argsForCall := fake.deleteStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricRWSet) DeleteStateReturns(result1 error) {
	fake.deleteStateMutex.Lock()
	defer fake.deleteStateMutex.Unlock()
	fake.DeleteStateStub = nil
	fake.deleteStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) DeleteStateReturnsOnCall(i int, result1 error) {
	fake.deleteStateMutex.Lock()
	defer fake.deleteStateMutex.Unlock()
	fake.DeleteStateStub = nil
	if fake.deleteStateReturnsOnCall == nil {
		fake.deleteStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) Done() {
	fake.doneMutex.Lock()
	fake.doneArgsForCall = append(fake.doneArgsForCall, struct {
	}{})
	stub := fake.DoneStub
	fake.recordInvocation("Done", []interface{}{})
	fake.doneMutex.Unlock()
	if stub != nil {
		fake.DoneStub()
	}
}

func (fake *FabricRWSet) DoneCallCount() int {
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	return len(fake.doneArgsForCall)
}

func (fake *FabricRWSet) DoneCalls(stub func()) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = stub
}

func (fake *FabricRWSet) Equals(arg1 interface{}, arg2 ...driver.Namespace) error {
	fake.equalsMutex.Lock()
	ret, specificReturn := fake.equalsReturnsOnCall[len(fake.equalsArgsForCall)]
	fake.equalsArgsForCall = append(fake.equalsArgsForCall, struct {
		arg1 interface{}
		arg2 []driver.Namespace
	}{arg1, arg2})
	stub := fake.EqualsStub
	fakeReturns := fake.equalsReturns
	fake.recordInvocation("Equals", []interface{}{arg1, arg2})
	fake.equalsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) EqualsCallCount() int {
	fake.equalsMutex.RLock()
	defer fake.equalsMutex.RUnlock()
	return len(fake.equalsArgsForCall)
}

func (fake *FabricRWSet) EqualsCalls(stub func(interface{}, ...driver.Namespace) error) {
	fake.equalsMutex.Lock()
	defer fake.equalsMutex.Unlock()
	fake.EqualsStub = stub
}

func (fake *FabricRWSet) EqualsArgsForCall(i int) (interface{}, []driver.Namespace) {
	fake.equalsMutex.RLock()
	defer fake.equalsMutex.RUnlock()
	argsForCall := fake.equalsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricRWSet) EqualsReturns(result1 error) {
	fake.equalsMutex.Lock()
	defer fake.equalsMutex.Unlock()
	fake.EqualsStub = nil
	fake.equalsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) EqualsReturnsOnCall(i int, result1 error) {
	fake.equalsMutex.Lock()
	defer fake.equalsMutex.Unlock()
	fake.EqualsStub = nil
	if fake.equalsReturnsOnCall == nil {
		fake.equalsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.equalsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) GetDirectState(arg1 driver.Namespace, arg2 driver.PKey) (driver.RawValue, error) {
	fake.getDirectStateMutex.Lock()
	ret, specificReturn := fake.getDirectStateReturnsOnCall[len(fake.getDirectStateArgsForCall)]
	fake.getDirectStateArgsForCall = append(fake.getDirectStateArgsForCall, struct {
		arg1 driver.Namespace
		arg2 driver.PKey
	}{arg1, arg2})
	stub := fake.GetDirectStateStub
	fakeReturns := fake.getDirectStateReturns
	fake.recordInvocation("GetDirectState", []interface{}{arg1, arg2})
	fake.getDirectStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricRWSet) GetDirectStateCallCount() int {
	fake.getDirectStateMutex.RLock()
	defer fake.getDirectStateMutex.RUnlock()
	return len(fake.getDirectStateArgsForCall)
}

func (fake *FabricRWSet) GetDirectStateCalls(stub func(driver.Namespace, driver.PKey) (driver.RawValue, error)) {
	fake.getDirectStateMutex.Lock()
	defer fake.getDirectStateMutex.Unlock()
	fake.GetDirectStateStub = stub
}

func (fake *FabricRWSet) GetDirectStateArgsForCall(i int) (driver.Namespace, driver.PKey) {
	fake.getDirectStateMutex.RLock()
	defer fake.getDirectStateMutex.RUnlock()
	argsForCall := fake.getDirectStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricRWSet) GetDirectStateReturns(result1 driver.RawValue, result2 error) {
	fake.getDirectStateMutex.Lock()
	defer fake.getDirectStateMutex.Unlock()
	fake.GetDirectStateStub = nil
	fake.getDirectStateReturns = struct {
		result1 driver.RawValue
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetDirectStateReturnsOnCall(i int, result1 driver.RawValue, result2 error) {
	fake.getDirectStateMutex.Lock()
	defer fake.getDirectStateMutex.Unlock()
	fake.GetDirectStateStub = nil
	if fake.getDirectStateReturnsOnCall == nil {
		fake.getDirectStateReturnsOnCall = make(map[int]struct {
			result1 driver.RawValue
			result2 error
		})
	}
	fake.getDirectStateReturnsOnCall[i] = struct {
		result1 driver.RawValue
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetReadAt(arg1 driver.Namespace, arg2 int) (driver.PKey, driver.RawValue, error) {
	fake.getReadAtMutex.Lock()
	ret, specificReturn := fake.getReadAtReturnsOnCall[len(fake.getReadAtArgsForCall)]
	fake.getReadAtArgsForCall = append(fake.getReadAtArgsForCall, struct {
		arg1 driver.Namespace
		arg2 int
	}{arg1, arg2})
	stub := fake.GetReadAtStub
	fakeReturns := fake.getReadAtReturns
	fake.recordInvocation("GetReadAt", []interface{}{arg1, arg2})
	fake.getReadAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FabricRWSet) GetReadAtCallCount() int {
	fake.getReadAtMutex.RLock()
	defer fake.getReadAtMutex.RUnlock()
	return len(fake.getReadAtArgsForCall)
}

func (fake *FabricRWSet) GetReadAtCalls(stub func(driver.Namespace, int) (driver.PKey, driver.RawValue, error)) {
	fake.getReadAtMutex.Lock()
	defer fake.getReadAtMutex.Unlock()
	fake.GetReadAtStub = stub
}

func (fake *FabricRWSet) GetReadAtArgsForCall(i int) (driver.Namespace, int) {
	fake.getReadAtMutex.RLock()
	defer fake.getReadAtMutex.RUnlock()
	argsForCall := fake.getReadAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricRWSet) GetReadAtReturns(result1 driver.PKey, result2 driver.RawValue, result3 error) {
	fake.getReadAtMutex.Lock()
	defer fake.getReadAtMutex.Unlock()
	fake.GetReadAtStub = nil
	fake.getReadAtReturns = struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}{result1, result2, result3}
}

func (fake *FabricRWSet) GetReadAtReturnsOnCall(i int, result1 driver.PKey, result2 driver.RawValue, result3 error) {
	fake.getReadAtMutex.Lock()
	defer fake.getReadAtMutex.Unlock()
	fake.GetReadAtStub = nil
	if fake.getReadAtReturnsOnCall == nil {
		fake.getReadAtReturnsOnCall = make(map[int]struct {
			result1 driver.PKey
			result2 driver.RawValue
			result3 error
		})
	}
	fake.getReadAtReturnsOnCall[i] = struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}{result1, result2, result3}
}

func (fake *FabricRWSet) GetReadKeyAt(arg1 driver.Namespace, arg2 int) (driver.PKey, error) {
	fake.getReadKeyAtMutex.Lock()
	ret, specificReturn := fake.getReadKeyAtReturnsOnCall[len(fake.getReadKeyAtArgsForCall)]
	fake.getReadKeyAtArgsForCall = append(fake.getReadKeyAtArgsForCall, struct {
		arg1 driver.Namespace
		arg2 int
	}{arg1, arg2})
	stub := fake.GetReadKeyAtStub
	fakeReturns := fake.getReadKeyAtReturns
	fake.recordInvocation("GetReadKeyAt", []interface{}{arg1, arg2})
	fake.getReadKeyAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricRWSet) GetReadKeyAtCallCount() int {
	fake.getReadKeyAtMutex.RLock()
	defer fake.getReadKeyAtMutex.RUnlock()
	return len(fake.getReadKeyAtArgsForCall)
}

func (fake *FabricRWSet) GetReadKeyAtCalls(stub func(driver.Namespace, int) (driver.PKey, error)) {
	fake.getReadKeyAtMutex.Lock()
	defer fake.getReadKeyAtMutex.Unlock()
	fake.GetReadKeyAtStub = stub
}

func (fake *FabricRWSet) GetReadKeyAtArgsForCall(i int) (driver.Namespace, int) {
	fake.getReadKeyAtMutex.RLock()
	defer fake.getReadKeyAtMutex.RUnlock()
	argsForCall := fake.getReadKeyAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricRWSet) GetReadKeyAtReturns(result1 driver.PKey, result2 error) {
	fake.getReadKeyAtMutex.Lock()
	defer fake.getReadKeyAtMutex.Unlock()
	fake.GetReadKeyAtStub = nil
	fake.getReadKeyAtReturns = struct {
		result1 driver.PKey
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetReadKeyAtReturnsOnCall(i int, result1 driver.PKey, result2 error) {
	fake.getReadKeyAtMutex.Lock()
	defer fake.getReadKeyAtMutex.Unlock()
	fake.GetReadKeyAtStub = nil
	if fake.getReadKeyAtReturnsOnCall == nil {
		fake.getReadKeyAtReturnsOnCall = make(map[int]struct {
			result1 driver.PKey
			result2 error
		})
	}
	fake.getReadKeyAtReturnsOnCall[i] = struct {
		result1 driver.PKey
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetState(arg1 driver.Namespace, arg2 driver.PKey, arg3 ...driver.GetStateOpt) (driver.RawValue, error) {
	fake.getStateMutex.Lock()
	ret, specificReturn := fake.getStateReturnsOnCall[len(fake.getStateArgsForCall)]
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 []driver.GetStateOpt
	}{arg1, arg2, arg3})
	stub := fake.GetStateStub
	fakeReturns := fake.getStateReturns
	fake.recordInvocation("GetState", []interface{}{arg1, arg2, arg3})
	fake.getStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricRWSet) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *FabricRWSet) GetStateCalls(stub func(driver.Namespace, driver.PKey, ...driver.GetStateOpt) (driver.RawValue, error)) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = stub
}

func (fake *FabricRWSet) GetStateArgsForCall(i int) (driver.Namespace, driver.PKey, []driver.GetStateOpt) {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	argsForCall := fake.getStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FabricRWSet) GetStateReturns(result1 driver.RawValue, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 driver.RawValue
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetStateReturnsOnCall(i int, result1 driver.RawValue, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	if fake.getStateReturnsOnCall == nil {
		fake.getStateReturnsOnCall = make(map[int]struct {
			result1 driver.RawValue
			result2 error
		})
	}
	fake.getStateReturnsOnCall[i] = struct {
		result1 driver.RawValue
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetStateMetadata(arg1 driver.Namespace, arg2 driver.PKey, arg3 ...driver.GetStateOpt) (driver.Metadata, error) {
	fake.getStateMetadataMutex.Lock()
	ret, specificReturn := fake.getStateMetadataReturnsOnCall[len(fake.getStateMetadataArgsForCall)]
	fake.getStateMetadataArgsForCall = append(fake.getStateMetadataArgsForCall, struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 []driver.GetStateOpt
	}{arg1, arg2, arg3})
	stub := fake.GetStateMetadataStub
	fakeReturns := fake.getStateMetadataReturns
	fake.recordInvocation("GetStateMetadata", []interface{}{arg1, arg2, arg3})
	fake.getStateMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricRWSet) GetStateMetadataCallCount() int {
	fake.getStateMetadataMutex.RLock()
	defer fake.getStateMetadataMutex.RUnlock()
	return len(fake.getStateMetadataArgsForCall)
}

func (fake *FabricRWSet) GetStateMetadataCalls(stub func(driver.Namespace, driver.PKey, ...driver.GetStateOpt) (driver.Metadata, error)) {
	fake.getStateMetadataMutex.Lock()
	defer fake.getStateMetadataMutex.Unlock()
	fake.GetStateMetadataStub = stub
}

func (fake *FabricRWSet) GetStateMetadataArgsForCall(i int) (driver.Namespace, driver.PKey, []driver.GetStateOpt) {
	fake.getStateMetadataMutex.RLock()
	defer fake.getStateMetadataMutex.RUnlock()
	argsForCall := fake.getStateMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FabricRWSet) GetStateMetadataReturns(result1 driver.Metadata, result2 error) {
	fake.getStateMetadataMutex.Lock()
	defer fake.getStateMetadataMutex.Unlock()
	fake.GetStateMetadataStub = nil
	fake.getStateMetadataReturns = struct {
		result1 driver.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetStateMetadataReturnsOnCall(i int, result1 driver.Metadata, result2 error) {
	fake.getStateMetadataMutex.Lock()
	defer fake.getStateMetadataMutex.Unlock()
	fake.GetStateMetadataStub = nil
	if fake.getStateMetadataReturnsOnCall == nil {
		fake.getStateMetadataReturnsOnCall = make(map[int]struct {
			result1 driver.Metadata
			result2 error
		})
	}
	fake.getStateMetadataReturnsOnCall[i] = struct {
		result1 driver.Metadata
		result2 error
	}{result1, result2}
}

func (fake *FabricRWSet) GetWriteAt(arg1 driver.Namespace, arg2 int) (driver.PKey, driver.RawValue, error) {
	fake.getWriteAtMutex.Lock()
	ret, specificReturn := fake.getWriteAtReturnsOnCall[len(fake.getWriteAtArgsForCall)]
	fake.getWriteAtArgsForCall = append(fake.getWriteAtArgsForCall, struct {
		arg1 driver.Namespace
		arg2 int
	}{arg1, arg2})
	stub := fake.GetWriteAtStub
	fakeReturns := fake.getWriteAtReturns
	fake.recordInvocation("GetWriteAt", []interface{}{arg1, arg2})
	fake.getWriteAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FabricRWSet) GetWriteAtCallCount() int {
	fake.getWriteAtMutex.RLock()
	defer fake.getWriteAtMutex.RUnlock()
	return len(fake.getWriteAtArgsForCall)
}

func (fake *FabricRWSet) GetWriteAtCalls(stub func(driver.Namespace, int) (driver.PKey, driver.RawValue, error)) {
	fake.getWriteAtMutex.Lock()
	defer fake.getWriteAtMutex.Unlock()
	fake.GetWriteAtStub = stub
}

func (fake *FabricRWSet) GetWriteAtArgsForCall(i int) (driver.Namespace, int) {
	fake.getWriteAtMutex.RLock()
	defer fake.getWriteAtMutex.RUnlock()
	argsForCall := fake.getWriteAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricRWSet) GetWriteAtReturns(result1 driver.PKey, result2 driver.RawValue, result3 error) {
	fake.getWriteAtMutex.Lock()
	defer fake.getWriteAtMutex.Unlock()
	fake.GetWriteAtStub = nil
	fake.getWriteAtReturns = struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}{result1, result2, result3}
}

func (fake *FabricRWSet) GetWriteAtReturnsOnCall(i int, result1 driver.PKey, result2 driver.RawValue, result3 error) {
	fake.getWriteAtMutex.Lock()
	defer fake.getWriteAtMutex.Unlock()
	fake.GetWriteAtStub = nil
	if fake.getWriteAtReturnsOnCall == nil {
		fake.getWriteAtReturnsOnCall = make(map[int]struct {
			result1 driver.PKey
			result2 driver.RawValue
			result3 error
		})
	}
	fake.getWriteAtReturnsOnCall[i] = struct {
		result1 driver.PKey
		result2 driver.RawValue
		result3 error
	}{result1, result2, result3}
}

func (fake *FabricRWSet) IsClosed() bool {
	fake.isClosedMutex.Lock()
	ret, specificReturn := fake.isClosedReturnsOnCall[len(fake.isClosedArgsForCall)]
	fake.isClosedArgsForCall = append(fake.isClosedArgsForCall, struct {
	}{})
	stub := fake.IsClosedStub
	fakeReturns := fake.isClosedReturns
	fake.recordInvocation("IsClosed", []interface{}{})
	fake.isClosedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) IsClosedCallCount() int {
	fake.isClosedMutex.RLock()
	defer fake.isClosedMutex.RUnlock()
	return len(fake.isClosedArgsForCall)
}

func (fake *FabricRWSet) IsClosedCalls(stub func() bool) {
	fake.isClosedMutex.Lock()
	defer fake.isClosedMutex.Unlock()
	fake.IsClosedStub = stub
}

func (fake *FabricRWSet) IsClosedReturns(result1 bool) {
	fake.isClosedMutex.Lock()
	defer fake.isClosedMutex.Unlock()
	fake.IsClosedStub = nil
	fake.isClosedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FabricRWSet) IsClosedReturnsOnCall(i int, result1 bool) {
	fake.isClosedMutex.Lock()
	defer fake.isClosedMutex.Unlock()
	fake.IsClosedStub = nil
	if fake.isClosedReturnsOnCall == nil {
		fake.isClosedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isClosedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FabricRWSet) IsValid() error {
	fake.isValidMutex.Lock()
	ret, specificReturn := fake.isValidReturnsOnCall[len(fake.isValidArgsForCall)]
	fake.isValidArgsForCall = append(fake.isValidArgsForCall, struct {
	}{})
	stub := fake.IsValidStub
	fakeReturns := fake.isValidReturns
	fake.recordInvocation("IsValid", []interface{}{})
	fake.isValidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) IsValidCallCount() int {
	fake.isValidMutex.RLock()
	defer fake.isValidMutex.RUnlock()
	return len(fake.isValidArgsForCall)
}

func (fake *FabricRWSet) IsValidCalls(stub func() error) {
	fake.isValidMutex.Lock()
	defer fake.isValidMutex.Unlock()
	fake.IsValidStub = stub
}

func (fake *FabricRWSet) IsValidReturns(result1 error) {
	fake.isValidMutex.Lock()
	defer fake.isValidMutex.Unlock()
	fake.IsValidStub = nil
	fake.isValidReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) IsValidReturnsOnCall(i int, result1 error) {
	fake.isValidMutex.Lock()
	defer fake.isValidMutex.Unlock()
	fake.IsValidStub = nil
	if fake.isValidReturnsOnCall == nil {
		fake.isValidReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.isValidReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) Namespaces() []driver.Namespace {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct {
	}{})
	stub := fake.NamespacesStub
	fakeReturns := fake.namespacesReturns
	fake.recordInvocation("Namespaces", []interface{}{})
	fake.namespacesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FabricRWSet) NamespacesCalls(stub func() []driver.Namespace) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = stub
}

func (fake *FabricRWSet) NamespacesReturns(result1 []driver.Namespace) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 []driver.Namespace
	}{result1}
}

func (fake *FabricRWSet) NamespacesReturnsOnCall(i int, result1 []driver.Namespace) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 []driver.Namespace
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 []driver.Namespace
	}{result1}
}

func (fake *FabricRWSet) NumReads(arg1 driver.Namespace) int {
	fake.numReadsMutex.Lock()
	ret, specificReturn := fake.numReadsReturnsOnCall[len(fake.numReadsArgsForCall)]
	fake.numReadsArgsForCall = append(fake.numReadsArgsForCall, struct {
		arg1 driver.Namespace
	}{arg1})
	stub := fake.NumReadsStub
	fakeReturns := fake.numReadsReturns
	fake.recordInvocation("NumReads", []interface{}{arg1})
	fake.numReadsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) NumReadsCallCount() int {
	fake.numReadsMutex.RLock()
	defer fake.numReadsMutex.RUnlock()
	return len(fake.numReadsArgsForCall)
}

func (fake *FabricRWSet) NumReadsCalls(stub func(driver.Namespace) int) {
	fake.numReadsMutex.Lock()
	defer fake.numReadsMutex.Unlock()
	fake.NumReadsStub = stub
}

func (fake *FabricRWSet) NumReadsArgsForCall(i int) driver.Namespace {
	fake.numReadsMutex.RLock()
	defer fake.numReadsMutex.RUnlock()
	argsForCall := fake.numReadsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricRWSet) NumReadsReturns(result1 int) {
	fake.numReadsMutex.Lock()
	defer fake.numReadsMutex.Unlock()
	fake.NumReadsStub = nil
	fake.numReadsReturns = struct {
		result1 int
	}{result1}
}

func (fake *FabricRWSet) NumReadsReturnsOnCall(i int, result1 int) {
	fake.numReadsMutex.Lock()
	defer fake.numReadsMutex.Unlock()
	fake.NumReadsStub = nil
	if fake.numReadsReturnsOnCall == nil {
		fake.numReadsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numReadsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FabricRWSet) NumWrites(arg1 driver.Namespace) int {
	fake.numWritesMutex.Lock()
	ret, specificReturn := fake.numWritesReturnsOnCall[len(fake.numWritesArgsForCall)]
	fake.numWritesArgsForCall = append(fake.numWritesArgsForCall, struct {
		arg1 driver.Namespace
	}{arg1})
	stub := fake.NumWritesStub
	fakeReturns := fake.numWritesReturns
	fake.recordInvocation("NumWrites", []interface{}{arg1})
	fake.numWritesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) NumWritesCallCount() int {
	fake.numWritesMutex.RLock()
	defer fake.numWritesMutex.RUnlock()
	return len(fake.numWritesArgsForCall)
}

func (fake *FabricRWSet) NumWritesCalls(stub func(driver.Namespace) int) {
	fake.numWritesMutex.Lock()
	defer fake.numWritesMutex.Unlock()
	fake.NumWritesStub = stub
}

func (fake *FabricRWSet) NumWritesArgsForCall(i int) driver.Namespace {
	fake.numWritesMutex.RLock()
	defer fake.numWritesMutex.RUnlock()
	argsForCall := fake.numWritesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricRWSet) NumWritesReturns(result1 int) {
	fake.numWritesMutex.Lock()
	defer fake.numWritesMutex.Unlock()
	fake.NumWritesStub = nil
	fake.numWritesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FabricRWSet) NumWritesReturnsOnCall(i int, result1 int) {
	fake.numWritesMutex.Lock()
	defer fake.numWritesMutex.Unlock()
	fake.NumWritesStub = nil
	if fake.numWritesReturnsOnCall == nil {
		fake.numWritesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numWritesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FabricRWSet) SetState(arg1 driver.Namespace, arg2 driver.PKey, arg3 driver.RawValue) error {
	fake.setStateMutex.Lock()
	ret, specificReturn := fake.setStateReturnsOnCall[len(fake.setStateArgsForCall)]
	fake.setStateArgsForCall = append(fake.setStateArgsForCall, struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 driver.RawValue
	}{arg1, arg2, arg3})
	stub := fake.SetStateStub
	fakeReturns := fake.setStateReturns
	fake.recordInvocation("SetState", []interface{}{arg1, arg2, arg3})
	fake.setStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) SetStateCallCount() int {
	fake.setStateMutex.RLock()
	defer fake.setStateMutex.RUnlock()
	return len(fake.setStateArgsForCall)
}

func (fake *FabricRWSet) SetStateCalls(stub func(driver.Namespace, driver.PKey, driver.RawValue) error) {
	fake.setStateMutex.Lock()
	defer fake.setStateMutex.Unlock()
	fake.SetStateStub = stub
}

func (fake *FabricRWSet) SetStateArgsForCall(i int) (driver.Namespace, driver.PKey, driver.RawValue) {
	fake.setStateMutex.RLock()
	defer fake.setStateMutex.RUnlock()
	argsForCall := fake.setStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FabricRWSet) SetStateReturns(result1 error) {
	fake.setStateMutex.Lock()
	defer fake.setStateMutex.Unlock()
	fake.SetStateStub = nil
	fake.setStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) SetStateReturnsOnCall(i int, result1 error) {
	fake.setStateMutex.Lock()
	defer fake.setStateMutex.Unlock()
	fake.SetStateStub = nil
	if fake.setStateReturnsOnCall == nil {
		fake.setStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) SetStateMetadata(arg1 driver.Namespace, arg2 driver.PKey, arg3 driver.Metadata) error {
	fake.setStateMetadataMutex.Lock()
	ret, specificReturn := fake.setStateMetadataReturnsOnCall[len(fake.setStateMetadataArgsForCall)]
	fake.setStateMetadataArgsForCall = append(fake.setStateMetadataArgsForCall, struct {
		arg1 driver.Namespace
		arg2 driver.PKey
		arg3 driver.Metadata
	}{arg1, arg2, arg3})
	stub := fake.SetStateMetadataStub
	fakeReturns := fake.setStateMetadataReturns
	fake.recordInvocation("SetStateMetadata", []interface{}{arg1, arg2, arg3})
	fake.setStateMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricRWSet) SetStateMetadataCallCount() int {
	fake.setStateMetadataMutex.RLock()
	defer fake.setStateMetadataMutex.RUnlock()
	return len(fake.setStateMetadataArgsForCall)
}

func (fake *FabricRWSet) SetStateMetadataCalls(stub func(driver.Namespace, driver.PKey, driver.Metadata) error) {
	fake.setStateMetadataMutex.Lock()
	defer fake.setStateMetadataMutex.Unlock()
	fake.SetStateMetadataStub = stub
}

func (fake *FabricRWSet) SetStateMetadataArgsForCall(i int) (driver.Namespace, driver.PKey, driver.Metadata) {
	fake.setStateMetadataMutex.RLock()
	defer fake.setStateMetadataMutex.RUnlock()
	argsForCall := fake.setStateMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FabricRWSet) SetStateMetadataReturns(result1 error) {
	fake.setStateMetadataMutex.Lock()
	defer fake.setStateMetadataMutex.Unlock()
	fake.SetStateMetadataStub = nil
	fake.setStateMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) SetStateMetadataReturnsOnCall(i int, result1 error) {
	fake.setStateMetadataMutex.Lock()
	defer fake.setStateMetadataMutex.Unlock()
	fake.SetStateMetadataStub = nil
	if fake.setStateMetadataReturnsOnCall == nil {
		fake.setStateMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setStateMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricRWSet) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addReadAtMutex.RLock()
	defer fake.addReadAtMutex.RUnlock()
	fake.appendRWSetMutex.RLock()
	defer fake.appendRWSetMutex.RUnlock()
	fake.bytesMutex.RLock()
	defer fake.bytesMutex.RUnlock()
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	fake.deleteStateMutex.RLock()
	defer fake.deleteStateMutex.RUnlock()
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	fake.equalsMutex.RLock()
	defer fake.equalsMutex.RUnlock()
	fake.getDirectStateMutex.RLock()
	defer fake.getDirectStateMutex.RUnlock()
	fake.getReadAtMutex.RLock()
	defer fake.getReadAtMutex.RUnlock()
	fake.getReadKeyAtMutex.RLock()
	defer fake.getReadKeyAtMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	fake.getStateMetadataMutex.RLock()
	defer fake.getStateMetadataMutex.RUnlock()
	fake.getWriteAtMutex.RLock()
	defer fake.getWriteAtMutex.RUnlock()
	fake.isClosedMutex.RLock()
	defer fake.isClosedMutex.RUnlock()
	fake.isValidMutex.RLock()
	defer fake.isValidMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.numReadsMutex.RLock()
	defer fake.numReadsMutex.RUnlock()
	fake.numWritesMutex.RLock()
	defer fake.numWritesMutex.RUnlock()
	fake.setStateMutex.RLock()
	defer fake.setStateMutex.RUnlock()
	fake.setStateMetadataMutex.RLock()
	defer fake.setStateMetadataMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FabricRWSet) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ fsc.FabricRWSet = new(FabricRWSet)
