// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-smart-client/platform/fabric/driver"
	"github.com/hyperledger-labs/fabric-smart-client/platform/view/view"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network/fabric/endorsement/fsc"
)

type FabricTransaction struct {
	AppendParameterStub        func([]byte)
	appendParameterMutex       sync.RWMutex
	appendParameterArgsForCall []struct {
		arg1 []byte
	}
	AppendProposalResponseStub        func(driver.ProposalResponse) error
	appendProposalResponseMutex       sync.RWMutex
	appendProposalResponseArgsForCall []struct {
		arg1 driver.ProposalResponse
	}
	appendProposalResponseReturns struct {
		result1 error
	}
	appendProposalResponseReturnsOnCall map[int]struct {
		result1 error
	}
	BytesStub        func() ([]byte, error)
	bytesMutex       sync.RWMutex
	bytesArgsForCall []struct {
	}
	bytesReturns struct {
		result1 []byte
		result2 error
	}
	bytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	BytesNoTransientStub        func() ([]byte, error)
	bytesNoTransientMutex       sync.RWMutex
	bytesNoTransientArgsForCall []struct {
	}
	bytesNoTransientReturns struct {
		result1 []byte
		result2 error
	}
	bytesNoTransientReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ChaincodeStub        func() string
	chaincodeMutex       sync.RWMutex
	chaincodeArgsForCall []struct {
	}
	chaincodeReturns struct {
		result1 string
	}
	chaincodeReturnsOnCall map[int]struct {
		result1 string
	}
	ChaincodeVersionStub        func() string
	chaincodeVersionMutex       sync.RWMutex
	chaincodeVersionArgsForCall []struct {
	}
	chaincodeVersionReturns struct {
		result1 string
	}
	chaincodeVersionReturnsOnCall map[int]struct {
		result1 string
	}
	ChannelStub        func() string
	channelMutex       sync.RWMutex
	channelArgsForCall []struct {
	}
	channelReturns struct {
		result1 string
	}
	channelReturnsOnCall map[int]struct {
		result1 string
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CreatorStub        func() view.Identity
	creatorMutex       sync.RWMutex
	creatorArgsForCall []struct {
	}
	creatorReturns struct {
		result1 view.Identity
	}
	creatorReturnsOnCall map[int]struct {
		result1 view.Identity
	}
	DoneStub        func() error
	doneMutex       sync.RWMutex
	doneArgsForCall []struct {
	}
	doneReturns struct {
		result1 error
	}
	doneReturnsOnCall map[int]struct {
		result1 error
	}
	EndorseStub        func() error
	endorseMutex       sync.RWMutex
	endorseArgsForCall []struct {
	}
	endorseReturns struct {
		result1 error
	}
	endorseReturnsOnCall map[int]struct {
		result1 error
	}
	EndorseProposalStub        func() error
	endorseProposalMutex       sync.RWMutex
	endorseProposalArgsForCall []struct {
	}
	endorseProposalReturns struct {
		result1 error
	}
	endorseProposalReturnsOnCall map[int]struct {
		result1 error
	}
	EndorseProposalResponseStub        func() error
	endorseProposalResponseMutex       sync.RWMutex
	endorseProposalResponseArgsForCall []struct {
	}
	endorseProposalResponseReturns struct {
		result1 error
	}
	endorseProposalResponseReturnsOnCall map[int]struct {
		result1 error
	}
	EndorseProposalResponseWithIdentityStub        func(view.Identity) error
	endorseProposalResponseWithIdentityMutex       sync.RWMutex
	endorseProposalResponseWithIdentityArgsForCall []struct {
		arg1 view.Identity
	}
	endorseProposalResponseWithIdentityReturns struct {
		result1 error
	}
	endorseProposalResponseWithIdentityReturnsOnCall map[int]struct {
		result1 error
	}
	EndorseProposalWithIdentityStub        func(view.Identity) error
	endorseProposalWithIdentityMutex       sync.RWMutex
	endorseProposalWithIdentityArgsForCall []struct {
		arg1 view.Identity
	}
	endorseProposalWithIdentityReturns struct {
		result1 error
	}
	endorseProposalWithIdentityReturnsOnCall map[int]struct {
		result1 error
	}
	EndorseWithIdentityStub        func(view.Identity) error
	endorseWithIdentityMutex       sync.RWMutex
	endorseWithIdentityArgsForCall []struct {
		arg1 view.Identity
	}
	endorseWithIdentityReturns struct {
		result1 error
	}
	endorseWithIdentityReturnsOnCall map[int]struct {
		result1 error
	}
	EndorseWithSignerStub        func(view.Identity, driver.Signer) error
	endorseWithSignerMutex       sync.RWMutex
	endorseWithSignerArgsForCall []struct {
		arg1 view.Identity
		arg2 driver.Signer
	}
	endorseWithSignerReturns struct {
		result1 error
	}
	endorseWithSignerReturnsOnCall map[int]struct {
		result1 error
	}
	EnvelopeStub        func() (driver.Envelope, error)
	envelopeMutex       sync.RWMutex
	envelopeArgsForCall []struct {
	}
	envelopeReturns struct {
		result1 driver.Envelope
		result2 error
	}
	envelopeReturnsOnCall map[int]struct {
		result1 driver.Envelope
		result2 error
	}
	FromStub        func(driver.Transaction) error
	fromMutex       sync.RWMutex
	fromArgsForCall []struct {
		arg1 driver.Transaction
	}
	fromReturns struct {
		result1 error
	}
	fromReturnsOnCall map[int]struct {
		result1 error
	}
	FunctionStub        func() string
	functionMutex       sync.RWMutex
	functionArgsForCall []struct {
	}
	functionReturns struct {
		result1 string
	}
	functionReturnsOnCall map[int]struct {
		result1 string
	}
	FunctionAndParametersStub        func() (string, []string)
	functionAndParametersMutex       sync.RWMutex
	functionAndParametersArgsForCall []struct {
	}
	functionAndParametersReturns struct {
		result1 string
		result2 []string
	}
	functionAndParametersReturnsOnCall map[int]struct {
		result1 string
		result2 []string
	}
	GetRWSetStub        func() (driver.RWSet, error)
	getRWSetMutex       sync.RWMutex
	getRWSetArgsForCall []struct {
	}
	getRWSetReturns struct {
		result1 driver.RWSet
		result2 error
	}
	getRWSetReturnsOnCall map[int]struct {
		result1 driver.RWSet
		result2 error
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	NetworkStub        func() string
	networkMutex       sync.RWMutex
	networkArgsForCall []struct {
	}
	networkReturns struct {
		result1 string
	}
	networkReturnsOnCall map[int]struct {
		result1 string
	}
	NonceStub        func() []byte
	nonceMutex       sync.RWMutex
	nonceArgsForCall []struct {
	}
	nonceReturns struct {
		result1 []byte
	}
	nonceReturnsOnCall map[int]struct {
		result1 []byte
	}
	ParametersStub        func() [][]byte
	parametersMutex       sync.RWMutex
	parametersArgsForCall []struct {
	}
	parametersReturns struct {
		result1 [][]byte
	}
	parametersReturnsOnCall map[int]struct {
		result1 [][]byte
	}
	ProposalStub        func() driver.Proposal
	proposalMutex       sync.RWMutex
	proposalArgsForCall []struct {
	}
	proposalReturns struct {
		result1 driver.Proposal
	}
	proposalReturnsOnCall map[int]struct {
		result1 driver.Proposal
	}
	ProposalHasBeenEndorsedByStub        func(view.Identity) error
	proposalHasBeenEndorsedByMutex       sync.RWMutex
	proposalHasBeenEndorsedByArgsForCall []struct {
		arg1 view.Identity
	}
	proposalHasBeenEndorsedByReturns struct {
		result1 error
	}
	proposalHasBeenEndorsedByReturnsOnCall map[int]struct {
		result1 error
	}
	ProposalResponseStub        func() ([]byte, error)
	proposalResponseMutex       sync.RWMutex
	proposalResponseArgsForCall []struct {
	}
	proposalResponseReturns struct {
		result1 []byte
		result2 error
	}
	proposalResponseReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ProposalResponsesStub        func() ([]driver.ProposalResponse, error)
	proposalResponsesMutex       sync.RWMutex
	proposalResponsesArgsForCall []struct {
	}
	proposalResponsesReturns struct {
		result1 []driver.ProposalResponse
		result2 error
	}
	proposalResponsesReturnsOnCall map[int]struct {
		result1 []driver.ProposalResponse
		result2 error
	}
	RWSStub        func() driver.RWSet
	rWSMutex       sync.RWMutex
	rWSArgsForCall []struct {
	}
	rWSReturns struct {
		result1 driver.RWSet
	}
	rWSReturnsOnCall map[int]struct {
		result1 driver.RWSet
	}
	RawStub        func() ([]byte, error)
	rawMutex       sync.RWMutex
	rawArgsForCall []struct {
	}
	rawReturns struct {
		result1 []byte
		result2 error
	}
	rawReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ResetTransientStub        func()
	resetTransientMutex       sync.RWMutex
	resetTransientArgsForCall []struct {
	}
	ResultsStub        func() ([]byte, error)
	resultsMutex       sync.RWMutex
	resultsArgsForCall []struct {
	}
	resultsReturns struct {
		result1 []byte
		result2 error
	}
	resultsReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	SetFromBytesStub        func([]byte) error
	setFromBytesMutex       sync.RWMutex
	setFromBytesArgsForCall []struct {
		arg1 []byte
	}
	setFromBytesReturns struct {
		result1 error
	}
	setFromBytesReturnsOnCall map[int]struct {
		result1 error
	}
	SetFromEnvelopeBytesStub        func([]byte) error
	setFromEnvelopeBytesMutex       sync.RWMutex
	setFromEnvelopeBytesArgsForCall []struct {
		arg1 []byte
	}
	setFromEnvelopeBytesReturns struct {
		result1 error
	}
	setFromEnvelopeBytesReturnsOnCall map[int]struct {
		result1 error
	}
	SetParameterAtStub        func(int, []byte) error
	setParameterAtMutex       sync.RWMutex
	setParameterAtArgsForCall []struct {
		arg1 int
		arg2 []byte
	}
	setParameterAtReturns struct {
		result1 error
	}
	setParameterAtReturnsOnCall map[int]struct {
		result1 error
	}
	SetProposalStub        func(string, string, string, ...string)
	setProposalMutex       sync.RWMutex
	setProposalArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []string
	}
	SetRWSetStub        func() error
	setRWSetMutex       sync.RWMutex
	setRWSetArgsForCall []struct {
	}
	setRWSetReturns struct {
		result1 error
	}
	setRWSetReturnsOnCall map[int]struct {
		result1 error
	}
	SignedProposalStub        func() driver.SignedProposal
	signedProposalMutex       sync.RWMutex
	signedProposalArgsForCall []struct {
	}
	signedProposalReturns struct {
		result1 driver.SignedProposal
	}
	signedProposalReturnsOnCall map[int]struct {
		result1 driver.SignedProposal
	}
	StoreTransientStub        func() error
	storeTransientMutex       sync.RWMutex
	storeTransientArgsForCall []struct {
	}
	storeTransientReturns struct {
		result1 error
	}
	storeTransientReturnsOnCall map[int]struct {
		result1 error
	}
	TransientStub        func() driver.TransientMap
	transientMutex       sync.RWMutex
	transientArgsForCall []struct {
	}
	transientReturns struct {
		result1 driver.TransientMap
	}
	transientReturnsOnCall map[int]struct {
		result1 driver.TransientMap
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FabricTransaction) AppendParameter(arg1 []byte) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.appendParameterMutex.Lock()
	fake.appendParameterArgsForCall = append(fake.appendParameterArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.AppendParameterStub
	fake.recordInvocation("AppendParameter", []interface{}{arg1Copy})
	fake.appendParameterMutex.Unlock()
	if stub != nil {
		fake.AppendParameterStub(arg1)
	}
}

func (fake *FabricTransaction) AppendParameterCallCount() int {
	fake.appendParameterMutex.RLock()
	defer fake.appendParameterMutex.RUnlock()
	return len(fake.appendParameterArgsForCall)
}

func (fake *FabricTransaction) AppendParameterCalls(stub func([]byte)) {
	fake.appendParameterMutex.Lock()
	defer fake.appendParameterMutex.Unlock()
	fake.AppendParameterStub = stub
}

func (fake *FabricTransaction) AppendParameterArgsForCall(i int) []byte {
	fake.appendParameterMutex.RLock()
	defer fake.appendParameterMutex.RUnlock()
	argsForCall := fake.appendParameterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) AppendProposalResponse(arg1 driver.ProposalResponse) error {
	fake.appendProposalResponseMutex.Lock()
	ret, specificReturn := fake.appendProposalResponseReturnsOnCall[len(fake.appendProposalResponseArgsForCall)]
	fake.appendProposalResponseArgsForCall = append(fake.appendProposalResponseArgsForCall, struct {
		arg1 driver.ProposalResponse
	}{arg1})
	stub := fake.AppendProposalResponseStub
	fakeReturns := fake.appendProposalResponseReturns
	fake.recordInvocation("AppendProposalResponse", []interface{}{arg1})
	fake.appendProposalResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) AppendProposalResponseCallCount() int {
	fake.appendProposalResponseMutex.RLock()
	defer fake.appendProposalResponseMutex.RUnlock()
	return len(fake.appendProposalResponseArgsForCall)
}

func (fake *FabricTransaction) AppendProposalResponseCalls(stub func(driver.ProposalResponse) error) {
	fake.appendProposalResponseMutex.Lock()
	defer fake.appendProposalResponseMutex.Unlock()
	fake.AppendProposalResponseStub = stub
}

func (fake *FabricTransaction) AppendProposalResponseArgsForCall(i int) driver.ProposalResponse {
	fake.appendProposalResponseMutex.RLock()
	defer fake.appendProposalResponseMutex.RUnlock()
	argsForCall := fake.appendProposalResponseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) AppendProposalResponseReturns(result1 error) {
	fake.appendProposalResponseMutex.Lock()
	defer fake.appendProposalResponseMutex.Unlock()
	fake.AppendProposalResponseStub = nil
	fake.appendProposalResponseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) AppendProposalResponseReturnsOnCall(i int, result1 error) {
	fake.appendProposalResponseMutex.Lock()
	defer fake.appendProposalResponseMutex.Unlock()
	fake.AppendProposalResponseStub = nil
	if fake.appendProposalResponseReturnsOnCall == nil {
		fake.appendProposalResponseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.appendProposalResponseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) Bytes() ([]byte, error) {
	fake.bytesMutex.Lock()
	ret, specificReturn := fake.bytesReturnsOnCall[len(fake.bytesArgsForCall)]
	fake.bytesArgsForCall = append(fake.bytesArgsForCall, struct {
	}{})
	stub := fake.BytesStub
	fakeReturns := fake.bytesReturns
	fake.recordInvocation("Bytes", []interface{}{})
	fake.bytesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) BytesCallCount() int {
	fake.bytesMutex.RLock()
	defer fake.bytesMutex.RUnlock()
	return len(fake.bytesArgsForCall)
}

func (fake *FabricTransaction) BytesCalls(stub func() ([]byte, error)) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = stub
}

func (fake *FabricTransaction) BytesReturns(result1 []byte, result2 error) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = nil
	fake.bytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) BytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = nil
	if fake.bytesReturnsOnCall == nil {
		fake.bytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.bytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) BytesNoTransient() ([]byte, error) {
	fake.bytesNoTransientMutex.Lock()
	ret, specificReturn := fake.bytesNoTransientReturnsOnCall[len(fake.bytesNoTransientArgsForCall)]
	fake.bytesNoTransientArgsForCall = append(fake.bytesNoTransientArgsForCall, struct {
	}{})
	stub := fake.BytesNoTransientStub
	fakeReturns := fake.bytesNoTransientReturns
	fake.recordInvocation("BytesNoTransient", []interface{}{})
	fake.bytesNoTransientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) BytesNoTransientCallCount() int {
	fake.bytesNoTransientMutex.RLock()
	defer fake.bytesNoTransientMutex.RUnlock()
	return len(fake.bytesNoTransientArgsForCall)
}

func (fake *FabricTransaction) BytesNoTransientCalls(stub func() ([]byte, error)) {
	fake.bytesNoTransientMutex.Lock()
	defer fake.bytesNoTransientMutex.Unlock()
	fake.BytesNoTransientStub = stub
}

func (fake *FabricTransaction) BytesNoTransientReturns(result1 []byte, result2 error) {
	fake.bytesNoTransientMutex.Lock()
	defer fake.bytesNoTransientMutex.Unlock()
	fake.BytesNoTransientStub = nil
	fake.bytesNoTransientReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) BytesNoTransientReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.bytesNoTransientMutex.Lock()
	defer fake.bytesNoTransientMutex.Unlock()
	fake.BytesNoTransientStub = nil
	if fake.bytesNoTransientReturnsOnCall == nil {
		fake.bytesNoTransientReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.bytesNoTransientReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) Chaincode() string {
	fake.chaincodeMutex.Lock()
	ret, specificReturn := fake.chaincodeReturnsOnCall[len(fake.chaincodeArgsForCall)]
	fake.chaincodeArgsForCall = append(fake.chaincodeArgsForCall, struct {
	}{})
	stub := fake.ChaincodeStub
	fakeReturns := fake.chaincodeReturns
	fake.recordInvocation("Chaincode", []interface{}{})
	fake.chaincodeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) ChaincodeCallCount() int {
	fake.chaincodeMutex.RLock()
	defer fake.chaincodeMutex.RUnlock()
	return len(fake.chaincodeArgsForCall)
}

func (fake *FabricTransaction) ChaincodeCalls(stub func() string) {
	fake.chaincodeMutex.Lock()
	defer fake.chaincodeMutex.Unlock()
	fake.ChaincodeStub = stub
}

func (fake *FabricTransaction) ChaincodeReturns(result1 string) {
	fake.chaincodeMutex.Lock()
	defer fake.chaincodeMutex.Unlock()
	fake.ChaincodeStub = nil
	fake.chaincodeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) ChaincodeReturnsOnCall(i int, result1 string) {
	fake.chaincodeMutex.Lock()
	defer fake.chaincodeMutex.Unlock()
	fake.ChaincodeStub = nil
	if fake.chaincodeReturnsOnCall == nil {
		fake.chaincodeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.chaincodeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) ChaincodeVersion() string {
	fake.chaincodeVersionMutex.Lock()
	ret, specificReturn := fake.chaincodeVersionReturnsOnCall[len(fake.chaincodeVersionArgsForCall)]
	fake.chaincodeVersionArgsForCall = append(fake.chaincodeVersionArgsForCall, struct {
	}{})
	stub := fake.ChaincodeVersionStub
	fakeReturns := fake.chaincodeVersionReturns
	fake.recordInvocation("ChaincodeVersion", []interface{}{})
	fake.chaincodeVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) ChaincodeVersionCallCount() int {
	fake.chaincodeVersionMutex.RLock()
	defer fake.chaincodeVersionMutex.RUnlock()
	return len(fake.chaincodeVersionArgsForCall)
}

func (fake *FabricTransaction) ChaincodeVersionCalls(stub func() string) {
	fake.chaincodeVersionMutex.Lock()
	defer fake.chaincodeVersionMutex.Unlock()
	fake.ChaincodeVersionStub = stub
}

func (fake *FabricTransaction) ChaincodeVersionReturns(result1 string) {
	fake.chaincodeVersionMutex.Lock()
	defer fake.chaincodeVersionMutex.Unlock()
	fake.ChaincodeVersionStub = nil
	fake.chaincodeVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) ChaincodeVersionReturnsOnCall(i int, result1 string) {
	fake.chaincodeVersionMutex.Lock()
	defer fake.chaincodeVersionMutex.Unlock()
	fake.ChaincodeVersionStub = nil
	if fake.chaincodeVersionReturnsOnCall == nil {
		fake.chaincodeVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.chaincodeVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) Channel() string {
	fake.channelMutex.Lock()
	ret, specificReturn := fake.channelReturnsOnCall[len(fake.channelArgsForCall)]
	fake.channelArgsForCall = append(fake.channelArgsForCall, struct {
	}{})
	stub := fake.ChannelStub
	fakeReturns := fake.channelReturns
	fake.recordInvocation("Channel", []interface{}{})
	fake.channelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) ChannelCallCount() int {
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	return len(fake.channelArgsForCall)
}

func (fake *FabricTransaction) ChannelCalls(stub func() string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = stub
}

func (fake *FabricTransaction) ChannelReturns(result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	fake.channelReturns = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) ChannelReturnsOnCall(i int, result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	if fake.channelReturnsOnCall == nil {
		fake.channelReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.channelReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FabricTransaction) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FabricTransaction) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FabricTransaction) Creator() view.Identity {
	fake.creatorMutex.Lock()
	ret, specificReturn := fake.creatorReturnsOnCall[len(fake.creatorArgsForCall)]
	fake.creatorArgsForCall = append(fake.creatorArgsForCall, struct {
	}{})
	stub := fake.CreatorStub
	fakeReturns := fake.creatorReturns
	fake.recordInvocation("Creator", []interface{}{})
	fake.creatorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) CreatorCallCount() int {
	fake.creatorMutex.RLock()
	defer fake.creatorMutex.RUnlock()
	return len(fake.creatorArgsForCall)
}

func (fake *FabricTransaction) CreatorCalls(stub func() view.Identity) {
	fake.creatorMutex.Lock()
	defer fake.creatorMutex.Unlock()
	fake.CreatorStub = stub
}

func (fake *FabricTransaction) CreatorReturns(result1 view.Identity) {
	fake.creatorMutex.Lock()
	defer fake.creatorMutex.Unlock()
	fake.CreatorStub = nil
	fake.creatorReturns = struct {
		result1 view.Identity
	}{result1}
}

func (fake *FabricTransaction) CreatorReturnsOnCall(i int, result1 view.Identity) {
	fake.creatorMutex.Lock()
	defer fake.creatorMutex.Unlock()
	fake.CreatorStub = nil
	if fake.creatorReturnsOnCall == nil {
		fake.creatorReturnsOnCall = make(map[int]struct {
			result1 view.Identity
		})
	}
	fake.creatorReturnsOnCall[i] = struct {
		result1 view.Identity
	}{result1}
}

func (fake *FabricTransaction) Done() error {
	fake.doneMutex.Lock()
	ret, specificReturn := fake.doneReturnsOnCall[len(fake.doneArgsForCall)]
	fake.doneArgsForCall = append(fake.doneArgsForCall, struct {
	}{})
	stub := fake.DoneStub
	fakeReturns := fake.doneReturns
	fake.recordInvocation("Done", []interface{}{})
	fake.doneMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) DoneCallCount() int {
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	return len(fake.doneArgsForCall)
}

func (fake *FabricTransaction) DoneCalls(stub func() error) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = stub
}

func (fake *FabricTransaction) DoneReturns(result1 error) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = nil
	fake.doneReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) DoneReturnsOnCall(i int, result1 error) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = nil
	if fake.doneReturnsOnCall == nil {
		fake.doneReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doneReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) Endorse() error {
	fake.endorseMutex.Lock()
	ret, specificReturn := fake.endorseReturnsOnCall[len(fake.endorseArgsForCall)]
	fake.endorseArgsForCall = append(fake.endorseArgsForCall, struct {
	}{})
	stub := fake.EndorseStub
	fakeReturns := fake.endorseReturns
	fake.recordInvocation("Endorse", []interface{}{})
	fake.endorseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) EndorseCallCount() int {
	fake.endorseMutex.RLock()
	defer fake.endorseMutex.RUnlock()
	return len(fake.endorseArgsForCall)
}

func (fake *FabricTransaction) EndorseCalls(stub func() error) {
	fake.endorseMutex.Lock()
	defer fake.endorseMutex.Unlock()
	fake.EndorseStub = stub
}

func (fake *FabricTransaction) EndorseReturns(result1 error) {
	fake.endorseMutex.Lock()
	defer fake.endorseMutex.Unlock()
	fake.EndorseStub = nil
	fake.endorseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseReturnsOnCall(i int, result1 error) {
	fake.endorseMutex.Lock()
	defer fake.endorseMutex.Unlock()
	fake.EndorseStub = nil
	if fake.endorseReturnsOnCall == nil {
		fake.endorseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endorseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposal() error {
	fake.endorseProposalMutex.Lock()
	ret, specificReturn := fake.endorseProposalReturnsOnCall[len(fake.endorseProposalArgsForCall)]
	fake.endorseProposalArgsForCall = append(fake.endorseProposalArgsForCall, struct {
	}{})
	stub := fake.EndorseProposalStub
	fakeReturns := fake.endorseProposalReturns
	fake.recordInvocation("EndorseProposal", []interface{}{})
	fake.endorseProposalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) EndorseProposalCallCount() int {
	fake.endorseProposalMutex.RLock()
	defer fake.endorseProposalMutex.RUnlock()
	return len(fake.endorseProposalArgsForCall)
}

func (fake *FabricTransaction) EndorseProposalCalls(stub func() error) {
	fake.endorseProposalMutex.Lock()
	defer fake.endorseProposalMutex.Unlock()
	fake.EndorseProposalStub = stub
}

func (fake *FabricTransaction) EndorseProposalReturns(result1 error) {
	fake.endorseProposalMutex.Lock()
	defer fake.endorseProposalMutex.Unlock()
	fake.EndorseProposalStub = nil
	fake.endorseProposalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposalReturnsOnCall(i int, result1 error) {
	fake.endorseProposalMutex.Lock()
	defer fake.endorseProposalMutex.Unlock()
	fake.EndorseProposalStub = nil
	if fake.endorseProposalReturnsOnCall == nil {
		fake.endorseProposalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endorseProposalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposalResponse() error {
	fake.endorseProposalResponseMutex.Lock()
	ret, specificReturn := fake.endorseProposalResponseReturnsOnCall[len(fake.endorseProposalResponseArgsForCall)]
	fake.endorseProposalResponseArgsForCall = append(fake.endorseProposalResponseArgsForCall, struct {
	}{})
	stub := fake.EndorseProposalResponseStub
	fakeReturns := fake.endorseProposalResponseReturns
	fake.recordInvocation("EndorseProposalResponse", []interface{}{})
	fake.endorseProposalResponseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) EndorseProposalResponseCallCount() int {
	fake.endorseProposalResponseMutex.RLock()
	defer fake.endorseProposalResponseMutex.RUnlock()
	return len(fake.endorseProposalResponseArgsForCall)
}

func (fake *FabricTransaction) EndorseProposalResponseCalls(stub func() error) {
	fake.endorseProposalResponseMutex.Lock()
	defer fake.endorseProposalResponseMutex.Unlock()
	fake.EndorseProposalResponseStub = stub
}

func (fake *FabricTransaction) EndorseProposalResponseReturns(result1 error) {
	fake.endorseProposalResponseMutex.Lock()
	defer fake.endorseProposalResponseMutex.Unlock()
	fake.EndorseProposalResponseStub = nil
	fake.endorseProposalResponseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposalResponseReturnsOnCall(i int, result1 error) {
	fake.endorseProposalResponseMutex.Lock()
	defer fake.endorseProposalResponseMutex.Unlock()
	fake.EndorseProposalResponseStub = nil
	if fake.endorseProposalResponseReturnsOnCall == nil {
		fake.endorseProposalResponseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endorseProposalResponseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposalResponseWithIdentity(arg1 view.Identity) error {
	fake.endorseProposalResponseWithIdentityMutex.Lock()
	ret, specificReturn := fake.endorseProposalResponseWithIdentityReturnsOnCall[len(fake.endorseProposalResponseWithIdentityArgsForCall)]
	fake.endorseProposalResponseWithIdentityArgsForCall = append(fake.endorseProposalResponseWithIdentityArgsForCall, struct {
		arg1 view.Identity
	}{arg1})
	stub := fake.EndorseProposalResponseWithIdentityStub
	fakeReturns := fake.endorseProposalResponseWithIdentityReturns
	fake.recordInvocation("EndorseProposalResponseWithIdentity", []interface{}{arg1})
	fake.endorseProposalResponseWithIdentityMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) EndorseProposalResponseWithIdentityCallCount() int {
	fake.endorseProposalResponseWithIdentityMutex.RLock()
	defer fake.endorseProposalResponseWithIdentityMutex.RUnlock()
	return len(fake.endorseProposalResponseWithIdentityArgsForCall)
}

func (fake *FabricTransaction) EndorseProposalResponseWithIdentityCalls(stub func(view.Identity) error) {
	fake.endorseProposalResponseWithIdentityMutex.Lock()
	defer fake.endorseProposalResponseWithIdentityMutex.Unlock()
	fake.EndorseProposalResponseWithIdentityStub = stub
}

func (fake *FabricTransaction) EndorseProposalResponseWithIdentityArgsForCall(i int) view.Identity {
	fake.endorseProposalResponseWithIdentityMutex.RLock()
	defer fake.endorseProposalResponseWithIdentityMutex.RUnlock()
	argsForCall := fake.endorseProposalResponseWithIdentityArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) EndorseProposalResponseWithIdentityReturns(result1 error) {
	fake.endorseProposalResponseWithIdentityMutex.Lock()
	defer fake.endorseProposalResponseWithIdentityMutex.Unlock()
	fake.EndorseProposalResponseWithIdentityStub = nil
	fake.endorseProposalResponseWithIdentityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposalResponseWithIdentityReturnsOnCall(i int, result1 error) {
	fake.endorseProposalResponseWithIdentityMutex.Lock()
	defer fake.endorseProposalResponseWithIdentityMutex.Unlock()
	fake.EndorseProposalResponseWithIdentityStub = nil
	if fake.endorseProposalResponseWithIdentityReturnsOnCall == nil {
		fake.endorseProposalResponseWithIdentityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endorseProposalResponseWithIdentityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposalWithIdentity(arg1 view.Identity) error {
	fake.endorseProposalWithIdentityMutex.Lock()
	ret, specificReturn := fake.endorseProposalWithIdentityReturnsOnCall[len(fake.endorseProposalWithIdentityArgsForCall)]
	fake.endorseProposalWithIdentityArgsForCall = append(fake.endorseProposalWithIdentityArgsForCall, struct {
		arg1 view.Identity
	}{arg1})
	stub := fake.EndorseProposalWithIdentityStub
	fakeReturns := fake.endorseProposalWithIdentityReturns
	fake.recordInvocation("EndorseProposalWithIdentity", []interface{}{arg1})
	fake.endorseProposalWithIdentityMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) EndorseProposalWithIdentityCallCount() int {
	fake.endorseProposalWithIdentityMutex.RLock()
	defer fake.endorseProposalWithIdentityMutex.RUnlock()
	return len(fake.endorseProposalWithIdentityArgsForCall)
}

func (fake *FabricTransaction) EndorseProposalWithIdentityCalls(stub func(view.Identity) error) {
	fake.endorseProposalWithIdentityMutex.Lock()
	defer fake.endorseProposalWithIdentityMutex.Unlock()
	fake.EndorseProposalWithIdentityStub = stub
}

func (fake *FabricTransaction) EndorseProposalWithIdentityArgsForCall(i int) view.Identity {
	fake.endorseProposalWithIdentityMutex.RLock()
	defer fake.endorseProposalWithIdentityMutex.RUnlock()
	argsForCall := fake.endorseProposalWithIdentityArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) EndorseProposalWithIdentityReturns(result1 error) {
	fake.endorseProposalWithIdentityMutex.Lock()
	defer fake.endorseProposalWithIdentityMutex.Unlock()
	fake.EndorseProposalWithIdentityStub = nil
	fake.endorseProposalWithIdentityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseProposalWithIdentityReturnsOnCall(i int, result1 error) {
	fake.endorseProposalWithIdentityMutex.Lock()
	defer fake.endorseProposalWithIdentityMutex.Unlock()
	fake.EndorseProposalWithIdentityStub = nil
	if fake.endorseProposalWithIdentityReturnsOnCall == nil {
		fake.endorseProposalWithIdentityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endorseProposalWithIdentityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseWithIdentity(arg1 view.Identity) error {
	fake.endorseWithIdentityMutex.Lock()
	ret, specificReturn := fake.endorseWithIdentityReturnsOnCall[len(fake.endorseWithIdentityArgsForCall)]
	fake.endorseWithIdentityArgsForCall = append(fake.endorseWithIdentityArgsForCall, struct {
		arg1 view.Identity
	}{arg1})
	stub := fake.EndorseWithIdentityStub
	fakeReturns := fake.endorseWithIdentityReturns
	fake.recordInvocation("EndorseWithIdentity", []interface{}{arg1})
	fake.endorseWithIdentityMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) EndorseWithIdentityCallCount() int {
	fake.endorseWithIdentityMutex.RLock()
	defer fake.endorseWithIdentityMutex.RUnlock()
	return len(fake.endorseWithIdentityArgsForCall)
}

func (fake *FabricTransaction) EndorseWithIdentityCalls(stub func(view.Identity) error) {
	fake.endorseWithIdentityMutex.Lock()
	defer fake.endorseWithIdentityMutex.Unlock()
	fake.EndorseWithIdentityStub = stub
}

func (fake *FabricTransaction) EndorseWithIdentityArgsForCall(i int) view.Identity {
	fake.endorseWithIdentityMutex.RLock()
	defer fake.endorseWithIdentityMutex.RUnlock()
	argsForCall := fake.endorseWithIdentityArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) EndorseWithIdentityReturns(result1 error) {
	fake.endorseWithIdentityMutex.Lock()
	defer fake.endorseWithIdentityMutex.Unlock()
	fake.EndorseWithIdentityStub = nil
	fake.endorseWithIdentityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseWithIdentityReturnsOnCall(i int, result1 error) {
	fake.endorseWithIdentityMutex.Lock()
	defer fake.endorseWithIdentityMutex.Unlock()
	fake.EndorseWithIdentityStub = nil
	if fake.endorseWithIdentityReturnsOnCall == nil {
		fake.endorseWithIdentityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endorseWithIdentityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseWithSigner(arg1 view.Identity, arg2 driver.Signer) error {
	fake.endorseWithSignerMutex.Lock()
	ret, specificReturn := fake.endorseWithSignerReturnsOnCall[len(fake.endorseWithSignerArgsForCall)]
	fake.endorseWithSignerArgsForCall = append(fake.endorseWithSignerArgsForCall, struct {
		arg1 view.Identity
		arg2 driver.Signer
	}{arg1, arg2})
	stub := fake.EndorseWithSignerStub
	fakeReturns := fake.endorseWithSignerReturns
	fake.recordInvocation("EndorseWithSigner", []interface{}{arg1, arg2})
	fake.endorseWithSignerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) EndorseWithSignerCallCount() int {
	fake.endorseWithSignerMutex.RLock()
	defer fake.endorseWithSignerMutex.RUnlock()
	return len(fake.endorseWithSignerArgsForCall)
}

func (fake *FabricTransaction) EndorseWithSignerCalls(stub func(view.Identity, driver.Signer) error) {
	fake.endorseWithSignerMutex.Lock()
	defer fake.endorseWithSignerMutex.Unlock()
	fake.EndorseWithSignerStub = stub
}

func (fake *FabricTransaction) EndorseWithSignerArgsForCall(i int) (view.Identity, driver.Signer) {
	fake.endorseWithSignerMutex.RLock()
	defer fake.endorseWithSignerMutex.RUnlock()
	argsForCall := fake.endorseWithSignerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricTransaction) EndorseWithSignerReturns(result1 error) {
	fake.endorseWithSignerMutex.Lock()
	defer fake.endorseWithSignerMutex.Unlock()
	fake.EndorseWithSignerStub = nil
	fake.endorseWithSignerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) EndorseWithSignerReturnsOnCall(i int, result1 error) {
	fake.endorseWithSignerMutex.Lock()
	defer fake.endorseWithSignerMutex.Unlock()
	fake.EndorseWithSignerStub = nil
	if fake.endorseWithSignerReturnsOnCall == nil {
		fake.endorseWithSignerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.endorseWithSignerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) Envelope() (driver.Envelope, error) {
	fake.envelopeMutex.Lock()
	ret, specificReturn := fake.envelopeReturnsOnCall[len(fake.envelopeArgsForCall)]
	fake.envelopeArgsForCall = append(fake.envelopeArgsForCall, struct {
	}{})
	stub := fake.EnvelopeStub
	fakeReturns := fake.envelopeReturns
	fake.recordInvocation("Envelope", []interface{}{})
	fake.envelopeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) EnvelopeCallCount() int {
	fake.envelopeMutex.RLock()
	defer fake.envelopeMutex.RUnlock()
	return len(fake.envelopeArgsForCall)
}

func (fake *FabricTransaction) EnvelopeCalls(stub func() (driver.Envelope, error)) {
	fake.envelopeMutex.Lock()
	defer fake.envelopeMutex.Unlock()
	fake.EnvelopeStub = stub
}

func (fake *FabricTransaction) EnvelopeReturns(result1 driver.Envelope, result2 error) {
	fake.envelopeMutex.Lock()
	defer fake.envelopeMutex.Unlock()
	fake.EnvelopeStub = nil
	fake.envelopeReturns = struct {
		result1 driver.Envelope
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) EnvelopeReturnsOnCall(i int, result1 driver.Envelope, result2 error) {
	fake.envelopeMutex.Lock()
	defer fake.envelopeMutex.Unlock()
	fake.EnvelopeStub = nil
	if fake.envelopeReturnsOnCall == nil {
		fake.envelopeReturnsOnCall = make(map[int]struct {
			result1 driver.Envelope
			result2 error
		})
	}
	fake.envelopeReturnsOnCall[i] = struct {
		result1 driver.Envelope
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) From(arg1 driver.Transaction) error {
	fake.fromMutex.Lock()
	ret, specificReturn := fake.fromReturnsOnCall[len(fake.fromArgsForCall)]
	fake.fromArgsForCall = append(fake.fromArgsForCall, struct {
		arg1 driver.Transaction
	}{arg1})
	stub := fake.FromStub
	fakeReturns := fake.fromReturns
	fake.recordInvocation("From", []interface{}{arg1})
	fake.fromMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) FromCallCount() int {
	fake.fromMutex.RLock()
	defer fake.fromMutex.RUnlock()
	return len(fake.fromArgsForCall)
}

func (fake *FabricTransaction) FromCalls(stub func(driver.Transaction) error) {
	fake.fromMutex.Lock()
	defer fake.fromMutex.Unlock()
	fake.FromStub = stub
}

func (fake *FabricTransaction) FromArgsForCall(i int) driver.Transaction {
	fake.fromMutex.RLock()
	defer fake.fromMutex.RUnlock()
	argsForCall := fake.fromArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) FromReturns(result1 error) {
	fake.fromMutex.Lock()
	defer fake.fromMutex.Unlock()
	fake.FromStub = nil
	fake.fromReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) FromReturnsOnCall(i int, result1 error) {
	fake.fromMutex.Lock()
	defer fake.fromMutex.Unlock()
	fake.FromStub = nil
	if fake.fromReturnsOnCall == nil {
		fake.fromReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fromReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) Function() string {
	fake.functionMutex.Lock()
	ret, specificReturn := fake.functionReturnsOnCall[len(fake.functionArgsForCall)]
	fake.functionArgsForCall = append(fake.functionArgsForCall, struct {
	}{})
	stub := fake.FunctionStub
	fakeReturns := fake.functionReturns
	fake.recordInvocation("Function", []interface{}{})
	fake.functionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) FunctionCallCount() int {
	fake.functionMutex.RLock()
	defer fake.functionMutex.RUnlock()
	return len(fake.functionArgsForCall)
}

func (fake *FabricTransaction) FunctionCalls(stub func() string) {
	fake.functionMutex.Lock()
	defer fake.functionMutex.Unlock()
	fake.FunctionStub = stub
}

func (fake *FabricTransaction) FunctionReturns(result1 string) {
	fake.functionMutex.Lock()
	defer fake.functionMutex.Unlock()
	fake.FunctionStub = nil
	fake.functionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) FunctionReturnsOnCall(i int, result1 string) {
	fake.functionMutex.Lock()
	defer fake.functionMutex.Unlock()
	fake.FunctionStub = nil
	if fake.functionReturnsOnCall == nil {
		fake.functionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.functionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) FunctionAndParameters() (string, []string) {
	fake.functionAndParametersMutex.Lock()
	ret, specificReturn := fake.functionAndParametersReturnsOnCall[len(fake.functionAndParametersArgsForCall)]
	fake.functionAndParametersArgsForCall = append(fake.functionAndParametersArgsForCall, struct {
	}{})
	stub := fake.FunctionAndParametersStub
	fakeReturns := fake.functionAndParametersReturns
	fake.recordInvocation("FunctionAndParameters", []interface{}{})
	fake.functionAndParametersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) FunctionAndParametersCallCount() int {
	fake.functionAndParametersMutex.RLock()
	defer fake.functionAndParametersMutex.RUnlock()
	return len(fake.functionAndParametersArgsForCall)
}

func (fake *FabricTransaction) FunctionAndParametersCalls(stub func() (string, []string)) {
	fake.functionAndParametersMutex.Lock()
	defer fake.functionAndParametersMutex.Unlock()
	fake.FunctionAndParametersStub = stub
}

func (fake *FabricTransaction) FunctionAndParametersReturns(result1 string, result2 []string) {
	fake.functionAndParametersMutex.Lock()
	defer fake.functionAndParametersMutex.Unlock()
	fake.FunctionAndParametersStub = nil
	fake.functionAndParametersReturns = struct {
		result1 string
		result2 []string
	}{result1, result2}
}

func (fake *FabricTransaction) FunctionAndParametersReturnsOnCall(i int, result1 string, result2 []string) {
	fake.functionAndParametersMutex.Lock()
	defer fake.functionAndParametersMutex.Unlock()
	fake.FunctionAndParametersStub = nil
	if fake.functionAndParametersReturnsOnCall == nil {
		fake.functionAndParametersReturnsOnCall = make(map[int]struct {
			result1 string
			result2 []string
		})
	}
	fake.functionAndParametersReturnsOnCall[i] = struct {
		result1 string
		result2 []string
	}{result1, result2}
}

func (fake *FabricTransaction) GetRWSet() (driver.RWSet, error) {
	fake.getRWSetMutex.Lock()
	ret, specificReturn := fake.getRWSetReturnsOnCall[len(fake.getRWSetArgsForCall)]
	fake.getRWSetArgsForCall = append(fake.getRWSetArgsForCall, struct {
	}{})
	stub := fake.GetRWSetStub
	fakeReturns := fake.getRWSetReturns
	fake.recordInvocation("GetRWSet", []interface{}{})
	fake.getRWSetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) GetRWSetCallCount() int {
	fake.getRWSetMutex.RLock()
	defer fake.getRWSetMutex.RUnlock()
	return len(fake.getRWSetArgsForCall)
}

func (fake *FabricTransaction) GetRWSetCalls(stub func() (driver.RWSet, error)) {
	fake.getRWSetMutex.Lock()
	defer fake.getRWSetMutex.Unlock()
	fake.GetRWSetStub = stub
}

func (fake *FabricTransaction) GetRWSetReturns(result1 driver.RWSet, result2 error) {
	fake.getRWSetMutex.Lock()
	defer fake.getRWSetMutex.Unlock()
	fake.GetRWSetStub = nil
	fake.getRWSetReturns = struct {
		result1 driver.RWSet
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) GetRWSetReturnsOnCall(i int, result1 driver.RWSet, result2 error) {
	fake.getRWSetMutex.Lock()
	defer fake.getRWSetMutex.Unlock()
	fake.GetRWSetStub = nil
	if fake.getRWSetReturnsOnCall == nil {
		fake.getRWSetReturnsOnCall = make(map[int]struct {
			result1 driver.RWSet
			result2 error
		})
	}
	fake.getRWSetReturnsOnCall[i] = struct {
		result1 driver.RWSet
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FabricTransaction) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FabricTransaction) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) Network() string {
	fake.networkMutex.Lock()
	ret, specificReturn := fake.networkReturnsOnCall[len(fake.networkArgsForCall)]
	fake.networkArgsForCall = append(fake.networkArgsForCall, struct {
	}{})
	stub := fake.NetworkStub
	fakeReturns := fake.networkReturns
	fake.recordInvocation("Network", []interface{}{})
	fake.networkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) NetworkCallCount() int {
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	return len(fake.networkArgsForCall)
}

func (fake *FabricTransaction) NetworkCalls(stub func() string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = stub
}

func (fake *FabricTransaction) NetworkReturns(result1 string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	fake.networkReturns = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) NetworkReturnsOnCall(i int, result1 string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	if fake.networkReturnsOnCall == nil {
		fake.networkReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.networkReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FabricTransaction) Nonce() []byte {
	fake.nonceMutex.Lock()
	ret, specificReturn := fake.nonceReturnsOnCall[len(fake.nonceArgsForCall)]
	fake.nonceArgsForCall = append(fake.nonceArgsForCall, struct {
	}{})
	stub := fake.NonceStub
	fakeReturns := fake.nonceReturns
	fake.recordInvocation("Nonce", []interface{}{})
	fake.nonceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) NonceCallCount() int {
	fake.nonceMutex.RLock()
	defer fake.nonceMutex.RUnlock()
	return len(fake.nonceArgsForCall)
}

func (fake *FabricTransaction) NonceCalls(stub func() []byte) {
	fake.nonceMutex.Lock()
	defer fake.nonceMutex.Unlock()
	fake.NonceStub = stub
}

func (fake *FabricTransaction) NonceReturns(result1 []byte) {
	fake.nonceMutex.Lock()
	defer fake.nonceMutex.Unlock()
	fake.NonceStub = nil
	fake.nonceReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FabricTransaction) NonceReturnsOnCall(i int, result1 []byte) {
	fake.nonceMutex.Lock()
	defer fake.nonceMutex.Unlock()
	fake.NonceStub = nil
	if fake.nonceReturnsOnCall == nil {
		fake.nonceReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.nonceReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FabricTransaction) Parameters() [][]byte {
	fake.parametersMutex.Lock()
	ret, specificReturn := fake.parametersReturnsOnCall[len(fake.parametersArgsForCall)]
	fake.parametersArgsForCall = append(fake.parametersArgsForCall, struct {
	}{})
	stub := fake.ParametersStub
	fakeReturns := fake.parametersReturns
	fake.recordInvocation("Parameters", []interface{}{})
	fake.parametersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) ParametersCallCount() int {
	fake.parametersMutex.RLock()
	defer fake.parametersMutex.RUnlock()
	return len(fake.parametersArgsForCall)
}

func (fake *FabricTransaction) ParametersCalls(stub func() [][]byte) {
	fake.parametersMutex.Lock()
	defer fake.parametersMutex.Unlock()
	fake.ParametersStub = stub
}

func (fake *FabricTransaction) ParametersReturns(result1 [][]byte) {
	fake.parametersMutex.Lock()
	defer fake.parametersMutex.Unlock()
	fake.ParametersStub = nil
	fake.parametersReturns = struct {
		result1 [][]byte
	}{result1}
}

func (fake *FabricTransaction) ParametersReturnsOnCall(i int, result1 [][]byte) {
	fake.parametersMutex.Lock()
	defer fake.parametersMutex.Unlock()
	fake.ParametersStub = nil
	if fake.parametersReturnsOnCall == nil {
		fake.parametersReturnsOnCall = make(map[int]struct {
			result1 [][]byte
		})
	}
	fake.parametersReturnsOnCall[i] = struct {
		result1 [][]byte
	}{result1}
}

func (fake *FabricTransaction) Proposal() driver.Proposal {
	fake.proposalMutex.Lock()
	ret, specificReturn := fake.proposalReturnsOnCall[len(fake.proposalArgsForCall)]
	fake.proposalArgsForCall = append(fake.proposalArgsForCall, struct {
	}{})
	stub := fake.ProposalStub
	fakeReturns := fake.proposalReturns
	fake.recordInvocation("Proposal", []interface{}{})
	fake.proposalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) ProposalCallCount() int {
	fake.proposalMutex.RLock()
	defer fake.proposalMutex.RUnlock()
	return len(fake.proposalArgsForCall)
}

func (fake *FabricTransaction) ProposalCalls(stub func() driver.Proposal) {
	fake.proposalMutex.Lock()
	defer fake.proposalMutex.Unlock()
	fake.ProposalStub = stub
}

func (fake *FabricTransaction) ProposalReturns(result1 driver.Proposal) {
	fake.proposalMutex.Lock()
	defer fake.proposalMutex.Unlock()
	fake.ProposalStub = nil
	fake.proposalReturns = struct {
		result1 driver.Proposal
	}{result1}
}

func (fake *FabricTransaction) ProposalReturnsOnCall(i int, result1 driver.Proposal) {
	fake.proposalMutex.Lock()
	defer fake.proposalMutex.Unlock()
	fake.ProposalStub = nil
	if fake.proposalReturnsOnCall == nil {
		fake.proposalReturnsOnCall = make(map[int]struct {
			result1 driver.Proposal
		})
	}
	fake.proposalReturnsOnCall[i] = struct {
		result1 driver.Proposal
	}{result1}
}

func (fake *FabricTransaction) ProposalHasBeenEndorsedBy(arg1 view.Identity) error {
	fake.proposalHasBeenEndorsedByMutex.Lock()
	ret, specificReturn := fake.proposalHasBeenEndorsedByReturnsOnCall[len(fake.proposalHasBeenEndorsedByArgsForCall)]
	fake.proposalHasBeenEndorsedByArgsForCall = append(fake.proposalHasBeenEndorsedByArgsForCall, struct {
		arg1 view.Identity
	}{arg1})
	stub := fake.ProposalHasBeenEndorsedByStub
	fakeReturns := fake.proposalHasBeenEndorsedByReturns
	fake.recordInvocation("ProposalHasBeenEndorsedBy", []interface{}{arg1})
	fake.proposalHasBeenEndorsedByMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) ProposalHasBeenEndorsedByCallCount() int {
	fake.proposalHasBeenEndorsedByMutex.RLock()
	defer fake.proposalHasBeenEndorsedByMutex.RUnlock()
	return len(fake.proposalHasBeenEndorsedByArgsForCall)
}

func (fake *FabricTransaction) ProposalHasBeenEndorsedByCalls(stub func(view.Identity) error) {
	fake.proposalHasBeenEndorsedByMutex.Lock()
	defer fake.proposalHasBeenEndorsedByMutex.Unlock()
	fake.ProposalHasBeenEndorsedByStub = stub
}

func (fake *FabricTransaction) ProposalHasBeenEndorsedByArgsForCall(i int) view.Identity {
	fake.proposalHasBeenEndorsedByMutex.RLock()
	defer fake.proposalHasBeenEndorsedByMutex.RUnlock()
	argsForCall := fake.proposalHasBeenEndorsedByArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) ProposalHasBeenEndorsedByReturns(result1 error) {
	fake.proposalHasBeenEndorsedByMutex.Lock()
	defer fake.proposalHasBeenEndorsedByMutex.Unlock()
	fake.ProposalHasBeenEndorsedByStub = nil
	fake.proposalHasBeenEndorsedByReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) ProposalHasBeenEndorsedByReturnsOnCall(i int, result1 error) {
	fake.proposalHasBeenEndorsedByMutex.Lock()
	defer fake.proposalHasBeenEndorsedByMutex.Unlock()
	fake.ProposalHasBeenEndorsedByStub = nil
	if fake.proposalHasBeenEndorsedByReturnsOnCall == nil {
		fake.proposalHasBeenEndorsedByReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.proposalHasBeenEndorsedByReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) ProposalResponse() ([]byte, error) {
	fake.proposalResponseMutex.Lock()
	ret, specificReturn := fake.proposalResponseReturnsOnCall[len(fake.proposalResponseArgsForCall)]
	fake.proposalResponseArgsForCall = append(fake.proposalResponseArgsForCall, struct {
	}{})
	stub := fake.ProposalResponseStub
	fakeReturns := fake.proposalResponseReturns
	fake.recordInvocation("ProposalResponse", []interface{}{})
	fake.proposalResponseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) ProposalResponseCallCount() int {
	fake.proposalResponseMutex.RLock()
	defer fake.proposalResponseMutex.RUnlock()
	return len(fake.proposalResponseArgsForCall)
}

func (fake *FabricTransaction) ProposalResponseCalls(stub func() ([]byte, error)) {
	fake.proposalResponseMutex.Lock()
	defer fake.proposalResponseMutex.Unlock()
	fake.ProposalResponseStub = stub
}

func (fake *FabricTransaction) ProposalResponseReturns(result1 []byte, result2 error) {
	fake.proposalResponseMutex.Lock()
	defer fake.proposalResponseMutex.Unlock()
	fake.ProposalResponseStub = nil
	fake.proposalResponseReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) ProposalResponseReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.proposalResponseMutex.Lock()
	defer fake.proposalResponseMutex.Unlock()
	fake.ProposalResponseStub = nil
	if fake.proposalResponseReturnsOnCall == nil {
		fake.proposalResponseReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.proposalResponseReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) ProposalResponses() ([]driver.ProposalResponse, error) {
	fake.proposalResponsesMutex.Lock()
	ret, specificReturn := fake.proposalResponsesReturnsOnCall[len(fake.proposalResponsesArgsForCall)]
	fake.proposalResponsesArgsForCall = append(fake.proposalResponsesArgsForCall, struct {
	}{})
	stub := fake.ProposalResponsesStub
	fakeReturns := fake.proposalResponsesReturns
	fake.recordInvocation("ProposalResponses", []interface{}{})
	fake.proposalResponsesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) ProposalResponsesCallCount() int {
	fake.proposalResponsesMutex.RLock()
	defer fake.proposalResponsesMutex.RUnlock()
	return len(fake.proposalResponsesArgsForCall)
}

func (fake *FabricTransaction) ProposalResponsesCalls(stub func() ([]driver.ProposalResponse, error)) {
	fake.proposalResponsesMutex.Lock()
	defer fake.proposalResponsesMutex.Unlock()
	fake.ProposalResponsesStub = stub
}

func (fake *FabricTransaction) ProposalResponsesReturns(result1 []driver.ProposalResponse, result2 error) {
	fake.proposalResponsesMutex.Lock()
	defer fake.proposalResponsesMutex.Unlock()
	fake.ProposalResponsesStub = nil
	fake.proposalResponsesReturns = struct {
		result1 []driver.ProposalResponse
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) ProposalResponsesReturnsOnCall(i int, result1 []driver.ProposalResponse, result2 error) {
	fake.proposalResponsesMutex.Lock()
	defer fake.proposalResponsesMutex.Unlock()
	fake.ProposalResponsesStub = nil
	if fake.proposalResponsesReturnsOnCall == nil {
		fake.proposalResponsesReturnsOnCall = make(map[int]struct {
			result1 []driver.ProposalResponse
			result2 error
		})
	}
	fake.proposalResponsesReturnsOnCall[i] = struct {
		result1 []driver.ProposalResponse
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) RWS() driver.RWSet {
	fake.rWSMutex.Lock()
	ret, specificReturn := fake.rWSReturnsOnCall[len(fake.rWSArgsForCall)]
	fake.rWSArgsForCall = append(fake.rWSArgsForCall, struct {
	}{})
	stub := fake.RWSStub
	fakeReturns := fake.rWSReturns
	fake.recordInvocation("RWS", []interface{}{})
	fake.rWSMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) RWSCallCount() int {
	fake.rWSMutex.RLock()
	defer fake.rWSMutex.RUnlock()
	return len(fake.rWSArgsForCall)
}

func (fake *FabricTransaction) RWSCalls(stub func() driver.RWSet) {
	fake.rWSMutex.Lock()
	defer fake.rWSMutex.Unlock()
	fake.RWSStub = stub
}

func (fake *FabricTransaction) RWSReturns(result1 driver.RWSet) {
	fake.rWSMutex.Lock()
	defer fake.rWSMutex.Unlock()
	fake.RWSStub = nil
	fake.rWSReturns = struct {
		result1 driver.RWSet
	}{result1}
}

func (fake *FabricTransaction) RWSReturnsOnCall(i int, result1 driver.RWSet) {
	fake.rWSMutex.Lock()
	defer fake.rWSMutex.Unlock()
	fake.RWSStub = nil
	if fake.rWSReturnsOnCall == nil {
		fake.rWSReturnsOnCall = make(map[int]struct {
			result1 driver.RWSet
		})
	}
	fake.rWSReturnsOnCall[i] = struct {
		result1 driver.RWSet
	}{result1}
}

func (fake *FabricTransaction) Raw() ([]byte, error) {
	fake.rawMutex.Lock()
	ret, specificReturn := fake.rawReturnsOnCall[len(fake.rawArgsForCall)]
	fake.rawArgsForCall = append(fake.rawArgsForCall, struct {
	}{})
	stub := fake.RawStub
	fakeReturns := fake.rawReturns
	fake.recordInvocation("Raw", []interface{}{})
	fake.rawMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) RawCallCount() int {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	return len(fake.rawArgsForCall)
}

func (fake *FabricTransaction) RawCalls(stub func() ([]byte, error)) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = stub
}

func (fake *FabricTransaction) RawReturns(result1 []byte, result2 error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	fake.rawReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) RawReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	if fake.rawReturnsOnCall == nil {
		fake.rawReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.rawReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) ResetTransient() {
	fake.resetTransientMutex.Lock()
	fake.resetTransientArgsForCall = append(fake.resetTransientArgsForCall, struct {
	}{})
	stub := fake.ResetTransientStub
	fake.recordInvocation("ResetTransient", []interface{}{})
	fake.resetTransientMutex.Unlock()
	if stub != nil {
		fake.ResetTransientStub()
	}
}

func (fake *FabricTransaction) ResetTransientCallCount() int {
	fake.resetTransientMutex.RLock()
	defer fake.resetTransientMutex.RUnlock()
	return len(fake.resetTransientArgsForCall)
}

func (fake *FabricTransaction) ResetTransientCalls(stub func()) {
	fake.resetTransientMutex.Lock()
	defer fake.resetTransientMutex.Unlock()
	fake.ResetTransientStub = stub
}

func (fake *FabricTransaction) Results() ([]byte, error) {
	fake.resultsMutex.Lock()
	ret, specificReturn := fake.resultsReturnsOnCall[len(fake.resultsArgsForCall)]
	fake.resultsArgsForCall = append(fake.resultsArgsForCall, struct {
	}{})
	stub := fake.ResultsStub
	fakeReturns := fake.resultsReturns
	fake.recordInvocation("Results", []interface{}{})
	fake.resultsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FabricTransaction) ResultsCallCount() int {
	fake.resultsMutex.RLock()
	defer fake.resultsMutex.RUnlock()
	return len(fake.resultsArgsForCall)
}

func (fake *FabricTransaction) ResultsCalls(stub func() ([]byte, error)) {
	fake.resultsMutex.Lock()
	defer fake.resultsMutex.Unlock()
	fake.ResultsStub = stub
}

func (fake *FabricTransaction) ResultsReturns(result1 []byte, result2 error) {
	fake.resultsMutex.Lock()
	defer fake.resultsMutex.Unlock()
	fake.ResultsStub = nil
	fake.resultsReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) ResultsReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.resultsMutex.Lock()
	defer fake.resultsMutex.Unlock()
	fake.ResultsStub = nil
	if fake.resultsReturnsOnCall == nil {
		fake.resultsReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.resultsReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FabricTransaction) SetFromBytes(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setFromBytesMutex.Lock()
	ret, specificReturn := fake.setFromBytesReturnsOnCall[len(fake.setFromBytesArgsForCall)]
	fake.setFromBytesArgsForCall = append(fake.setFromBytesArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.SetFromBytesStub
	fakeReturns := fake.setFromBytesReturns
	fake.recordInvocation("SetFromBytes", []interface{}{arg1Copy})
	fake.setFromBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) SetFromBytesCallCount() int {
	fake.setFromBytesMutex.RLock()
	defer fake.setFromBytesMutex.RUnlock()
	return len(fake.setFromBytesArgsForCall)
}

func (fake *FabricTransaction) SetFromBytesCalls(stub func([]byte) error) {
	fake.setFromBytesMutex.Lock()
	defer fake.setFromBytesMutex.Unlock()
	fake.SetFromBytesStub = stub
}

func (fake *FabricTransaction) SetFromBytesArgsForCall(i int) []byte {
	fake.setFromBytesMutex.RLock()
	defer fake.setFromBytesMutex.RUnlock()
	argsForCall := fake.setFromBytesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) SetFromBytesReturns(result1 error) {
	fake.setFromBytesMutex.Lock()
	defer fake.setFromBytesMutex.Unlock()
	fake.SetFromBytesStub = nil
	fake.setFromBytesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SetFromBytesReturnsOnCall(i int, result1 error) {
	fake.setFromBytesMutex.Lock()
	defer fake.setFromBytesMutex.Unlock()
	fake.SetFromBytesStub = nil
	if fake.setFromBytesReturnsOnCall == nil {
		fake.setFromBytesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setFromBytesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SetFromEnvelopeBytes(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setFromEnvelopeBytesMutex.Lock()
	ret, specificReturn := fake.setFromEnvelopeBytesReturnsOnCall[len(fake.setFromEnvelopeBytesArgsForCall)]
	fake.setFromEnvelopeBytesArgsForCall = append(fake.setFromEnvelopeBytesArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.SetFromEnvelopeBytesStub
	fakeReturns := fake.setFromEnvelopeBytesReturns
	fake.recordInvocation("SetFromEnvelopeBytes", []interface{}{arg1Copy})
	fake.setFromEnvelopeBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) SetFromEnvelopeBytesCallCount() int {
	fake.setFromEnvelopeBytesMutex.RLock()
	defer fake.setFromEnvelopeBytesMutex.RUnlock()
	return len(fake.setFromEnvelopeBytesArgsForCall)
}

func (fake *FabricTransaction) SetFromEnvelopeBytesCalls(stub func([]byte) error) {
	fake.setFromEnvelopeBytesMutex.Lock()
	defer fake.setFromEnvelopeBytesMutex.Unlock()
	fake.SetFromEnvelopeBytesStub = stub
}

func (fake *FabricTransaction) SetFromEnvelopeBytesArgsForCall(i int) []byte {
	fake.setFromEnvelopeBytesMutex.RLock()
	defer fake.setFromEnvelopeBytesMutex.RUnlock()
	argsForCall := fake.setFromEnvelopeBytesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FabricTransaction) SetFromEnvelopeBytesReturns(result1 error) {
	fake.setFromEnvelopeBytesMutex.Lock()
	defer fake.setFromEnvelopeBytesMutex.Unlock()
	fake.SetFromEnvelopeBytesStub = nil
	fake.setFromEnvelopeBytesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SetFromEnvelopeBytesReturnsOnCall(i int, result1 error) {
	fake.setFromEnvelopeBytesMutex.Lock()
	defer fake.setFromEnvelopeBytesMutex.Unlock()
	fake.SetFromEnvelopeBytesStub = nil
	if fake.setFromEnvelopeBytesReturnsOnCall == nil {
		fake.setFromEnvelopeBytesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setFromEnvelopeBytesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SetParameterAt(arg1 int, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.setParameterAtMutex.Lock()
	ret, specificReturn := fake.setParameterAtReturnsOnCall[len(fake.setParameterAtArgsForCall)]
	fake.setParameterAtArgsForCall = append(fake.setParameterAtArgsForCall, struct {
		arg1 int
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.SetParameterAtStub
	fakeReturns := fake.setParameterAtReturns
	fake.recordInvocation("SetParameterAt", []interface{}{arg1, arg2Copy})
	fake.setParameterAtMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) SetParameterAtCallCount() int {
	fake.setParameterAtMutex.RLock()
	defer fake.setParameterAtMutex.RUnlock()
	return len(fake.setParameterAtArgsForCall)
}

func (fake *FabricTransaction) SetParameterAtCalls(stub func(int, []byte) error) {
	fake.setParameterAtMutex.Lock()
	defer fake.setParameterAtMutex.Unlock()
	fake.SetParameterAtStub = stub
}

func (fake *FabricTransaction) SetParameterAtArgsForCall(i int) (int, []byte) {
	fake.setParameterAtMutex.RLock()
	defer fake.setParameterAtMutex.RUnlock()
	argsForCall := fake.setParameterAtArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FabricTransaction) SetParameterAtReturns(result1 error) {
	fake.setParameterAtMutex.Lock()
	defer fake.setParameterAtMutex.Unlock()
	fake.SetParameterAtStub = nil
	fake.setParameterAtReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SetParameterAtReturnsOnCall(i int, result1 error) {
	fake.setParameterAtMutex.Lock()
	defer fake.setParameterAtMutex.Unlock()
	fake.SetParameterAtStub = nil
	if fake.setParameterAtReturnsOnCall == nil {
		fake.setParameterAtReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setParameterAtReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SetProposal(arg1 string, arg2 string, arg3 string, arg4 ...string) {
	fake.setProposalMutex.Lock()
	fake.setProposalArgsForCall = append(fake.setProposalArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []string
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetProposalStub
	fake.recordInvocation("SetProposal", []interface{}{arg1, arg2, arg3, arg4})
	fake.setProposalMutex.Unlock()
	if stub != nil {
		fake.SetProposalStub(arg1, arg2, arg3, arg4...)
	}
}

func (fake *FabricTransaction) SetProposalCallCount() int {
	fake.setProposalMutex.RLock()
	defer fake.setProposalMutex.RUnlock()
	return len(fake.setProposalArgsForCall)
}

func (fake *FabricTransaction) SetProposalCalls(stub func(string, string, string, ...string)) {
	fake.setProposalMutex.Lock()
	defer fake.setProposalMutex.Unlock()
	fake.SetProposalStub = stub
}

func (fake *FabricTransaction) SetProposalArgsForCall(i int) (string, string, string, []string) {
	fake.setProposalMutex.RLock()
	defer fake.setProposalMutex.RUnlock()
	argsForCall := fake.setProposalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FabricTransaction) SetRWSet() error {
	fake.setRWSetMutex.Lock()
	ret, specificReturn := fake.setRWSetReturnsOnCall[len(fake.setRWSetArgsForCall)]
	fake.setRWSetArgsForCall = append(fake.setRWSetArgsForCall, struct {
	}{})
	stub := fake.SetRWSetStub
	fakeReturns := fake.setRWSetReturns
	fake.recordInvocation("SetRWSet", []interface{}{})
	fake.setRWSetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) SetRWSetCallCount() int {
	fake.setRWSetMutex.RLock()
	defer fake.setRWSetMutex.RUnlock()
	return len(fake.setRWSetArgsForCall)
}

func (fake *FabricTransaction) SetRWSetCalls(stub func() error) {
	fake.setRWSetMutex.Lock()
	defer fake.setRWSetMutex.Unlock()
	fake.SetRWSetStub = stub
}

func (fake *FabricTransaction) SetRWSetReturns(result1 error) {
	fake.setRWSetMutex.Lock()
	defer fake.setRWSetMutex.Unlock()
	fake.SetRWSetStub = nil
	fake.setRWSetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SetRWSetReturnsOnCall(i int, result1 error) {
	fake.setRWSetMutex.Lock()
	defer fake.setRWSetMutex.Unlock()
	fake.SetRWSetStub = nil
	if fake.setRWSetReturnsOnCall == nil {
		fake.setRWSetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRWSetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) SignedProposal() driver.SignedProposal {
	fake.signedProposalMutex.Lock()
	ret, specificReturn := fake.signedProposalReturnsOnCall[len(fake.signedProposalArgsForCall)]
	fake.signedProposalArgsForCall = append(fake.signedProposalArgsForCall, struct {
	}{})
	stub := fake.SignedProposalStub
	fakeReturns := fake.signedProposalReturns
	fake.recordInvocation("SignedProposal", []interface{}{})
	fake.signedProposalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) SignedProposalCallCount() int {
	fake.signedProposalMutex.RLock()
	defer fake.signedProposalMutex.RUnlock()
	return len(fake.signedProposalArgsForCall)
}

func (fake *FabricTransaction) SignedProposalCalls(stub func() driver.SignedProposal) {
	fake.signedProposalMutex.Lock()
	defer fake.signedProposalMutex.Unlock()
	fake.SignedProposalStub = stub
}

func (fake *FabricTransaction) SignedProposalReturns(result1 driver.SignedProposal) {
	fake.signedProposalMutex.Lock()
	defer fake.signedProposalMutex.Unlock()
	fake.SignedProposalStub = nil
	fake.signedProposalReturns = struct {
		result1 driver.SignedProposal
	}{result1}
}

func (fake *FabricTransaction) SignedProposalReturnsOnCall(i int, result1 driver.SignedProposal) {
	fake.signedProposalMutex.Lock()
	defer fake.signedProposalMutex.Unlock()
	fake.SignedProposalStub = nil
	if fake.signedProposalReturnsOnCall == nil {
		fake.signedProposalReturnsOnCall = make(map[int]struct {
			result1 driver.SignedProposal
		})
	}
	fake.signedProposalReturnsOnCall[i] = struct {
		result1 driver.SignedProposal
	}{result1}
}

func (fake *FabricTransaction) StoreTransient() error {
	fake.storeTransientMutex.Lock()
	ret, specificReturn := fake.storeTransientReturnsOnCall[len(fake.storeTransientArgsForCall)]
	fake.storeTransientArgsForCall = append(fake.storeTransientArgsForCall, struct {
	}{})
	stub := fake.StoreTransientStub
	fakeReturns := fake.storeTransientReturns
	fake.recordInvocation("StoreTransient", []interface{}{})
	fake.storeTransientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) StoreTransientCallCount() int {
	fake.storeTransientMutex.RLock()
	defer fake.storeTransientMutex.RUnlock()
	return len(fake.storeTransientArgsForCall)
}

func (fake *FabricTransaction) StoreTransientCalls(stub func() error) {
	fake.storeTransientMutex.Lock()
	defer fake.storeTransientMutex.Unlock()
	fake.StoreTransientStub = stub
}

func (fake *FabricTransaction) StoreTransientReturns(result1 error) {
	fake.storeTransientMutex.Lock()
	defer fake.storeTransientMutex.Unlock()
	fake.StoreTransientStub = nil
	fake.storeTransientReturns = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) StoreTransientReturnsOnCall(i int, result1 error) {
	fake.storeTransientMutex.Lock()
	defer fake.storeTransientMutex.Unlock()
	fake.StoreTransientStub = nil
	if fake.storeTransientReturnsOnCall == nil {
		fake.storeTransientReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeTransientReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FabricTransaction) Transient() driver.TransientMap {
	fake.transientMutex.Lock()
	ret, specificReturn := fake.transientReturnsOnCall[len(fake.transientArgsForCall)]
	fake.transientArgsForCall = append(fake.transientArgsForCall, struct {
	}{})
	stub := fake.TransientStub
	fakeReturns := fake.transientReturns
	fake.recordInvocation("Transient", []interface{}{})
	fake.transientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FabricTransaction) TransientCallCount() int {
	fake.transientMutex.RLock()
	defer fake.transientMutex.RUnlock()
	return len(fake.transientArgsForCall)
}

func (fake *FabricTransaction) TransientCalls(stub func() driver.TransientMap) {
	fake.transientMutex.Lock()
	defer fake.transientMutex.Unlock()
	fake.TransientStub = stub
}

func (fake *FabricTransaction) TransientReturns(result1 driver.TransientMap) {
	fake.transientMutex.Lock()
	defer fake.transientMutex.Unlock()
	fake.TransientStub = nil
	fake.transientReturns = struct {
		result1 driver.TransientMap
	}{result1}
}

func (fake *FabricTransaction) TransientReturnsOnCall(i int, result1 driver.TransientMap) {
	fake.transientMutex.Lock()
	defer fake.transientMutex.Unlock()
	fake.TransientStub = nil
	if fake.transientReturnsOnCall == nil {
		fake.transientReturnsOnCall = make(map[int]struct {
			result1 driver.TransientMap
		})
	}
	fake.transientReturnsOnCall[i] = struct {
		result1 driver.TransientMap
	}{result1}
}

func (fake *FabricTransaction) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appendParameterMutex.RLock()
	defer fake.appendParameterMutex.RUnlock()
	fake.appendProposalResponseMutex.RLock()
	defer fake.appendProposalResponseMutex.RUnlock()
	fake.bytesMutex.RLock()
	defer fake.bytesMutex.RUnlock()
	fake.bytesNoTransientMutex.RLock()
	defer fake.bytesNoTransientMutex.RUnlock()
	fake.chaincodeMutex.RLock()
	defer fake.chaincodeMutex.RUnlock()
	fake.chaincodeVersionMutex.RLock()
	defer fake.chaincodeVersionMutex.RUnlock()
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.creatorMutex.RLock()
	defer fake.creatorMutex.RUnlock()
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	fake.endorseMutex.RLock()
	defer fake.endorseMutex.RUnlock()
	fake.endorseProposalMutex.RLock()
	defer fake.endorseProposalMutex.RUnlock()
	fake.endorseProposalResponseMutex.RLock()
	defer fake.endorseProposalResponseMutex.RUnlock()
	fake.endorseProposalResponseWithIdentityMutex.RLock()
	defer fake.endorseProposalResponseWithIdentityMutex.RUnlock()
	fake.endorseProposalWithIdentityMutex.RLock()
	defer fake.endorseProposalWithIdentityMutex.RUnlock()
	fake.endorseWithIdentityMutex.RLock()
	defer fake.endorseWithIdentityMutex.RUnlock()
	fake.endorseWithSignerMutex.RLock()
	defer fake.endorseWithSignerMutex.RUnlock()
	fake.envelopeMutex.RLock()
	defer fake.envelopeMutex.RUnlock()
	fake.fromMutex.RLock()
	defer fake.fromMutex.RUnlock()
	fake.functionMutex.RLock()
	defer fake.functionMutex.RUnlock()
	fake.functionAndParametersMutex.RLock()
	defer fake.functionAndParametersMutex.RUnlock()
	fake.getRWSetMutex.RLock()
	defer fake.getRWSetMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	fake.nonceMutex.RLock()
	defer fake.nonceMutex.RUnlock()
	fake.parametersMutex.RLock()
	defer fake.parametersMutex.RUnlock()
	fake.proposalMutex.RLock()
	defer fake.proposalMutex.RUnlock()
	fake.proposalHasBeenEndorsedByMutex.RLock()
	defer fake.proposalHasBeenEndorsedByMutex.RUnlock()
	fake.proposalResponseMutex.RLock()
	defer fake.proposalResponseMutex.RUnlock()
	fake.proposalResponsesMutex.RLock()
	defer fake.proposalResponsesMutex.RUnlock()
	fake.rWSMutex.RLock()
	defer fake.rWSMutex.RUnlock()
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	fake.resetTransientMutex.RLock()
	defer fake.resetTransientMutex.RUnlock()
	fake.resultsMutex.RLock()
	defer fake.resultsMutex.RUnlock()
	fake.setFromBytesMutex.RLock()
	defer fake.setFromBytesMutex.RUnlock()
	fake.setFromEnvelopeBytesMutex.RLock()
	defer fake.setFromEnvelopeBytesMutex.RUnlock()
	fake.setParameterAtMutex.RLock()
	defer fake.setParameterAtMutex.RUnlock()
	fake.setProposalMutex.RLock()
	defer fake.setProposalMutex.RUnlock()
	fake.setRWSetMutex.RLock()
	defer fake.setRWSetMutex.RUnlock()
	fake.signedProposalMutex.RLock()
	defer fake.signedProposalMutex.RUnlock()
	fake.storeTransientMutex.RLock()
	defer fake.storeTransientMutex.RUnlock()
	fake.transientMutex.RLock()
	defer fake.transientMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FabricTransaction) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ fsc.FabricTransaction = new(FabricTransaction)
