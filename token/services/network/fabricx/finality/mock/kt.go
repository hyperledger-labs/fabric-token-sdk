// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network/common/rws/translator"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network/fabricx/finality"
)

type KeyTranslator struct {
	CreateInputSNKeyStub        func(string) (translator.Key, error)
	createInputSNKeyMutex       sync.RWMutex
	createInputSNKeyArgsForCall []struct {
		arg1 string
	}
	createInputSNKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createInputSNKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	CreateIssueActionMetadataKeyStub        func(string) (translator.Key, error)
	createIssueActionMetadataKeyMutex       sync.RWMutex
	createIssueActionMetadataKeyArgsForCall []struct {
		arg1 string
	}
	createIssueActionMetadataKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createIssueActionMetadataKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	CreateOutputKeyStub        func(string, uint64) (translator.Key, error)
	createOutputKeyMutex       sync.RWMutex
	createOutputKeyArgsForCall []struct {
		arg1 string
		arg2 uint64
	}
	createOutputKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createOutputKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	CreateOutputSNKeyStub        func(string, uint64, []byte) (translator.Key, error)
	createOutputSNKeyMutex       sync.RWMutex
	createOutputSNKeyArgsForCall []struct {
		arg1 string
		arg2 uint64
		arg3 []byte
	}
	createOutputSNKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createOutputSNKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	CreateSetupHashKeyStub        func() (translator.Key, error)
	createSetupHashKeyMutex       sync.RWMutex
	createSetupHashKeyArgsForCall []struct {
	}
	createSetupHashKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createSetupHashKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	CreateSetupKeyStub        func() (translator.Key, error)
	createSetupKeyMutex       sync.RWMutex
	createSetupKeyArgsForCall []struct {
	}
	createSetupKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createSetupKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	CreateTokenRequestKeyStub        func(string) (translator.Key, error)
	createTokenRequestKeyMutex       sync.RWMutex
	createTokenRequestKeyArgsForCall []struct {
		arg1 string
	}
	createTokenRequestKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createTokenRequestKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	CreateTransferActionMetadataKeyStub        func(string) (translator.Key, error)
	createTransferActionMetadataKeyMutex       sync.RWMutex
	createTransferActionMetadataKeyArgsForCall []struct {
		arg1 string
	}
	createTransferActionMetadataKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	createTransferActionMetadataKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	GetTransferMetadataSubKeyStub        func(string) (translator.Key, error)
	getTransferMetadataSubKeyMutex       sync.RWMutex
	getTransferMetadataSubKeyArgsForCall []struct {
		arg1 string
	}
	getTransferMetadataSubKeyReturns struct {
		result1 translator.Key
		result2 error
	}
	getTransferMetadataSubKeyReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	TransferActionMetadataKeyPrefixStub        func() (translator.Key, error)
	transferActionMetadataKeyPrefixMutex       sync.RWMutex
	transferActionMetadataKeyPrefixArgsForCall []struct {
	}
	transferActionMetadataKeyPrefixReturns struct {
		result1 translator.Key
		result2 error
	}
	transferActionMetadataKeyPrefixReturnsOnCall map[int]struct {
		result1 translator.Key
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *KeyTranslator) CreateInputSNKey(arg1 string) (translator.Key, error) {
	fake.createInputSNKeyMutex.Lock()
	ret, specificReturn := fake.createInputSNKeyReturnsOnCall[len(fake.createInputSNKeyArgsForCall)]
	fake.createInputSNKeyArgsForCall = append(fake.createInputSNKeyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateInputSNKeyStub
	fakeReturns := fake.createInputSNKeyReturns
	fake.recordInvocation("CreateInputSNKey", []interface{}{arg1})
	fake.createInputSNKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateInputSNKeyCallCount() int {
	fake.createInputSNKeyMutex.RLock()
	defer fake.createInputSNKeyMutex.RUnlock()
	return len(fake.createInputSNKeyArgsForCall)
}

func (fake *KeyTranslator) CreateInputSNKeyCalls(stub func(string) (translator.Key, error)) {
	fake.createInputSNKeyMutex.Lock()
	defer fake.createInputSNKeyMutex.Unlock()
	fake.CreateInputSNKeyStub = stub
}

func (fake *KeyTranslator) CreateInputSNKeyArgsForCall(i int) string {
	fake.createInputSNKeyMutex.RLock()
	defer fake.createInputSNKeyMutex.RUnlock()
	argsForCall := fake.createInputSNKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KeyTranslator) CreateInputSNKeyReturns(result1 translator.Key, result2 error) {
	fake.createInputSNKeyMutex.Lock()
	defer fake.createInputSNKeyMutex.Unlock()
	fake.CreateInputSNKeyStub = nil
	fake.createInputSNKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateInputSNKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createInputSNKeyMutex.Lock()
	defer fake.createInputSNKeyMutex.Unlock()
	fake.CreateInputSNKeyStub = nil
	if fake.createInputSNKeyReturnsOnCall == nil {
		fake.createInputSNKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createInputSNKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateIssueActionMetadataKey(arg1 string) (translator.Key, error) {
	fake.createIssueActionMetadataKeyMutex.Lock()
	ret, specificReturn := fake.createIssueActionMetadataKeyReturnsOnCall[len(fake.createIssueActionMetadataKeyArgsForCall)]
	fake.createIssueActionMetadataKeyArgsForCall = append(fake.createIssueActionMetadataKeyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateIssueActionMetadataKeyStub
	fakeReturns := fake.createIssueActionMetadataKeyReturns
	fake.recordInvocation("CreateIssueActionMetadataKey", []interface{}{arg1})
	fake.createIssueActionMetadataKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateIssueActionMetadataKeyCallCount() int {
	fake.createIssueActionMetadataKeyMutex.RLock()
	defer fake.createIssueActionMetadataKeyMutex.RUnlock()
	return len(fake.createIssueActionMetadataKeyArgsForCall)
}

func (fake *KeyTranslator) CreateIssueActionMetadataKeyCalls(stub func(string) (translator.Key, error)) {
	fake.createIssueActionMetadataKeyMutex.Lock()
	defer fake.createIssueActionMetadataKeyMutex.Unlock()
	fake.CreateIssueActionMetadataKeyStub = stub
}

func (fake *KeyTranslator) CreateIssueActionMetadataKeyArgsForCall(i int) string {
	fake.createIssueActionMetadataKeyMutex.RLock()
	defer fake.createIssueActionMetadataKeyMutex.RUnlock()
	argsForCall := fake.createIssueActionMetadataKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KeyTranslator) CreateIssueActionMetadataKeyReturns(result1 translator.Key, result2 error) {
	fake.createIssueActionMetadataKeyMutex.Lock()
	defer fake.createIssueActionMetadataKeyMutex.Unlock()
	fake.CreateIssueActionMetadataKeyStub = nil
	fake.createIssueActionMetadataKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateIssueActionMetadataKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createIssueActionMetadataKeyMutex.Lock()
	defer fake.createIssueActionMetadataKeyMutex.Unlock()
	fake.CreateIssueActionMetadataKeyStub = nil
	if fake.createIssueActionMetadataKeyReturnsOnCall == nil {
		fake.createIssueActionMetadataKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createIssueActionMetadataKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateOutputKey(arg1 string, arg2 uint64) (translator.Key, error) {
	fake.createOutputKeyMutex.Lock()
	ret, specificReturn := fake.createOutputKeyReturnsOnCall[len(fake.createOutputKeyArgsForCall)]
	fake.createOutputKeyArgsForCall = append(fake.createOutputKeyArgsForCall, struct {
		arg1 string
		arg2 uint64
	}{arg1, arg2})
	stub := fake.CreateOutputKeyStub
	fakeReturns := fake.createOutputKeyReturns
	fake.recordInvocation("CreateOutputKey", []interface{}{arg1, arg2})
	fake.createOutputKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateOutputKeyCallCount() int {
	fake.createOutputKeyMutex.RLock()
	defer fake.createOutputKeyMutex.RUnlock()
	return len(fake.createOutputKeyArgsForCall)
}

func (fake *KeyTranslator) CreateOutputKeyCalls(stub func(string, uint64) (translator.Key, error)) {
	fake.createOutputKeyMutex.Lock()
	defer fake.createOutputKeyMutex.Unlock()
	fake.CreateOutputKeyStub = stub
}

func (fake *KeyTranslator) CreateOutputKeyArgsForCall(i int) (string, uint64) {
	fake.createOutputKeyMutex.RLock()
	defer fake.createOutputKeyMutex.RUnlock()
	argsForCall := fake.createOutputKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KeyTranslator) CreateOutputKeyReturns(result1 translator.Key, result2 error) {
	fake.createOutputKeyMutex.Lock()
	defer fake.createOutputKeyMutex.Unlock()
	fake.CreateOutputKeyStub = nil
	fake.createOutputKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateOutputKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createOutputKeyMutex.Lock()
	defer fake.createOutputKeyMutex.Unlock()
	fake.CreateOutputKeyStub = nil
	if fake.createOutputKeyReturnsOnCall == nil {
		fake.createOutputKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createOutputKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateOutputSNKey(arg1 string, arg2 uint64, arg3 []byte) (translator.Key, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createOutputSNKeyMutex.Lock()
	ret, specificReturn := fake.createOutputSNKeyReturnsOnCall[len(fake.createOutputSNKeyArgsForCall)]
	fake.createOutputSNKeyArgsForCall = append(fake.createOutputSNKeyArgsForCall, struct {
		arg1 string
		arg2 uint64
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.CreateOutputSNKeyStub
	fakeReturns := fake.createOutputSNKeyReturns
	fake.recordInvocation("CreateOutputSNKey", []interface{}{arg1, arg2, arg3Copy})
	fake.createOutputSNKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateOutputSNKeyCallCount() int {
	fake.createOutputSNKeyMutex.RLock()
	defer fake.createOutputSNKeyMutex.RUnlock()
	return len(fake.createOutputSNKeyArgsForCall)
}

func (fake *KeyTranslator) CreateOutputSNKeyCalls(stub func(string, uint64, []byte) (translator.Key, error)) {
	fake.createOutputSNKeyMutex.Lock()
	defer fake.createOutputSNKeyMutex.Unlock()
	fake.CreateOutputSNKeyStub = stub
}

func (fake *KeyTranslator) CreateOutputSNKeyArgsForCall(i int) (string, uint64, []byte) {
	fake.createOutputSNKeyMutex.RLock()
	defer fake.createOutputSNKeyMutex.RUnlock()
	argsForCall := fake.createOutputSNKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *KeyTranslator) CreateOutputSNKeyReturns(result1 translator.Key, result2 error) {
	fake.createOutputSNKeyMutex.Lock()
	defer fake.createOutputSNKeyMutex.Unlock()
	fake.CreateOutputSNKeyStub = nil
	fake.createOutputSNKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateOutputSNKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createOutputSNKeyMutex.Lock()
	defer fake.createOutputSNKeyMutex.Unlock()
	fake.CreateOutputSNKeyStub = nil
	if fake.createOutputSNKeyReturnsOnCall == nil {
		fake.createOutputSNKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createOutputSNKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateSetupHashKey() (translator.Key, error) {
	fake.createSetupHashKeyMutex.Lock()
	ret, specificReturn := fake.createSetupHashKeyReturnsOnCall[len(fake.createSetupHashKeyArgsForCall)]
	fake.createSetupHashKeyArgsForCall = append(fake.createSetupHashKeyArgsForCall, struct {
	}{})
	stub := fake.CreateSetupHashKeyStub
	fakeReturns := fake.createSetupHashKeyReturns
	fake.recordInvocation("CreateSetupHashKey", []interface{}{})
	fake.createSetupHashKeyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateSetupHashKeyCallCount() int {
	fake.createSetupHashKeyMutex.RLock()
	defer fake.createSetupHashKeyMutex.RUnlock()
	return len(fake.createSetupHashKeyArgsForCall)
}

func (fake *KeyTranslator) CreateSetupHashKeyCalls(stub func() (translator.Key, error)) {
	fake.createSetupHashKeyMutex.Lock()
	defer fake.createSetupHashKeyMutex.Unlock()
	fake.CreateSetupHashKeyStub = stub
}

func (fake *KeyTranslator) CreateSetupHashKeyReturns(result1 translator.Key, result2 error) {
	fake.createSetupHashKeyMutex.Lock()
	defer fake.createSetupHashKeyMutex.Unlock()
	fake.CreateSetupHashKeyStub = nil
	fake.createSetupHashKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateSetupHashKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createSetupHashKeyMutex.Lock()
	defer fake.createSetupHashKeyMutex.Unlock()
	fake.CreateSetupHashKeyStub = nil
	if fake.createSetupHashKeyReturnsOnCall == nil {
		fake.createSetupHashKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createSetupHashKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateSetupKey() (translator.Key, error) {
	fake.createSetupKeyMutex.Lock()
	ret, specificReturn := fake.createSetupKeyReturnsOnCall[len(fake.createSetupKeyArgsForCall)]
	fake.createSetupKeyArgsForCall = append(fake.createSetupKeyArgsForCall, struct {
	}{})
	stub := fake.CreateSetupKeyStub
	fakeReturns := fake.createSetupKeyReturns
	fake.recordInvocation("CreateSetupKey", []interface{}{})
	fake.createSetupKeyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateSetupKeyCallCount() int {
	fake.createSetupKeyMutex.RLock()
	defer fake.createSetupKeyMutex.RUnlock()
	return len(fake.createSetupKeyArgsForCall)
}

func (fake *KeyTranslator) CreateSetupKeyCalls(stub func() (translator.Key, error)) {
	fake.createSetupKeyMutex.Lock()
	defer fake.createSetupKeyMutex.Unlock()
	fake.CreateSetupKeyStub = stub
}

func (fake *KeyTranslator) CreateSetupKeyReturns(result1 translator.Key, result2 error) {
	fake.createSetupKeyMutex.Lock()
	defer fake.createSetupKeyMutex.Unlock()
	fake.CreateSetupKeyStub = nil
	fake.createSetupKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateSetupKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createSetupKeyMutex.Lock()
	defer fake.createSetupKeyMutex.Unlock()
	fake.CreateSetupKeyStub = nil
	if fake.createSetupKeyReturnsOnCall == nil {
		fake.createSetupKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createSetupKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateTokenRequestKey(arg1 string) (translator.Key, error) {
	fake.createTokenRequestKeyMutex.Lock()
	ret, specificReturn := fake.createTokenRequestKeyReturnsOnCall[len(fake.createTokenRequestKeyArgsForCall)]
	fake.createTokenRequestKeyArgsForCall = append(fake.createTokenRequestKeyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateTokenRequestKeyStub
	fakeReturns := fake.createTokenRequestKeyReturns
	fake.recordInvocation("CreateTokenRequestKey", []interface{}{arg1})
	fake.createTokenRequestKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateTokenRequestKeyCallCount() int {
	fake.createTokenRequestKeyMutex.RLock()
	defer fake.createTokenRequestKeyMutex.RUnlock()
	return len(fake.createTokenRequestKeyArgsForCall)
}

func (fake *KeyTranslator) CreateTokenRequestKeyCalls(stub func(string) (translator.Key, error)) {
	fake.createTokenRequestKeyMutex.Lock()
	defer fake.createTokenRequestKeyMutex.Unlock()
	fake.CreateTokenRequestKeyStub = stub
}

func (fake *KeyTranslator) CreateTokenRequestKeyArgsForCall(i int) string {
	fake.createTokenRequestKeyMutex.RLock()
	defer fake.createTokenRequestKeyMutex.RUnlock()
	argsForCall := fake.createTokenRequestKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KeyTranslator) CreateTokenRequestKeyReturns(result1 translator.Key, result2 error) {
	fake.createTokenRequestKeyMutex.Lock()
	defer fake.createTokenRequestKeyMutex.Unlock()
	fake.CreateTokenRequestKeyStub = nil
	fake.createTokenRequestKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateTokenRequestKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createTokenRequestKeyMutex.Lock()
	defer fake.createTokenRequestKeyMutex.Unlock()
	fake.CreateTokenRequestKeyStub = nil
	if fake.createTokenRequestKeyReturnsOnCall == nil {
		fake.createTokenRequestKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createTokenRequestKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateTransferActionMetadataKey(arg1 string) (translator.Key, error) {
	fake.createTransferActionMetadataKeyMutex.Lock()
	ret, specificReturn := fake.createTransferActionMetadataKeyReturnsOnCall[len(fake.createTransferActionMetadataKeyArgsForCall)]
	fake.createTransferActionMetadataKeyArgsForCall = append(fake.createTransferActionMetadataKeyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateTransferActionMetadataKeyStub
	fakeReturns := fake.createTransferActionMetadataKeyReturns
	fake.recordInvocation("CreateTransferActionMetadataKey", []interface{}{arg1})
	fake.createTransferActionMetadataKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) CreateTransferActionMetadataKeyCallCount() int {
	fake.createTransferActionMetadataKeyMutex.RLock()
	defer fake.createTransferActionMetadataKeyMutex.RUnlock()
	return len(fake.createTransferActionMetadataKeyArgsForCall)
}

func (fake *KeyTranslator) CreateTransferActionMetadataKeyCalls(stub func(string) (translator.Key, error)) {
	fake.createTransferActionMetadataKeyMutex.Lock()
	defer fake.createTransferActionMetadataKeyMutex.Unlock()
	fake.CreateTransferActionMetadataKeyStub = stub
}

func (fake *KeyTranslator) CreateTransferActionMetadataKeyArgsForCall(i int) string {
	fake.createTransferActionMetadataKeyMutex.RLock()
	defer fake.createTransferActionMetadataKeyMutex.RUnlock()
	argsForCall := fake.createTransferActionMetadataKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KeyTranslator) CreateTransferActionMetadataKeyReturns(result1 translator.Key, result2 error) {
	fake.createTransferActionMetadataKeyMutex.Lock()
	defer fake.createTransferActionMetadataKeyMutex.Unlock()
	fake.CreateTransferActionMetadataKeyStub = nil
	fake.createTransferActionMetadataKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) CreateTransferActionMetadataKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.createTransferActionMetadataKeyMutex.Lock()
	defer fake.createTransferActionMetadataKeyMutex.Unlock()
	fake.CreateTransferActionMetadataKeyStub = nil
	if fake.createTransferActionMetadataKeyReturnsOnCall == nil {
		fake.createTransferActionMetadataKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.createTransferActionMetadataKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) GetTransferMetadataSubKey(arg1 string) (translator.Key, error) {
	fake.getTransferMetadataSubKeyMutex.Lock()
	ret, specificReturn := fake.getTransferMetadataSubKeyReturnsOnCall[len(fake.getTransferMetadataSubKeyArgsForCall)]
	fake.getTransferMetadataSubKeyArgsForCall = append(fake.getTransferMetadataSubKeyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTransferMetadataSubKeyStub
	fakeReturns := fake.getTransferMetadataSubKeyReturns
	fake.recordInvocation("GetTransferMetadataSubKey", []interface{}{arg1})
	fake.getTransferMetadataSubKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) GetTransferMetadataSubKeyCallCount() int {
	fake.getTransferMetadataSubKeyMutex.RLock()
	defer fake.getTransferMetadataSubKeyMutex.RUnlock()
	return len(fake.getTransferMetadataSubKeyArgsForCall)
}

func (fake *KeyTranslator) GetTransferMetadataSubKeyCalls(stub func(string) (translator.Key, error)) {
	fake.getTransferMetadataSubKeyMutex.Lock()
	defer fake.getTransferMetadataSubKeyMutex.Unlock()
	fake.GetTransferMetadataSubKeyStub = stub
}

func (fake *KeyTranslator) GetTransferMetadataSubKeyArgsForCall(i int) string {
	fake.getTransferMetadataSubKeyMutex.RLock()
	defer fake.getTransferMetadataSubKeyMutex.RUnlock()
	argsForCall := fake.getTransferMetadataSubKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KeyTranslator) GetTransferMetadataSubKeyReturns(result1 translator.Key, result2 error) {
	fake.getTransferMetadataSubKeyMutex.Lock()
	defer fake.getTransferMetadataSubKeyMutex.Unlock()
	fake.GetTransferMetadataSubKeyStub = nil
	fake.getTransferMetadataSubKeyReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) GetTransferMetadataSubKeyReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.getTransferMetadataSubKeyMutex.Lock()
	defer fake.getTransferMetadataSubKeyMutex.Unlock()
	fake.GetTransferMetadataSubKeyStub = nil
	if fake.getTransferMetadataSubKeyReturnsOnCall == nil {
		fake.getTransferMetadataSubKeyReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.getTransferMetadataSubKeyReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) TransferActionMetadataKeyPrefix() (translator.Key, error) {
	fake.transferActionMetadataKeyPrefixMutex.Lock()
	ret, specificReturn := fake.transferActionMetadataKeyPrefixReturnsOnCall[len(fake.transferActionMetadataKeyPrefixArgsForCall)]
	fake.transferActionMetadataKeyPrefixArgsForCall = append(fake.transferActionMetadataKeyPrefixArgsForCall, struct {
	}{})
	stub := fake.TransferActionMetadataKeyPrefixStub
	fakeReturns := fake.transferActionMetadataKeyPrefixReturns
	fake.recordInvocation("TransferActionMetadataKeyPrefix", []interface{}{})
	fake.transferActionMetadataKeyPrefixMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KeyTranslator) TransferActionMetadataKeyPrefixCallCount() int {
	fake.transferActionMetadataKeyPrefixMutex.RLock()
	defer fake.transferActionMetadataKeyPrefixMutex.RUnlock()
	return len(fake.transferActionMetadataKeyPrefixArgsForCall)
}

func (fake *KeyTranslator) TransferActionMetadataKeyPrefixCalls(stub func() (translator.Key, error)) {
	fake.transferActionMetadataKeyPrefixMutex.Lock()
	defer fake.transferActionMetadataKeyPrefixMutex.Unlock()
	fake.TransferActionMetadataKeyPrefixStub = stub
}

func (fake *KeyTranslator) TransferActionMetadataKeyPrefixReturns(result1 translator.Key, result2 error) {
	fake.transferActionMetadataKeyPrefixMutex.Lock()
	defer fake.transferActionMetadataKeyPrefixMutex.Unlock()
	fake.TransferActionMetadataKeyPrefixStub = nil
	fake.transferActionMetadataKeyPrefixReturns = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) TransferActionMetadataKeyPrefixReturnsOnCall(i int, result1 translator.Key, result2 error) {
	fake.transferActionMetadataKeyPrefixMutex.Lock()
	defer fake.transferActionMetadataKeyPrefixMutex.Unlock()
	fake.TransferActionMetadataKeyPrefixStub = nil
	if fake.transferActionMetadataKeyPrefixReturnsOnCall == nil {
		fake.transferActionMetadataKeyPrefixReturnsOnCall = make(map[int]struct {
			result1 translator.Key
			result2 error
		})
	}
	fake.transferActionMetadataKeyPrefixReturnsOnCall[i] = struct {
		result1 translator.Key
		result2 error
	}{result1, result2}
}

func (fake *KeyTranslator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *KeyTranslator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ finality.KeyTranslator = new(KeyTranslator)
