// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
	drivera "github.com/hyperledger-labs/fabric-token-sdk/token/services/identity/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/identity/role"
)

type LocalMembership struct {
	DefaultNetworkIdentityStub        func() driver.Identity
	defaultNetworkIdentityMutex       sync.RWMutex
	defaultNetworkIdentityArgsForCall []struct {
	}
	defaultNetworkIdentityReturns struct {
		result1 driver.Identity
	}
	defaultNetworkIdentityReturnsOnCall map[int]struct {
		result1 driver.Identity
	}
	GetDefaultIdentifierStub        func() string
	getDefaultIdentifierMutex       sync.RWMutex
	getDefaultIdentifierArgsForCall []struct {
	}
	getDefaultIdentifierReturns struct {
		result1 string
	}
	getDefaultIdentifierReturnsOnCall map[int]struct {
		result1 string
	}
	GetIdentifierStub        func(context.Context, driver.Identity) (string, error)
	getIdentifierMutex       sync.RWMutex
	getIdentifierArgsForCall []struct {
		arg1 context.Context
		arg2 driver.Identity
	}
	getIdentifierReturns struct {
		result1 string
		result2 error
	}
	getIdentifierReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetIdentityInfoStub        func(context.Context, string, []byte) (drivera.IdentityInfo, error)
	getIdentityInfoMutex       sync.RWMutex
	getIdentityInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}
	getIdentityInfoReturns struct {
		result1 drivera.IdentityInfo
		result2 error
	}
	getIdentityInfoReturnsOnCall map[int]struct {
		result1 drivera.IdentityInfo
		result2 error
	}
	IDsStub        func() ([]string, error)
	iDsMutex       sync.RWMutex
	iDsArgsForCall []struct {
	}
	iDsReturns struct {
		result1 []string
		result2 error
	}
	iDsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	IsMeStub        func(context.Context, driver.Identity) bool
	isMeMutex       sync.RWMutex
	isMeArgsForCall []struct {
		arg1 context.Context
		arg2 driver.Identity
	}
	isMeReturns struct {
		result1 bool
	}
	isMeReturnsOnCall map[int]struct {
		result1 bool
	}
	RegisterIdentityStub        func(context.Context, driver.IdentityConfiguration) error
	registerIdentityMutex       sync.RWMutex
	registerIdentityArgsForCall []struct {
		arg1 context.Context
		arg2 driver.IdentityConfiguration
	}
	registerIdentityReturns struct {
		result1 error
	}
	registerIdentityReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *LocalMembership) DefaultNetworkIdentity() driver.Identity {
	fake.defaultNetworkIdentityMutex.Lock()
	ret, specificReturn := fake.defaultNetworkIdentityReturnsOnCall[len(fake.defaultNetworkIdentityArgsForCall)]
	fake.defaultNetworkIdentityArgsForCall = append(fake.defaultNetworkIdentityArgsForCall, struct {
	}{})
	stub := fake.DefaultNetworkIdentityStub
	fakeReturns := fake.defaultNetworkIdentityReturns
	fake.recordInvocation("DefaultNetworkIdentity", []interface{}{})
	fake.defaultNetworkIdentityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LocalMembership) DefaultNetworkIdentityCallCount() int {
	fake.defaultNetworkIdentityMutex.RLock()
	defer fake.defaultNetworkIdentityMutex.RUnlock()
	return len(fake.defaultNetworkIdentityArgsForCall)
}

func (fake *LocalMembership) DefaultNetworkIdentityCalls(stub func() driver.Identity) {
	fake.defaultNetworkIdentityMutex.Lock()
	defer fake.defaultNetworkIdentityMutex.Unlock()
	fake.DefaultNetworkIdentityStub = stub
}

func (fake *LocalMembership) DefaultNetworkIdentityReturns(result1 driver.Identity) {
	fake.defaultNetworkIdentityMutex.Lock()
	defer fake.defaultNetworkIdentityMutex.Unlock()
	fake.DefaultNetworkIdentityStub = nil
	fake.defaultNetworkIdentityReturns = struct {
		result1 driver.Identity
	}{result1}
}

func (fake *LocalMembership) DefaultNetworkIdentityReturnsOnCall(i int, result1 driver.Identity) {
	fake.defaultNetworkIdentityMutex.Lock()
	defer fake.defaultNetworkIdentityMutex.Unlock()
	fake.DefaultNetworkIdentityStub = nil
	if fake.defaultNetworkIdentityReturnsOnCall == nil {
		fake.defaultNetworkIdentityReturnsOnCall = make(map[int]struct {
			result1 driver.Identity
		})
	}
	fake.defaultNetworkIdentityReturnsOnCall[i] = struct {
		result1 driver.Identity
	}{result1}
}

func (fake *LocalMembership) GetDefaultIdentifier() string {
	fake.getDefaultIdentifierMutex.Lock()
	ret, specificReturn := fake.getDefaultIdentifierReturnsOnCall[len(fake.getDefaultIdentifierArgsForCall)]
	fake.getDefaultIdentifierArgsForCall = append(fake.getDefaultIdentifierArgsForCall, struct {
	}{})
	stub := fake.GetDefaultIdentifierStub
	fakeReturns := fake.getDefaultIdentifierReturns
	fake.recordInvocation("GetDefaultIdentifier", []interface{}{})
	fake.getDefaultIdentifierMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LocalMembership) GetDefaultIdentifierCallCount() int {
	fake.getDefaultIdentifierMutex.RLock()
	defer fake.getDefaultIdentifierMutex.RUnlock()
	return len(fake.getDefaultIdentifierArgsForCall)
}

func (fake *LocalMembership) GetDefaultIdentifierCalls(stub func() string) {
	fake.getDefaultIdentifierMutex.Lock()
	defer fake.getDefaultIdentifierMutex.Unlock()
	fake.GetDefaultIdentifierStub = stub
}

func (fake *LocalMembership) GetDefaultIdentifierReturns(result1 string) {
	fake.getDefaultIdentifierMutex.Lock()
	defer fake.getDefaultIdentifierMutex.Unlock()
	fake.GetDefaultIdentifierStub = nil
	fake.getDefaultIdentifierReturns = struct {
		result1 string
	}{result1}
}

func (fake *LocalMembership) GetDefaultIdentifierReturnsOnCall(i int, result1 string) {
	fake.getDefaultIdentifierMutex.Lock()
	defer fake.getDefaultIdentifierMutex.Unlock()
	fake.GetDefaultIdentifierStub = nil
	if fake.getDefaultIdentifierReturnsOnCall == nil {
		fake.getDefaultIdentifierReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getDefaultIdentifierReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *LocalMembership) GetIdentifier(arg1 context.Context, arg2 driver.Identity) (string, error) {
	fake.getIdentifierMutex.Lock()
	ret, specificReturn := fake.getIdentifierReturnsOnCall[len(fake.getIdentifierArgsForCall)]
	fake.getIdentifierArgsForCall = append(fake.getIdentifierArgsForCall, struct {
		arg1 context.Context
		arg2 driver.Identity
	}{arg1, arg2})
	stub := fake.GetIdentifierStub
	fakeReturns := fake.getIdentifierReturns
	fake.recordInvocation("GetIdentifier", []interface{}{arg1, arg2})
	fake.getIdentifierMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *LocalMembership) GetIdentifierCallCount() int {
	fake.getIdentifierMutex.RLock()
	defer fake.getIdentifierMutex.RUnlock()
	return len(fake.getIdentifierArgsForCall)
}

func (fake *LocalMembership) GetIdentifierCalls(stub func(context.Context, driver.Identity) (string, error)) {
	fake.getIdentifierMutex.Lock()
	defer fake.getIdentifierMutex.Unlock()
	fake.GetIdentifierStub = stub
}

func (fake *LocalMembership) GetIdentifierArgsForCall(i int) (context.Context, driver.Identity) {
	fake.getIdentifierMutex.RLock()
	defer fake.getIdentifierMutex.RUnlock()
	argsForCall := fake.getIdentifierArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LocalMembership) GetIdentifierReturns(result1 string, result2 error) {
	fake.getIdentifierMutex.Lock()
	defer fake.getIdentifierMutex.Unlock()
	fake.GetIdentifierStub = nil
	fake.getIdentifierReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *LocalMembership) GetIdentifierReturnsOnCall(i int, result1 string, result2 error) {
	fake.getIdentifierMutex.Lock()
	defer fake.getIdentifierMutex.Unlock()
	fake.GetIdentifierStub = nil
	if fake.getIdentifierReturnsOnCall == nil {
		fake.getIdentifierReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getIdentifierReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *LocalMembership) GetIdentityInfo(arg1 context.Context, arg2 string, arg3 []byte) (drivera.IdentityInfo, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.getIdentityInfoMutex.Lock()
	ret, specificReturn := fake.getIdentityInfoReturnsOnCall[len(fake.getIdentityInfoArgsForCall)]
	fake.getIdentityInfoArgsForCall = append(fake.getIdentityInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.GetIdentityInfoStub
	fakeReturns := fake.getIdentityInfoReturns
	fake.recordInvocation("GetIdentityInfo", []interface{}{arg1, arg2, arg3Copy})
	fake.getIdentityInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *LocalMembership) GetIdentityInfoCallCount() int {
	fake.getIdentityInfoMutex.RLock()
	defer fake.getIdentityInfoMutex.RUnlock()
	return len(fake.getIdentityInfoArgsForCall)
}

func (fake *LocalMembership) GetIdentityInfoCalls(stub func(context.Context, string, []byte) (drivera.IdentityInfo, error)) {
	fake.getIdentityInfoMutex.Lock()
	defer fake.getIdentityInfoMutex.Unlock()
	fake.GetIdentityInfoStub = stub
}

func (fake *LocalMembership) GetIdentityInfoArgsForCall(i int) (context.Context, string, []byte) {
	fake.getIdentityInfoMutex.RLock()
	defer fake.getIdentityInfoMutex.RUnlock()
	argsForCall := fake.getIdentityInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *LocalMembership) GetIdentityInfoReturns(result1 drivera.IdentityInfo, result2 error) {
	fake.getIdentityInfoMutex.Lock()
	defer fake.getIdentityInfoMutex.Unlock()
	fake.GetIdentityInfoStub = nil
	fake.getIdentityInfoReturns = struct {
		result1 drivera.IdentityInfo
		result2 error
	}{result1, result2}
}

func (fake *LocalMembership) GetIdentityInfoReturnsOnCall(i int, result1 drivera.IdentityInfo, result2 error) {
	fake.getIdentityInfoMutex.Lock()
	defer fake.getIdentityInfoMutex.Unlock()
	fake.GetIdentityInfoStub = nil
	if fake.getIdentityInfoReturnsOnCall == nil {
		fake.getIdentityInfoReturnsOnCall = make(map[int]struct {
			result1 drivera.IdentityInfo
			result2 error
		})
	}
	fake.getIdentityInfoReturnsOnCall[i] = struct {
		result1 drivera.IdentityInfo
		result2 error
	}{result1, result2}
}

func (fake *LocalMembership) IDs() ([]string, error) {
	fake.iDsMutex.Lock()
	ret, specificReturn := fake.iDsReturnsOnCall[len(fake.iDsArgsForCall)]
	fake.iDsArgsForCall = append(fake.iDsArgsForCall, struct {
	}{})
	stub := fake.IDsStub
	fakeReturns := fake.iDsReturns
	fake.recordInvocation("IDs", []interface{}{})
	fake.iDsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *LocalMembership) IDsCallCount() int {
	fake.iDsMutex.RLock()
	defer fake.iDsMutex.RUnlock()
	return len(fake.iDsArgsForCall)
}

func (fake *LocalMembership) IDsCalls(stub func() ([]string, error)) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = stub
}

func (fake *LocalMembership) IDsReturns(result1 []string, result2 error) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = nil
	fake.iDsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *LocalMembership) IDsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = nil
	if fake.iDsReturnsOnCall == nil {
		fake.iDsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.iDsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *LocalMembership) IsMe(arg1 context.Context, arg2 driver.Identity) bool {
	fake.isMeMutex.Lock()
	ret, specificReturn := fake.isMeReturnsOnCall[len(fake.isMeArgsForCall)]
	fake.isMeArgsForCall = append(fake.isMeArgsForCall, struct {
		arg1 context.Context
		arg2 driver.Identity
	}{arg1, arg2})
	stub := fake.IsMeStub
	fakeReturns := fake.isMeReturns
	fake.recordInvocation("IsMe", []interface{}{arg1, arg2})
	fake.isMeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LocalMembership) IsMeCallCount() int {
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	return len(fake.isMeArgsForCall)
}

func (fake *LocalMembership) IsMeCalls(stub func(context.Context, driver.Identity) bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = stub
}

func (fake *LocalMembership) IsMeArgsForCall(i int) (context.Context, driver.Identity) {
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	argsForCall := fake.isMeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LocalMembership) IsMeReturns(result1 bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = nil
	fake.isMeReturns = struct {
		result1 bool
	}{result1}
}

func (fake *LocalMembership) IsMeReturnsOnCall(i int, result1 bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = nil
	if fake.isMeReturnsOnCall == nil {
		fake.isMeReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isMeReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *LocalMembership) RegisterIdentity(arg1 context.Context, arg2 driver.IdentityConfiguration) error {
	fake.registerIdentityMutex.Lock()
	ret, specificReturn := fake.registerIdentityReturnsOnCall[len(fake.registerIdentityArgsForCall)]
	fake.registerIdentityArgsForCall = append(fake.registerIdentityArgsForCall, struct {
		arg1 context.Context
		arg2 driver.IdentityConfiguration
	}{arg1, arg2})
	stub := fake.RegisterIdentityStub
	fakeReturns := fake.registerIdentityReturns
	fake.recordInvocation("RegisterIdentity", []interface{}{arg1, arg2})
	fake.registerIdentityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *LocalMembership) RegisterIdentityCallCount() int {
	fake.registerIdentityMutex.RLock()
	defer fake.registerIdentityMutex.RUnlock()
	return len(fake.registerIdentityArgsForCall)
}

func (fake *LocalMembership) RegisterIdentityCalls(stub func(context.Context, driver.IdentityConfiguration) error) {
	fake.registerIdentityMutex.Lock()
	defer fake.registerIdentityMutex.Unlock()
	fake.RegisterIdentityStub = stub
}

func (fake *LocalMembership) RegisterIdentityArgsForCall(i int) (context.Context, driver.IdentityConfiguration) {
	fake.registerIdentityMutex.RLock()
	defer fake.registerIdentityMutex.RUnlock()
	argsForCall := fake.registerIdentityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *LocalMembership) RegisterIdentityReturns(result1 error) {
	fake.registerIdentityMutex.Lock()
	defer fake.registerIdentityMutex.Unlock()
	fake.RegisterIdentityStub = nil
	fake.registerIdentityReturns = struct {
		result1 error
	}{result1}
}

func (fake *LocalMembership) RegisterIdentityReturnsOnCall(i int, result1 error) {
	fake.registerIdentityMutex.Lock()
	defer fake.registerIdentityMutex.Unlock()
	fake.RegisterIdentityStub = nil
	if fake.registerIdentityReturnsOnCall == nil {
		fake.registerIdentityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerIdentityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *LocalMembership) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *LocalMembership) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ role.LocalMembership = new(LocalMembership)
