// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/storage/auditdb"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/ttx/dep/auditor"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/ttx/dep/db"
)

type AuditStoreService struct {
	NewHoldingsFilterStub        func() *auditdb.HoldingsFilter
	newHoldingsFilterMutex       sync.RWMutex
	newHoldingsFilterArgsForCall []struct {
	}
	newHoldingsFilterReturns struct {
		result1 *auditdb.HoldingsFilter
	}
	newHoldingsFilterReturnsOnCall map[int]struct {
		result1 *auditdb.HoldingsFilter
	}
	NewPaymentsFilterStub        func() *auditdb.PaymentsFilter
	newPaymentsFilterMutex       sync.RWMutex
	newPaymentsFilterArgsForCall []struct {
	}
	newPaymentsFilterReturns struct {
		result1 *auditdb.PaymentsFilter
	}
	newPaymentsFilterReturnsOnCall map[int]struct {
		result1 *auditdb.PaymentsFilter
	}
	SetStatusStub        func(context.Context, string, driver.TxStatus, string) error
	setStatusMutex       sync.RWMutex
	setStatusArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 driver.TxStatus
		arg4 string
	}
	setStatusReturns struct {
		result1 error
	}
	setStatusReturnsOnCall map[int]struct {
		result1 error
	}
	TransactionsStub        func(context.Context, db.QueryTransactionsParams, db.Pagination) (*db.PageTransactionsIterator, error)
	transactionsMutex       sync.RWMutex
	transactionsArgsForCall []struct {
		arg1 context.Context
		arg2 db.QueryTransactionsParams
		arg3 db.Pagination
	}
	transactionsReturns struct {
		result1 *db.PageTransactionsIterator
		result2 error
	}
	transactionsReturnsOnCall map[int]struct {
		result1 *db.PageTransactionsIterator
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *AuditStoreService) NewHoldingsFilter() *auditdb.HoldingsFilter {
	fake.newHoldingsFilterMutex.Lock()
	ret, specificReturn := fake.newHoldingsFilterReturnsOnCall[len(fake.newHoldingsFilterArgsForCall)]
	fake.newHoldingsFilterArgsForCall = append(fake.newHoldingsFilterArgsForCall, struct {
	}{})
	stub := fake.NewHoldingsFilterStub
	fakeReturns := fake.newHoldingsFilterReturns
	fake.recordInvocation("NewHoldingsFilter", []interface{}{})
	fake.newHoldingsFilterMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *AuditStoreService) NewHoldingsFilterCallCount() int {
	fake.newHoldingsFilterMutex.RLock()
	defer fake.newHoldingsFilterMutex.RUnlock()
	return len(fake.newHoldingsFilterArgsForCall)
}

func (fake *AuditStoreService) NewHoldingsFilterCalls(stub func() *auditdb.HoldingsFilter) {
	fake.newHoldingsFilterMutex.Lock()
	defer fake.newHoldingsFilterMutex.Unlock()
	fake.NewHoldingsFilterStub = stub
}

func (fake *AuditStoreService) NewHoldingsFilterReturns(result1 *auditdb.HoldingsFilter) {
	fake.newHoldingsFilterMutex.Lock()
	defer fake.newHoldingsFilterMutex.Unlock()
	fake.NewHoldingsFilterStub = nil
	fake.newHoldingsFilterReturns = struct {
		result1 *auditdb.HoldingsFilter
	}{result1}
}

func (fake *AuditStoreService) NewHoldingsFilterReturnsOnCall(i int, result1 *auditdb.HoldingsFilter) {
	fake.newHoldingsFilterMutex.Lock()
	defer fake.newHoldingsFilterMutex.Unlock()
	fake.NewHoldingsFilterStub = nil
	if fake.newHoldingsFilterReturnsOnCall == nil {
		fake.newHoldingsFilterReturnsOnCall = make(map[int]struct {
			result1 *auditdb.HoldingsFilter
		})
	}
	fake.newHoldingsFilterReturnsOnCall[i] = struct {
		result1 *auditdb.HoldingsFilter
	}{result1}
}

func (fake *AuditStoreService) NewPaymentsFilter() *auditdb.PaymentsFilter {
	fake.newPaymentsFilterMutex.Lock()
	ret, specificReturn := fake.newPaymentsFilterReturnsOnCall[len(fake.newPaymentsFilterArgsForCall)]
	fake.newPaymentsFilterArgsForCall = append(fake.newPaymentsFilterArgsForCall, struct {
	}{})
	stub := fake.NewPaymentsFilterStub
	fakeReturns := fake.newPaymentsFilterReturns
	fake.recordInvocation("NewPaymentsFilter", []interface{}{})
	fake.newPaymentsFilterMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *AuditStoreService) NewPaymentsFilterCallCount() int {
	fake.newPaymentsFilterMutex.RLock()
	defer fake.newPaymentsFilterMutex.RUnlock()
	return len(fake.newPaymentsFilterArgsForCall)
}

func (fake *AuditStoreService) NewPaymentsFilterCalls(stub func() *auditdb.PaymentsFilter) {
	fake.newPaymentsFilterMutex.Lock()
	defer fake.newPaymentsFilterMutex.Unlock()
	fake.NewPaymentsFilterStub = stub
}

func (fake *AuditStoreService) NewPaymentsFilterReturns(result1 *auditdb.PaymentsFilter) {
	fake.newPaymentsFilterMutex.Lock()
	defer fake.newPaymentsFilterMutex.Unlock()
	fake.NewPaymentsFilterStub = nil
	fake.newPaymentsFilterReturns = struct {
		result1 *auditdb.PaymentsFilter
	}{result1}
}

func (fake *AuditStoreService) NewPaymentsFilterReturnsOnCall(i int, result1 *auditdb.PaymentsFilter) {
	fake.newPaymentsFilterMutex.Lock()
	defer fake.newPaymentsFilterMutex.Unlock()
	fake.NewPaymentsFilterStub = nil
	if fake.newPaymentsFilterReturnsOnCall == nil {
		fake.newPaymentsFilterReturnsOnCall = make(map[int]struct {
			result1 *auditdb.PaymentsFilter
		})
	}
	fake.newPaymentsFilterReturnsOnCall[i] = struct {
		result1 *auditdb.PaymentsFilter
	}{result1}
}

func (fake *AuditStoreService) SetStatus(arg1 context.Context, arg2 string, arg3 driver.TxStatus, arg4 string) error {
	fake.setStatusMutex.Lock()
	ret, specificReturn := fake.setStatusReturnsOnCall[len(fake.setStatusArgsForCall)]
	fake.setStatusArgsForCall = append(fake.setStatusArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 driver.TxStatus
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.SetStatusStub
	fakeReturns := fake.setStatusReturns
	fake.recordInvocation("SetStatus", []interface{}{arg1, arg2, arg3, arg4})
	fake.setStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *AuditStoreService) SetStatusCallCount() int {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	return len(fake.setStatusArgsForCall)
}

func (fake *AuditStoreService) SetStatusCalls(stub func(context.Context, string, driver.TxStatus, string) error) {
	fake.setStatusMutex.Lock()
	defer fake.setStatusMutex.Unlock()
	fake.SetStatusStub = stub
}

func (fake *AuditStoreService) SetStatusArgsForCall(i int) (context.Context, string, driver.TxStatus, string) {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	argsForCall := fake.setStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *AuditStoreService) SetStatusReturns(result1 error) {
	fake.setStatusMutex.Lock()
	defer fake.setStatusMutex.Unlock()
	fake.SetStatusStub = nil
	fake.setStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *AuditStoreService) SetStatusReturnsOnCall(i int, result1 error) {
	fake.setStatusMutex.Lock()
	defer fake.setStatusMutex.Unlock()
	fake.SetStatusStub = nil
	if fake.setStatusReturnsOnCall == nil {
		fake.setStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *AuditStoreService) Transactions(arg1 context.Context, arg2 db.QueryTransactionsParams, arg3 db.Pagination) (*db.PageTransactionsIterator, error) {
	fake.transactionsMutex.Lock()
	ret, specificReturn := fake.transactionsReturnsOnCall[len(fake.transactionsArgsForCall)]
	fake.transactionsArgsForCall = append(fake.transactionsArgsForCall, struct {
		arg1 context.Context
		arg2 db.QueryTransactionsParams
		arg3 db.Pagination
	}{arg1, arg2, arg3})
	stub := fake.TransactionsStub
	fakeReturns := fake.transactionsReturns
	fake.recordInvocation("Transactions", []interface{}{arg1, arg2, arg3})
	fake.transactionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *AuditStoreService) TransactionsCallCount() int {
	fake.transactionsMutex.RLock()
	defer fake.transactionsMutex.RUnlock()
	return len(fake.transactionsArgsForCall)
}

func (fake *AuditStoreService) TransactionsCalls(stub func(context.Context, db.QueryTransactionsParams, db.Pagination) (*db.PageTransactionsIterator, error)) {
	fake.transactionsMutex.Lock()
	defer fake.transactionsMutex.Unlock()
	fake.TransactionsStub = stub
}

func (fake *AuditStoreService) TransactionsArgsForCall(i int) (context.Context, db.QueryTransactionsParams, db.Pagination) {
	fake.transactionsMutex.RLock()
	defer fake.transactionsMutex.RUnlock()
	argsForCall := fake.transactionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *AuditStoreService) TransactionsReturns(result1 *db.PageTransactionsIterator, result2 error) {
	fake.transactionsMutex.Lock()
	defer fake.transactionsMutex.Unlock()
	fake.TransactionsStub = nil
	fake.transactionsReturns = struct {
		result1 *db.PageTransactionsIterator
		result2 error
	}{result1, result2}
}

func (fake *AuditStoreService) TransactionsReturnsOnCall(i int, result1 *db.PageTransactionsIterator, result2 error) {
	fake.transactionsMutex.Lock()
	defer fake.transactionsMutex.Unlock()
	fake.TransactionsStub = nil
	if fake.transactionsReturnsOnCall == nil {
		fake.transactionsReturnsOnCall = make(map[int]struct {
			result1 *db.PageTransactionsIterator
			result2 error
		})
	}
	fake.transactionsReturnsOnCall[i] = struct {
		result1 *db.PageTransactionsIterator
		result2 error
	}{result1, result2}
}

func (fake *AuditStoreService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newHoldingsFilterMutex.RLock()
	defer fake.newHoldingsFilterMutex.RUnlock()
	fake.newPaymentsFilterMutex.RLock()
	defer fake.newPaymentsFilterMutex.RUnlock()
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	fake.transactionsMutex.RLock()
	defer fake.transactionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *AuditStoreService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ auditor.StoreService = new(AuditStoreService)
