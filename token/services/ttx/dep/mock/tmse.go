// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/ttx/dep"
)

type TokenManagementServiceWithExtensions struct {
	ChannelStub        func() string
	channelMutex       sync.RWMutex
	channelArgsForCall []struct {
	}
	channelReturns struct {
		result1 string
	}
	channelReturnsOnCall map[int]struct {
		result1 string
	}
	IDStub        func() token.TMSID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 token.TMSID
	}
	iDReturnsOnCall map[int]struct {
		result1 token.TMSID
	}
	NetworkStub        func() string
	networkMutex       sync.RWMutex
	networkArgsForCall []struct {
	}
	networkReturns struct {
		result1 string
	}
	networkReturnsOnCall map[int]struct {
		result1 string
	}
	NewFullRequestFromBytesStub        func([]byte) (*token.Request, error)
	newFullRequestFromBytesMutex       sync.RWMutex
	newFullRequestFromBytesArgsForCall []struct {
		arg1 []byte
	}
	newFullRequestFromBytesReturns struct {
		result1 *token.Request
		result2 error
	}
	newFullRequestFromBytesReturnsOnCall map[int]struct {
		result1 *token.Request
		result2 error
	}
	NewRequestStub        func(token.RequestAnchor) (*token.Request, error)
	newRequestMutex       sync.RWMutex
	newRequestArgsForCall []struct {
		arg1 token.RequestAnchor
	}
	newRequestReturns struct {
		result1 *token.Request
		result2 error
	}
	newRequestReturnsOnCall map[int]struct {
		result1 *token.Request
		result2 error
	}
	PublicParametersManagerStub        func() *token.PublicParametersManager
	publicParametersManagerMutex       sync.RWMutex
	publicParametersManagerArgsForCall []struct {
	}
	publicParametersManagerReturns struct {
		result1 *token.PublicParametersManager
	}
	publicParametersManagerReturnsOnCall map[int]struct {
		result1 *token.PublicParametersManager
	}
	SelectorManagerStub        func() (token.SelectorManager, error)
	selectorManagerMutex       sync.RWMutex
	selectorManagerArgsForCall []struct {
	}
	selectorManagerReturns struct {
		result1 token.SelectorManager
		result2 error
	}
	selectorManagerReturnsOnCall map[int]struct {
		result1 token.SelectorManager
		result2 error
	}
	SetTokenManagementServiceStub        func(*token.Request) error
	setTokenManagementServiceMutex       sync.RWMutex
	setTokenManagementServiceArgsForCall []struct {
		arg1 *token.Request
	}
	setTokenManagementServiceReturns struct {
		result1 error
	}
	setTokenManagementServiceReturnsOnCall map[int]struct {
		result1 error
	}
	SigServiceStub        func() *token.SignatureService
	sigServiceMutex       sync.RWMutex
	sigServiceArgsForCall []struct {
	}
	sigServiceReturns struct {
		result1 *token.SignatureService
	}
	sigServiceReturnsOnCall map[int]struct {
		result1 *token.SignatureService
	}
	VaultStub        func() *token.Vault
	vaultMutex       sync.RWMutex
	vaultArgsForCall []struct {
	}
	vaultReturns struct {
		result1 *token.Vault
	}
	vaultReturnsOnCall map[int]struct {
		result1 *token.Vault
	}
	WalletManagerStub        func() *token.WalletManager
	walletManagerMutex       sync.RWMutex
	walletManagerArgsForCall []struct {
	}
	walletManagerReturns struct {
		result1 *token.WalletManager
	}
	walletManagerReturnsOnCall map[int]struct {
		result1 *token.WalletManager
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TokenManagementServiceWithExtensions) Channel() string {
	fake.channelMutex.Lock()
	ret, specificReturn := fake.channelReturnsOnCall[len(fake.channelArgsForCall)]
	fake.channelArgsForCall = append(fake.channelArgsForCall, struct {
	}{})
	stub := fake.ChannelStub
	fakeReturns := fake.channelReturns
	fake.recordInvocation("Channel", []interface{}{})
	fake.channelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) ChannelCallCount() int {
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	return len(fake.channelArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) ChannelCalls(stub func() string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = stub
}

func (fake *TokenManagementServiceWithExtensions) ChannelReturns(result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	fake.channelReturns = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) ChannelReturnsOnCall(i int, result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	if fake.channelReturnsOnCall == nil {
		fake.channelReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.channelReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) ID() token.TMSID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) IDCalls(stub func() token.TMSID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *TokenManagementServiceWithExtensions) IDReturns(result1 token.TMSID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 token.TMSID
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) IDReturnsOnCall(i int, result1 token.TMSID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 token.TMSID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 token.TMSID
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) Network() string {
	fake.networkMutex.Lock()
	ret, specificReturn := fake.networkReturnsOnCall[len(fake.networkArgsForCall)]
	fake.networkArgsForCall = append(fake.networkArgsForCall, struct {
	}{})
	stub := fake.NetworkStub
	fakeReturns := fake.networkReturns
	fake.recordInvocation("Network", []interface{}{})
	fake.networkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) NetworkCallCount() int {
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	return len(fake.networkArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) NetworkCalls(stub func() string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = stub
}

func (fake *TokenManagementServiceWithExtensions) NetworkReturns(result1 string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	fake.networkReturns = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) NetworkReturnsOnCall(i int, result1 string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	if fake.networkReturnsOnCall == nil {
		fake.networkReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.networkReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) NewFullRequestFromBytes(arg1 []byte) (*token.Request, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newFullRequestFromBytesMutex.Lock()
	ret, specificReturn := fake.newFullRequestFromBytesReturnsOnCall[len(fake.newFullRequestFromBytesArgsForCall)]
	fake.newFullRequestFromBytesArgsForCall = append(fake.newFullRequestFromBytesArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.NewFullRequestFromBytesStub
	fakeReturns := fake.newFullRequestFromBytesReturns
	fake.recordInvocation("NewFullRequestFromBytes", []interface{}{arg1Copy})
	fake.newFullRequestFromBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenManagementServiceWithExtensions) NewFullRequestFromBytesCallCount() int {
	fake.newFullRequestFromBytesMutex.RLock()
	defer fake.newFullRequestFromBytesMutex.RUnlock()
	return len(fake.newFullRequestFromBytesArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) NewFullRequestFromBytesCalls(stub func([]byte) (*token.Request, error)) {
	fake.newFullRequestFromBytesMutex.Lock()
	defer fake.newFullRequestFromBytesMutex.Unlock()
	fake.NewFullRequestFromBytesStub = stub
}

func (fake *TokenManagementServiceWithExtensions) NewFullRequestFromBytesArgsForCall(i int) []byte {
	fake.newFullRequestFromBytesMutex.RLock()
	defer fake.newFullRequestFromBytesMutex.RUnlock()
	argsForCall := fake.newFullRequestFromBytesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenManagementServiceWithExtensions) NewFullRequestFromBytesReturns(result1 *token.Request, result2 error) {
	fake.newFullRequestFromBytesMutex.Lock()
	defer fake.newFullRequestFromBytesMutex.Unlock()
	fake.NewFullRequestFromBytesStub = nil
	fake.newFullRequestFromBytesReturns = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementServiceWithExtensions) NewFullRequestFromBytesReturnsOnCall(i int, result1 *token.Request, result2 error) {
	fake.newFullRequestFromBytesMutex.Lock()
	defer fake.newFullRequestFromBytesMutex.Unlock()
	fake.NewFullRequestFromBytesStub = nil
	if fake.newFullRequestFromBytesReturnsOnCall == nil {
		fake.newFullRequestFromBytesReturnsOnCall = make(map[int]struct {
			result1 *token.Request
			result2 error
		})
	}
	fake.newFullRequestFromBytesReturnsOnCall[i] = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementServiceWithExtensions) NewRequest(arg1 token.RequestAnchor) (*token.Request, error) {
	fake.newRequestMutex.Lock()
	ret, specificReturn := fake.newRequestReturnsOnCall[len(fake.newRequestArgsForCall)]
	fake.newRequestArgsForCall = append(fake.newRequestArgsForCall, struct {
		arg1 token.RequestAnchor
	}{arg1})
	stub := fake.NewRequestStub
	fakeReturns := fake.newRequestReturns
	fake.recordInvocation("NewRequest", []interface{}{arg1})
	fake.newRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenManagementServiceWithExtensions) NewRequestCallCount() int {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	return len(fake.newRequestArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) NewRequestCalls(stub func(token.RequestAnchor) (*token.Request, error)) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = stub
}

func (fake *TokenManagementServiceWithExtensions) NewRequestArgsForCall(i int) token.RequestAnchor {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	argsForCall := fake.newRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenManagementServiceWithExtensions) NewRequestReturns(result1 *token.Request, result2 error) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	fake.newRequestReturns = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementServiceWithExtensions) NewRequestReturnsOnCall(i int, result1 *token.Request, result2 error) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	if fake.newRequestReturnsOnCall == nil {
		fake.newRequestReturnsOnCall = make(map[int]struct {
			result1 *token.Request
			result2 error
		})
	}
	fake.newRequestReturnsOnCall[i] = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementServiceWithExtensions) PublicParametersManager() *token.PublicParametersManager {
	fake.publicParametersManagerMutex.Lock()
	ret, specificReturn := fake.publicParametersManagerReturnsOnCall[len(fake.publicParametersManagerArgsForCall)]
	fake.publicParametersManagerArgsForCall = append(fake.publicParametersManagerArgsForCall, struct {
	}{})
	stub := fake.PublicParametersManagerStub
	fakeReturns := fake.publicParametersManagerReturns
	fake.recordInvocation("PublicParametersManager", []interface{}{})
	fake.publicParametersManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) PublicParametersManagerCallCount() int {
	fake.publicParametersManagerMutex.RLock()
	defer fake.publicParametersManagerMutex.RUnlock()
	return len(fake.publicParametersManagerArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) PublicParametersManagerCalls(stub func() *token.PublicParametersManager) {
	fake.publicParametersManagerMutex.Lock()
	defer fake.publicParametersManagerMutex.Unlock()
	fake.PublicParametersManagerStub = stub
}

func (fake *TokenManagementServiceWithExtensions) PublicParametersManagerReturns(result1 *token.PublicParametersManager) {
	fake.publicParametersManagerMutex.Lock()
	defer fake.publicParametersManagerMutex.Unlock()
	fake.PublicParametersManagerStub = nil
	fake.publicParametersManagerReturns = struct {
		result1 *token.PublicParametersManager
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) PublicParametersManagerReturnsOnCall(i int, result1 *token.PublicParametersManager) {
	fake.publicParametersManagerMutex.Lock()
	defer fake.publicParametersManagerMutex.Unlock()
	fake.PublicParametersManagerStub = nil
	if fake.publicParametersManagerReturnsOnCall == nil {
		fake.publicParametersManagerReturnsOnCall = make(map[int]struct {
			result1 *token.PublicParametersManager
		})
	}
	fake.publicParametersManagerReturnsOnCall[i] = struct {
		result1 *token.PublicParametersManager
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) SelectorManager() (token.SelectorManager, error) {
	fake.selectorManagerMutex.Lock()
	ret, specificReturn := fake.selectorManagerReturnsOnCall[len(fake.selectorManagerArgsForCall)]
	fake.selectorManagerArgsForCall = append(fake.selectorManagerArgsForCall, struct {
	}{})
	stub := fake.SelectorManagerStub
	fakeReturns := fake.selectorManagerReturns
	fake.recordInvocation("SelectorManager", []interface{}{})
	fake.selectorManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenManagementServiceWithExtensions) SelectorManagerCallCount() int {
	fake.selectorManagerMutex.RLock()
	defer fake.selectorManagerMutex.RUnlock()
	return len(fake.selectorManagerArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) SelectorManagerCalls(stub func() (token.SelectorManager, error)) {
	fake.selectorManagerMutex.Lock()
	defer fake.selectorManagerMutex.Unlock()
	fake.SelectorManagerStub = stub
}

func (fake *TokenManagementServiceWithExtensions) SelectorManagerReturns(result1 token.SelectorManager, result2 error) {
	fake.selectorManagerMutex.Lock()
	defer fake.selectorManagerMutex.Unlock()
	fake.SelectorManagerStub = nil
	fake.selectorManagerReturns = struct {
		result1 token.SelectorManager
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementServiceWithExtensions) SelectorManagerReturnsOnCall(i int, result1 token.SelectorManager, result2 error) {
	fake.selectorManagerMutex.Lock()
	defer fake.selectorManagerMutex.Unlock()
	fake.SelectorManagerStub = nil
	if fake.selectorManagerReturnsOnCall == nil {
		fake.selectorManagerReturnsOnCall = make(map[int]struct {
			result1 token.SelectorManager
			result2 error
		})
	}
	fake.selectorManagerReturnsOnCall[i] = struct {
		result1 token.SelectorManager
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementServiceWithExtensions) SetTokenManagementService(arg1 *token.Request) error {
	fake.setTokenManagementServiceMutex.Lock()
	ret, specificReturn := fake.setTokenManagementServiceReturnsOnCall[len(fake.setTokenManagementServiceArgsForCall)]
	fake.setTokenManagementServiceArgsForCall = append(fake.setTokenManagementServiceArgsForCall, struct {
		arg1 *token.Request
	}{arg1})
	stub := fake.SetTokenManagementServiceStub
	fakeReturns := fake.setTokenManagementServiceReturns
	fake.recordInvocation("SetTokenManagementService", []interface{}{arg1})
	fake.setTokenManagementServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) SetTokenManagementServiceCallCount() int {
	fake.setTokenManagementServiceMutex.RLock()
	defer fake.setTokenManagementServiceMutex.RUnlock()
	return len(fake.setTokenManagementServiceArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) SetTokenManagementServiceCalls(stub func(*token.Request) error) {
	fake.setTokenManagementServiceMutex.Lock()
	defer fake.setTokenManagementServiceMutex.Unlock()
	fake.SetTokenManagementServiceStub = stub
}

func (fake *TokenManagementServiceWithExtensions) SetTokenManagementServiceArgsForCall(i int) *token.Request {
	fake.setTokenManagementServiceMutex.RLock()
	defer fake.setTokenManagementServiceMutex.RUnlock()
	argsForCall := fake.setTokenManagementServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenManagementServiceWithExtensions) SetTokenManagementServiceReturns(result1 error) {
	fake.setTokenManagementServiceMutex.Lock()
	defer fake.setTokenManagementServiceMutex.Unlock()
	fake.SetTokenManagementServiceStub = nil
	fake.setTokenManagementServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) SetTokenManagementServiceReturnsOnCall(i int, result1 error) {
	fake.setTokenManagementServiceMutex.Lock()
	defer fake.setTokenManagementServiceMutex.Unlock()
	fake.SetTokenManagementServiceStub = nil
	if fake.setTokenManagementServiceReturnsOnCall == nil {
		fake.setTokenManagementServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTokenManagementServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) SigService() *token.SignatureService {
	fake.sigServiceMutex.Lock()
	ret, specificReturn := fake.sigServiceReturnsOnCall[len(fake.sigServiceArgsForCall)]
	fake.sigServiceArgsForCall = append(fake.sigServiceArgsForCall, struct {
	}{})
	stub := fake.SigServiceStub
	fakeReturns := fake.sigServiceReturns
	fake.recordInvocation("SigService", []interface{}{})
	fake.sigServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) SigServiceCallCount() int {
	fake.sigServiceMutex.RLock()
	defer fake.sigServiceMutex.RUnlock()
	return len(fake.sigServiceArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) SigServiceCalls(stub func() *token.SignatureService) {
	fake.sigServiceMutex.Lock()
	defer fake.sigServiceMutex.Unlock()
	fake.SigServiceStub = stub
}

func (fake *TokenManagementServiceWithExtensions) SigServiceReturns(result1 *token.SignatureService) {
	fake.sigServiceMutex.Lock()
	defer fake.sigServiceMutex.Unlock()
	fake.SigServiceStub = nil
	fake.sigServiceReturns = struct {
		result1 *token.SignatureService
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) SigServiceReturnsOnCall(i int, result1 *token.SignatureService) {
	fake.sigServiceMutex.Lock()
	defer fake.sigServiceMutex.Unlock()
	fake.SigServiceStub = nil
	if fake.sigServiceReturnsOnCall == nil {
		fake.sigServiceReturnsOnCall = make(map[int]struct {
			result1 *token.SignatureService
		})
	}
	fake.sigServiceReturnsOnCall[i] = struct {
		result1 *token.SignatureService
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) Vault() *token.Vault {
	fake.vaultMutex.Lock()
	ret, specificReturn := fake.vaultReturnsOnCall[len(fake.vaultArgsForCall)]
	fake.vaultArgsForCall = append(fake.vaultArgsForCall, struct {
	}{})
	stub := fake.VaultStub
	fakeReturns := fake.vaultReturns
	fake.recordInvocation("Vault", []interface{}{})
	fake.vaultMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) VaultCallCount() int {
	fake.vaultMutex.RLock()
	defer fake.vaultMutex.RUnlock()
	return len(fake.vaultArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) VaultCalls(stub func() *token.Vault) {
	fake.vaultMutex.Lock()
	defer fake.vaultMutex.Unlock()
	fake.VaultStub = stub
}

func (fake *TokenManagementServiceWithExtensions) VaultReturns(result1 *token.Vault) {
	fake.vaultMutex.Lock()
	defer fake.vaultMutex.Unlock()
	fake.VaultStub = nil
	fake.vaultReturns = struct {
		result1 *token.Vault
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) VaultReturnsOnCall(i int, result1 *token.Vault) {
	fake.vaultMutex.Lock()
	defer fake.vaultMutex.Unlock()
	fake.VaultStub = nil
	if fake.vaultReturnsOnCall == nil {
		fake.vaultReturnsOnCall = make(map[int]struct {
			result1 *token.Vault
		})
	}
	fake.vaultReturnsOnCall[i] = struct {
		result1 *token.Vault
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) WalletManager() *token.WalletManager {
	fake.walletManagerMutex.Lock()
	ret, specificReturn := fake.walletManagerReturnsOnCall[len(fake.walletManagerArgsForCall)]
	fake.walletManagerArgsForCall = append(fake.walletManagerArgsForCall, struct {
	}{})
	stub := fake.WalletManagerStub
	fakeReturns := fake.walletManagerReturns
	fake.recordInvocation("WalletManager", []interface{}{})
	fake.walletManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementServiceWithExtensions) WalletManagerCallCount() int {
	fake.walletManagerMutex.RLock()
	defer fake.walletManagerMutex.RUnlock()
	return len(fake.walletManagerArgsForCall)
}

func (fake *TokenManagementServiceWithExtensions) WalletManagerCalls(stub func() *token.WalletManager) {
	fake.walletManagerMutex.Lock()
	defer fake.walletManagerMutex.Unlock()
	fake.WalletManagerStub = stub
}

func (fake *TokenManagementServiceWithExtensions) WalletManagerReturns(result1 *token.WalletManager) {
	fake.walletManagerMutex.Lock()
	defer fake.walletManagerMutex.Unlock()
	fake.WalletManagerStub = nil
	fake.walletManagerReturns = struct {
		result1 *token.WalletManager
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) WalletManagerReturnsOnCall(i int, result1 *token.WalletManager) {
	fake.walletManagerMutex.Lock()
	defer fake.walletManagerMutex.Unlock()
	fake.WalletManagerStub = nil
	if fake.walletManagerReturnsOnCall == nil {
		fake.walletManagerReturnsOnCall = make(map[int]struct {
			result1 *token.WalletManager
		})
	}
	fake.walletManagerReturnsOnCall[i] = struct {
		result1 *token.WalletManager
	}{result1}
}

func (fake *TokenManagementServiceWithExtensions) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	fake.newFullRequestFromBytesMutex.RLock()
	defer fake.newFullRequestFromBytesMutex.RUnlock()
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	fake.publicParametersManagerMutex.RLock()
	defer fake.publicParametersManagerMutex.RUnlock()
	fake.selectorManagerMutex.RLock()
	defer fake.selectorManagerMutex.RUnlock()
	fake.setTokenManagementServiceMutex.RLock()
	defer fake.setTokenManagementServiceMutex.RUnlock()
	fake.sigServiceMutex.RLock()
	defer fake.sigServiceMutex.RUnlock()
	fake.vaultMutex.RLock()
	defer fake.vaultMutex.RUnlock()
	fake.walletManagerMutex.RLock()
	defer fake.walletManagerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TokenManagementServiceWithExtensions) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dep.TokenManagementServiceWithExtensions = new(TokenManagementServiceWithExtensions)
