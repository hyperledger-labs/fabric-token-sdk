// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"

	"github.com/hyperledger-labs/fabric-smart-client/platform/view/view"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/ttx"
	"go.opentelemetry.io/otel/trace"
)

type Context struct {
	ContextStub        func() context.Context
	contextMutex       sync.RWMutex
	contextArgsForCall []struct {
	}
	contextReturns struct {
		result1 context.Context
	}
	contextReturnsOnCall map[int]struct {
		result1 context.Context
	}
	GetServiceStub        func(interface{}) (interface{}, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		arg1 interface{}
	}
	getServiceReturns struct {
		result1 interface{}
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetSessionStub        func(view.View, view.Identity, ...view.View) (view.Session, error)
	getSessionMutex       sync.RWMutex
	getSessionArgsForCall []struct {
		arg1 view.View
		arg2 view.Identity
		arg3 []view.View
	}
	getSessionReturns struct {
		result1 view.Session
		result2 error
	}
	getSessionReturnsOnCall map[int]struct {
		result1 view.Session
		result2 error
	}
	GetSessionByIDStub        func(string, view.Identity) (view.Session, error)
	getSessionByIDMutex       sync.RWMutex
	getSessionByIDArgsForCall []struct {
		arg1 string
		arg2 view.Identity
	}
	getSessionByIDReturns struct {
		result1 view.Session
		result2 error
	}
	getSessionByIDReturnsOnCall map[int]struct {
		result1 view.Session
		result2 error
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	InitiatorStub        func() view.View
	initiatorMutex       sync.RWMutex
	initiatorArgsForCall []struct {
	}
	initiatorReturns struct {
		result1 view.View
	}
	initiatorReturnsOnCall map[int]struct {
		result1 view.View
	}
	IsMeStub        func(view.Identity) bool
	isMeMutex       sync.RWMutex
	isMeArgsForCall []struct {
		arg1 view.Identity
	}
	isMeReturns struct {
		result1 bool
	}
	isMeReturnsOnCall map[int]struct {
		result1 bool
	}
	MeStub        func() view.Identity
	meMutex       sync.RWMutex
	meArgsForCall []struct {
	}
	meReturns struct {
		result1 view.Identity
	}
	meReturnsOnCall map[int]struct {
		result1 view.Identity
	}
	OnErrorStub        func(func())
	onErrorMutex       sync.RWMutex
	onErrorArgsForCall []struct {
		arg1 func()
	}
	RunViewStub        func(view.View, ...view.RunViewOption) (interface{}, error)
	runViewMutex       sync.RWMutex
	runViewArgsForCall []struct {
		arg1 view.View
		arg2 []view.RunViewOption
	}
	runViewReturns struct {
		result1 interface{}
		result2 error
	}
	runViewReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	SessionStub        func() view.Session
	sessionMutex       sync.RWMutex
	sessionArgsForCall []struct {
	}
	sessionReturns struct {
		result1 view.Session
	}
	sessionReturnsOnCall map[int]struct {
		result1 view.Session
	}
	StartSpanFromStub        func(context.Context, string, ...trace.SpanStartOption) (context.Context, trace.Span)
	startSpanFromMutex       sync.RWMutex
	startSpanFromArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []trace.SpanStartOption
	}
	startSpanFromReturns struct {
		result1 context.Context
		result2 trace.Span
	}
	startSpanFromReturnsOnCall map[int]struct {
		result1 context.Context
		result2 trace.Span
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Context) Context() context.Context {
	fake.contextMutex.Lock()
	ret, specificReturn := fake.contextReturnsOnCall[len(fake.contextArgsForCall)]
	fake.contextArgsForCall = append(fake.contextArgsForCall, struct {
	}{})
	stub := fake.ContextStub
	fakeReturns := fake.contextReturns
	fake.recordInvocation("Context", []interface{}{})
	fake.contextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Context) ContextCallCount() int {
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	return len(fake.contextArgsForCall)
}

func (fake *Context) ContextCalls(stub func() context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = stub
}

func (fake *Context) ContextReturns(result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	fake.contextReturns = struct {
		result1 context.Context
	}{result1}
}

func (fake *Context) ContextReturnsOnCall(i int, result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	if fake.contextReturnsOnCall == nil {
		fake.contextReturnsOnCall = make(map[int]struct {
			result1 context.Context
		})
	}
	fake.contextReturnsOnCall[i] = struct {
		result1 context.Context
	}{result1}
}

func (fake *Context) GetService(arg1 interface{}) (interface{}, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	stub := fake.GetServiceStub
	fakeReturns := fake.getServiceReturns
	fake.recordInvocation("GetService", []interface{}{arg1})
	fake.getServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Context) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *Context) GetServiceCalls(stub func(interface{}) (interface{}, error)) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = stub
}

func (fake *Context) GetServiceArgsForCall(i int) interface{} {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	argsForCall := fake.getServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Context) GetServiceReturns(result1 interface{}, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *Context) GetServiceReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *Context) GetSession(arg1 view.View, arg2 view.Identity, arg3 ...view.View) (view.Session, error) {
	fake.getSessionMutex.Lock()
	ret, specificReturn := fake.getSessionReturnsOnCall[len(fake.getSessionArgsForCall)]
	fake.getSessionArgsForCall = append(fake.getSessionArgsForCall, struct {
		arg1 view.View
		arg2 view.Identity
		arg3 []view.View
	}{arg1, arg2, arg3})
	stub := fake.GetSessionStub
	fakeReturns := fake.getSessionReturns
	fake.recordInvocation("GetSession", []interface{}{arg1, arg2, arg3})
	fake.getSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Context) GetSessionCallCount() int {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	return len(fake.getSessionArgsForCall)
}

func (fake *Context) GetSessionCalls(stub func(view.View, view.Identity, ...view.View) (view.Session, error)) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = stub
}

func (fake *Context) GetSessionArgsForCall(i int) (view.View, view.Identity, []view.View) {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	argsForCall := fake.getSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Context) GetSessionReturns(result1 view.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	fake.getSessionReturns = struct {
		result1 view.Session
		result2 error
	}{result1, result2}
}

func (fake *Context) GetSessionReturnsOnCall(i int, result1 view.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	if fake.getSessionReturnsOnCall == nil {
		fake.getSessionReturnsOnCall = make(map[int]struct {
			result1 view.Session
			result2 error
		})
	}
	fake.getSessionReturnsOnCall[i] = struct {
		result1 view.Session
		result2 error
	}{result1, result2}
}

func (fake *Context) GetSessionByID(arg1 string, arg2 view.Identity) (view.Session, error) {
	fake.getSessionByIDMutex.Lock()
	ret, specificReturn := fake.getSessionByIDReturnsOnCall[len(fake.getSessionByIDArgsForCall)]
	fake.getSessionByIDArgsForCall = append(fake.getSessionByIDArgsForCall, struct {
		arg1 string
		arg2 view.Identity
	}{arg1, arg2})
	stub := fake.GetSessionByIDStub
	fakeReturns := fake.getSessionByIDReturns
	fake.recordInvocation("GetSessionByID", []interface{}{arg1, arg2})
	fake.getSessionByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Context) GetSessionByIDCallCount() int {
	fake.getSessionByIDMutex.RLock()
	defer fake.getSessionByIDMutex.RUnlock()
	return len(fake.getSessionByIDArgsForCall)
}

func (fake *Context) GetSessionByIDCalls(stub func(string, view.Identity) (view.Session, error)) {
	fake.getSessionByIDMutex.Lock()
	defer fake.getSessionByIDMutex.Unlock()
	fake.GetSessionByIDStub = stub
}

func (fake *Context) GetSessionByIDArgsForCall(i int) (string, view.Identity) {
	fake.getSessionByIDMutex.RLock()
	defer fake.getSessionByIDMutex.RUnlock()
	argsForCall := fake.getSessionByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Context) GetSessionByIDReturns(result1 view.Session, result2 error) {
	fake.getSessionByIDMutex.Lock()
	defer fake.getSessionByIDMutex.Unlock()
	fake.GetSessionByIDStub = nil
	fake.getSessionByIDReturns = struct {
		result1 view.Session
		result2 error
	}{result1, result2}
}

func (fake *Context) GetSessionByIDReturnsOnCall(i int, result1 view.Session, result2 error) {
	fake.getSessionByIDMutex.Lock()
	defer fake.getSessionByIDMutex.Unlock()
	fake.GetSessionByIDStub = nil
	if fake.getSessionByIDReturnsOnCall == nil {
		fake.getSessionByIDReturnsOnCall = make(map[int]struct {
			result1 view.Session
			result2 error
		})
	}
	fake.getSessionByIDReturnsOnCall[i] = struct {
		result1 view.Session
		result2 error
	}{result1, result2}
}

func (fake *Context) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Context) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *Context) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *Context) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *Context) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Context) Initiator() view.View {
	fake.initiatorMutex.Lock()
	ret, specificReturn := fake.initiatorReturnsOnCall[len(fake.initiatorArgsForCall)]
	fake.initiatorArgsForCall = append(fake.initiatorArgsForCall, struct {
	}{})
	stub := fake.InitiatorStub
	fakeReturns := fake.initiatorReturns
	fake.recordInvocation("Initiator", []interface{}{})
	fake.initiatorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Context) InitiatorCallCount() int {
	fake.initiatorMutex.RLock()
	defer fake.initiatorMutex.RUnlock()
	return len(fake.initiatorArgsForCall)
}

func (fake *Context) InitiatorCalls(stub func() view.View) {
	fake.initiatorMutex.Lock()
	defer fake.initiatorMutex.Unlock()
	fake.InitiatorStub = stub
}

func (fake *Context) InitiatorReturns(result1 view.View) {
	fake.initiatorMutex.Lock()
	defer fake.initiatorMutex.Unlock()
	fake.InitiatorStub = nil
	fake.initiatorReturns = struct {
		result1 view.View
	}{result1}
}

func (fake *Context) InitiatorReturnsOnCall(i int, result1 view.View) {
	fake.initiatorMutex.Lock()
	defer fake.initiatorMutex.Unlock()
	fake.InitiatorStub = nil
	if fake.initiatorReturnsOnCall == nil {
		fake.initiatorReturnsOnCall = make(map[int]struct {
			result1 view.View
		})
	}
	fake.initiatorReturnsOnCall[i] = struct {
		result1 view.View
	}{result1}
}

func (fake *Context) IsMe(arg1 view.Identity) bool {
	fake.isMeMutex.Lock()
	ret, specificReturn := fake.isMeReturnsOnCall[len(fake.isMeArgsForCall)]
	fake.isMeArgsForCall = append(fake.isMeArgsForCall, struct {
		arg1 view.Identity
	}{arg1})
	stub := fake.IsMeStub
	fakeReturns := fake.isMeReturns
	fake.recordInvocation("IsMe", []interface{}{arg1})
	fake.isMeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Context) IsMeCallCount() int {
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	return len(fake.isMeArgsForCall)
}

func (fake *Context) IsMeCalls(stub func(view.Identity) bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = stub
}

func (fake *Context) IsMeArgsForCall(i int) view.Identity {
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	argsForCall := fake.isMeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Context) IsMeReturns(result1 bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = nil
	fake.isMeReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Context) IsMeReturnsOnCall(i int, result1 bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = nil
	if fake.isMeReturnsOnCall == nil {
		fake.isMeReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isMeReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Context) Me() view.Identity {
	fake.meMutex.Lock()
	ret, specificReturn := fake.meReturnsOnCall[len(fake.meArgsForCall)]
	fake.meArgsForCall = append(fake.meArgsForCall, struct {
	}{})
	stub := fake.MeStub
	fakeReturns := fake.meReturns
	fake.recordInvocation("Me", []interface{}{})
	fake.meMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Context) MeCallCount() int {
	fake.meMutex.RLock()
	defer fake.meMutex.RUnlock()
	return len(fake.meArgsForCall)
}

func (fake *Context) MeCalls(stub func() view.Identity) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = stub
}

func (fake *Context) MeReturns(result1 view.Identity) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = nil
	fake.meReturns = struct {
		result1 view.Identity
	}{result1}
}

func (fake *Context) MeReturnsOnCall(i int, result1 view.Identity) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = nil
	if fake.meReturnsOnCall == nil {
		fake.meReturnsOnCall = make(map[int]struct {
			result1 view.Identity
		})
	}
	fake.meReturnsOnCall[i] = struct {
		result1 view.Identity
	}{result1}
}

func (fake *Context) OnError(arg1 func()) {
	fake.onErrorMutex.Lock()
	fake.onErrorArgsForCall = append(fake.onErrorArgsForCall, struct {
		arg1 func()
	}{arg1})
	stub := fake.OnErrorStub
	fake.recordInvocation("OnError", []interface{}{arg1})
	fake.onErrorMutex.Unlock()
	if stub != nil {
		fake.OnErrorStub(arg1)
	}
}

func (fake *Context) OnErrorCallCount() int {
	fake.onErrorMutex.RLock()
	defer fake.onErrorMutex.RUnlock()
	return len(fake.onErrorArgsForCall)
}

func (fake *Context) OnErrorCalls(stub func(func())) {
	fake.onErrorMutex.Lock()
	defer fake.onErrorMutex.Unlock()
	fake.OnErrorStub = stub
}

func (fake *Context) OnErrorArgsForCall(i int) func() {
	fake.onErrorMutex.RLock()
	defer fake.onErrorMutex.RUnlock()
	argsForCall := fake.onErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Context) RunView(arg1 view.View, arg2 ...view.RunViewOption) (interface{}, error) {
	fake.runViewMutex.Lock()
	ret, specificReturn := fake.runViewReturnsOnCall[len(fake.runViewArgsForCall)]
	fake.runViewArgsForCall = append(fake.runViewArgsForCall, struct {
		arg1 view.View
		arg2 []view.RunViewOption
	}{arg1, arg2})
	stub := fake.RunViewStub
	fakeReturns := fake.runViewReturns
	fake.recordInvocation("RunView", []interface{}{arg1, arg2})
	fake.runViewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Context) RunViewCallCount() int {
	fake.runViewMutex.RLock()
	defer fake.runViewMutex.RUnlock()
	return len(fake.runViewArgsForCall)
}

func (fake *Context) RunViewCalls(stub func(view.View, ...view.RunViewOption) (interface{}, error)) {
	fake.runViewMutex.Lock()
	defer fake.runViewMutex.Unlock()
	fake.RunViewStub = stub
}

func (fake *Context) RunViewArgsForCall(i int) (view.View, []view.RunViewOption) {
	fake.runViewMutex.RLock()
	defer fake.runViewMutex.RUnlock()
	argsForCall := fake.runViewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Context) RunViewReturns(result1 interface{}, result2 error) {
	fake.runViewMutex.Lock()
	defer fake.runViewMutex.Unlock()
	fake.RunViewStub = nil
	fake.runViewReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *Context) RunViewReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.runViewMutex.Lock()
	defer fake.runViewMutex.Unlock()
	fake.RunViewStub = nil
	if fake.runViewReturnsOnCall == nil {
		fake.runViewReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.runViewReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *Context) Session() view.Session {
	fake.sessionMutex.Lock()
	ret, specificReturn := fake.sessionReturnsOnCall[len(fake.sessionArgsForCall)]
	fake.sessionArgsForCall = append(fake.sessionArgsForCall, struct {
	}{})
	stub := fake.SessionStub
	fakeReturns := fake.sessionReturns
	fake.recordInvocation("Session", []interface{}{})
	fake.sessionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Context) SessionCallCount() int {
	fake.sessionMutex.RLock()
	defer fake.sessionMutex.RUnlock()
	return len(fake.sessionArgsForCall)
}

func (fake *Context) SessionCalls(stub func() view.Session) {
	fake.sessionMutex.Lock()
	defer fake.sessionMutex.Unlock()
	fake.SessionStub = stub
}

func (fake *Context) SessionReturns(result1 view.Session) {
	fake.sessionMutex.Lock()
	defer fake.sessionMutex.Unlock()
	fake.SessionStub = nil
	fake.sessionReturns = struct {
		result1 view.Session
	}{result1}
}

func (fake *Context) SessionReturnsOnCall(i int, result1 view.Session) {
	fake.sessionMutex.Lock()
	defer fake.sessionMutex.Unlock()
	fake.SessionStub = nil
	if fake.sessionReturnsOnCall == nil {
		fake.sessionReturnsOnCall = make(map[int]struct {
			result1 view.Session
		})
	}
	fake.sessionReturnsOnCall[i] = struct {
		result1 view.Session
	}{result1}
}

func (fake *Context) StartSpanFrom(arg1 context.Context, arg2 string, arg3 ...trace.SpanStartOption) (context.Context, trace.Span) {
	fake.startSpanFromMutex.Lock()
	ret, specificReturn := fake.startSpanFromReturnsOnCall[len(fake.startSpanFromArgsForCall)]
	fake.startSpanFromArgsForCall = append(fake.startSpanFromArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []trace.SpanStartOption
	}{arg1, arg2, arg3})
	stub := fake.StartSpanFromStub
	fakeReturns := fake.startSpanFromReturns
	fake.recordInvocation("StartSpanFrom", []interface{}{arg1, arg2, arg3})
	fake.startSpanFromMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Context) StartSpanFromCallCount() int {
	fake.startSpanFromMutex.RLock()
	defer fake.startSpanFromMutex.RUnlock()
	return len(fake.startSpanFromArgsForCall)
}

func (fake *Context) StartSpanFromCalls(stub func(context.Context, string, ...trace.SpanStartOption) (context.Context, trace.Span)) {
	fake.startSpanFromMutex.Lock()
	defer fake.startSpanFromMutex.Unlock()
	fake.StartSpanFromStub = stub
}

func (fake *Context) StartSpanFromArgsForCall(i int) (context.Context, string, []trace.SpanStartOption) {
	fake.startSpanFromMutex.RLock()
	defer fake.startSpanFromMutex.RUnlock()
	argsForCall := fake.startSpanFromArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Context) StartSpanFromReturns(result1 context.Context, result2 trace.Span) {
	fake.startSpanFromMutex.Lock()
	defer fake.startSpanFromMutex.Unlock()
	fake.StartSpanFromStub = nil
	fake.startSpanFromReturns = struct {
		result1 context.Context
		result2 trace.Span
	}{result1, result2}
}

func (fake *Context) StartSpanFromReturnsOnCall(i int, result1 context.Context, result2 trace.Span) {
	fake.startSpanFromMutex.Lock()
	defer fake.startSpanFromMutex.Unlock()
	fake.StartSpanFromStub = nil
	if fake.startSpanFromReturnsOnCall == nil {
		fake.startSpanFromReturnsOnCall = make(map[int]struct {
			result1 context.Context
			result2 trace.Span
		})
	}
	fake.startSpanFromReturnsOnCall[i] = struct {
		result1 context.Context
		result2 trace.Span
	}{result1, result2}
}

func (fake *Context) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	fake.getSessionByIDMutex.RLock()
	defer fake.getSessionByIDMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.initiatorMutex.RLock()
	defer fake.initiatorMutex.RUnlock()
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	fake.meMutex.RLock()
	defer fake.meMutex.RUnlock()
	fake.onErrorMutex.RLock()
	defer fake.onErrorMutex.RUnlock()
	fake.runViewMutex.RLock()
	defer fake.runViewMutex.RUnlock()
	fake.sessionMutex.RLock()
	defer fake.sessionMutex.RUnlock()
	fake.startSpanFromMutex.RLock()
	defer fake.startSpanFromMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Context) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ttx.Context = new(Context)
