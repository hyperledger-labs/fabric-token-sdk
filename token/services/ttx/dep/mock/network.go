// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-smart-client/platform/view/view"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/ttx/dep"
)

type Network struct {
	AddFinalityListenerStub        func(string, string, network.FinalityListener) error
	addFinalityListenerMutex       sync.RWMutex
	addFinalityListenerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 network.FinalityListener
	}
	addFinalityListenerReturns struct {
		result1 error
	}
	addFinalityListenerReturnsOnCall map[int]struct {
		result1 error
	}
	AnonymousIdentityStub        func() (view.Identity, error)
	anonymousIdentityMutex       sync.RWMutex
	anonymousIdentityArgsForCall []struct {
	}
	anonymousIdentityReturns struct {
		result1 view.Identity
		result2 error
	}
	anonymousIdentityReturnsOnCall map[int]struct {
		result1 view.Identity
		result2 error
	}
	ComputeTxIDStub        func(*network.TxID) string
	computeTxIDMutex       sync.RWMutex
	computeTxIDArgsForCall []struct {
		arg1 *network.TxID
	}
	computeTxIDReturns struct {
		result1 string
	}
	computeTxIDReturnsOnCall map[int]struct {
		result1 string
	}
	LocalMembershipStub        func() *network.LocalMembership
	localMembershipMutex       sync.RWMutex
	localMembershipArgsForCall []struct {
	}
	localMembershipReturns struct {
		result1 *network.LocalMembership
	}
	localMembershipReturnsOnCall map[int]struct {
		result1 *network.LocalMembership
	}
	NewEnvelopeStub        func() *network.Envelope
	newEnvelopeMutex       sync.RWMutex
	newEnvelopeArgsForCall []struct {
	}
	newEnvelopeReturns struct {
		result1 *network.Envelope
	}
	newEnvelopeReturnsOnCall map[int]struct {
		result1 *network.Envelope
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Network) AddFinalityListener(arg1 string, arg2 string, arg3 network.FinalityListener) error {
	fake.addFinalityListenerMutex.Lock()
	ret, specificReturn := fake.addFinalityListenerReturnsOnCall[len(fake.addFinalityListenerArgsForCall)]
	fake.addFinalityListenerArgsForCall = append(fake.addFinalityListenerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 network.FinalityListener
	}{arg1, arg2, arg3})
	stub := fake.AddFinalityListenerStub
	fakeReturns := fake.addFinalityListenerReturns
	fake.recordInvocation("AddFinalityListener", []interface{}{arg1, arg2, arg3})
	fake.addFinalityListenerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) AddFinalityListenerCallCount() int {
	fake.addFinalityListenerMutex.RLock()
	defer fake.addFinalityListenerMutex.RUnlock()
	return len(fake.addFinalityListenerArgsForCall)
}

func (fake *Network) AddFinalityListenerCalls(stub func(string, string, network.FinalityListener) error) {
	fake.addFinalityListenerMutex.Lock()
	defer fake.addFinalityListenerMutex.Unlock()
	fake.AddFinalityListenerStub = stub
}

func (fake *Network) AddFinalityListenerArgsForCall(i int) (string, string, network.FinalityListener) {
	fake.addFinalityListenerMutex.RLock()
	defer fake.addFinalityListenerMutex.RUnlock()
	argsForCall := fake.addFinalityListenerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Network) AddFinalityListenerReturns(result1 error) {
	fake.addFinalityListenerMutex.Lock()
	defer fake.addFinalityListenerMutex.Unlock()
	fake.AddFinalityListenerStub = nil
	fake.addFinalityListenerReturns = struct {
		result1 error
	}{result1}
}

func (fake *Network) AddFinalityListenerReturnsOnCall(i int, result1 error) {
	fake.addFinalityListenerMutex.Lock()
	defer fake.addFinalityListenerMutex.Unlock()
	fake.AddFinalityListenerStub = nil
	if fake.addFinalityListenerReturnsOnCall == nil {
		fake.addFinalityListenerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFinalityListenerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Network) AnonymousIdentity() (view.Identity, error) {
	fake.anonymousIdentityMutex.Lock()
	ret, specificReturn := fake.anonymousIdentityReturnsOnCall[len(fake.anonymousIdentityArgsForCall)]
	fake.anonymousIdentityArgsForCall = append(fake.anonymousIdentityArgsForCall, struct {
	}{})
	stub := fake.AnonymousIdentityStub
	fakeReturns := fake.anonymousIdentityReturns
	fake.recordInvocation("AnonymousIdentity", []interface{}{})
	fake.anonymousIdentityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) AnonymousIdentityCallCount() int {
	fake.anonymousIdentityMutex.RLock()
	defer fake.anonymousIdentityMutex.RUnlock()
	return len(fake.anonymousIdentityArgsForCall)
}

func (fake *Network) AnonymousIdentityCalls(stub func() (view.Identity, error)) {
	fake.anonymousIdentityMutex.Lock()
	defer fake.anonymousIdentityMutex.Unlock()
	fake.AnonymousIdentityStub = stub
}

func (fake *Network) AnonymousIdentityReturns(result1 view.Identity, result2 error) {
	fake.anonymousIdentityMutex.Lock()
	defer fake.anonymousIdentityMutex.Unlock()
	fake.AnonymousIdentityStub = nil
	fake.anonymousIdentityReturns = struct {
		result1 view.Identity
		result2 error
	}{result1, result2}
}

func (fake *Network) AnonymousIdentityReturnsOnCall(i int, result1 view.Identity, result2 error) {
	fake.anonymousIdentityMutex.Lock()
	defer fake.anonymousIdentityMutex.Unlock()
	fake.AnonymousIdentityStub = nil
	if fake.anonymousIdentityReturnsOnCall == nil {
		fake.anonymousIdentityReturnsOnCall = make(map[int]struct {
			result1 view.Identity
			result2 error
		})
	}
	fake.anonymousIdentityReturnsOnCall[i] = struct {
		result1 view.Identity
		result2 error
	}{result1, result2}
}

func (fake *Network) ComputeTxID(arg1 *network.TxID) string {
	fake.computeTxIDMutex.Lock()
	ret, specificReturn := fake.computeTxIDReturnsOnCall[len(fake.computeTxIDArgsForCall)]
	fake.computeTxIDArgsForCall = append(fake.computeTxIDArgsForCall, struct {
		arg1 *network.TxID
	}{arg1})
	stub := fake.ComputeTxIDStub
	fakeReturns := fake.computeTxIDReturns
	fake.recordInvocation("ComputeTxID", []interface{}{arg1})
	fake.computeTxIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) ComputeTxIDCallCount() int {
	fake.computeTxIDMutex.RLock()
	defer fake.computeTxIDMutex.RUnlock()
	return len(fake.computeTxIDArgsForCall)
}

func (fake *Network) ComputeTxIDCalls(stub func(*network.TxID) string) {
	fake.computeTxIDMutex.Lock()
	defer fake.computeTxIDMutex.Unlock()
	fake.ComputeTxIDStub = stub
}

func (fake *Network) ComputeTxIDArgsForCall(i int) *network.TxID {
	fake.computeTxIDMutex.RLock()
	defer fake.computeTxIDMutex.RUnlock()
	argsForCall := fake.computeTxIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Network) ComputeTxIDReturns(result1 string) {
	fake.computeTxIDMutex.Lock()
	defer fake.computeTxIDMutex.Unlock()
	fake.ComputeTxIDStub = nil
	fake.computeTxIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *Network) ComputeTxIDReturnsOnCall(i int, result1 string) {
	fake.computeTxIDMutex.Lock()
	defer fake.computeTxIDMutex.Unlock()
	fake.ComputeTxIDStub = nil
	if fake.computeTxIDReturnsOnCall == nil {
		fake.computeTxIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.computeTxIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Network) LocalMembership() *network.LocalMembership {
	fake.localMembershipMutex.Lock()
	ret, specificReturn := fake.localMembershipReturnsOnCall[len(fake.localMembershipArgsForCall)]
	fake.localMembershipArgsForCall = append(fake.localMembershipArgsForCall, struct {
	}{})
	stub := fake.LocalMembershipStub
	fakeReturns := fake.localMembershipReturns
	fake.recordInvocation("LocalMembership", []interface{}{})
	fake.localMembershipMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) LocalMembershipCallCount() int {
	fake.localMembershipMutex.RLock()
	defer fake.localMembershipMutex.RUnlock()
	return len(fake.localMembershipArgsForCall)
}

func (fake *Network) LocalMembershipCalls(stub func() *network.LocalMembership) {
	fake.localMembershipMutex.Lock()
	defer fake.localMembershipMutex.Unlock()
	fake.LocalMembershipStub = stub
}

func (fake *Network) LocalMembershipReturns(result1 *network.LocalMembership) {
	fake.localMembershipMutex.Lock()
	defer fake.localMembershipMutex.Unlock()
	fake.LocalMembershipStub = nil
	fake.localMembershipReturns = struct {
		result1 *network.LocalMembership
	}{result1}
}

func (fake *Network) LocalMembershipReturnsOnCall(i int, result1 *network.LocalMembership) {
	fake.localMembershipMutex.Lock()
	defer fake.localMembershipMutex.Unlock()
	fake.LocalMembershipStub = nil
	if fake.localMembershipReturnsOnCall == nil {
		fake.localMembershipReturnsOnCall = make(map[int]struct {
			result1 *network.LocalMembership
		})
	}
	fake.localMembershipReturnsOnCall[i] = struct {
		result1 *network.LocalMembership
	}{result1}
}

func (fake *Network) NewEnvelope() *network.Envelope {
	fake.newEnvelopeMutex.Lock()
	ret, specificReturn := fake.newEnvelopeReturnsOnCall[len(fake.newEnvelopeArgsForCall)]
	fake.newEnvelopeArgsForCall = append(fake.newEnvelopeArgsForCall, struct {
	}{})
	stub := fake.NewEnvelopeStub
	fakeReturns := fake.newEnvelopeReturns
	fake.recordInvocation("NewEnvelope", []interface{}{})
	fake.newEnvelopeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) NewEnvelopeCallCount() int {
	fake.newEnvelopeMutex.RLock()
	defer fake.newEnvelopeMutex.RUnlock()
	return len(fake.newEnvelopeArgsForCall)
}

func (fake *Network) NewEnvelopeCalls(stub func() *network.Envelope) {
	fake.newEnvelopeMutex.Lock()
	defer fake.newEnvelopeMutex.Unlock()
	fake.NewEnvelopeStub = stub
}

func (fake *Network) NewEnvelopeReturns(result1 *network.Envelope) {
	fake.newEnvelopeMutex.Lock()
	defer fake.newEnvelopeMutex.Unlock()
	fake.NewEnvelopeStub = nil
	fake.newEnvelopeReturns = struct {
		result1 *network.Envelope
	}{result1}
}

func (fake *Network) NewEnvelopeReturnsOnCall(i int, result1 *network.Envelope) {
	fake.newEnvelopeMutex.Lock()
	defer fake.newEnvelopeMutex.Unlock()
	fake.NewEnvelopeStub = nil
	if fake.newEnvelopeReturnsOnCall == nil {
		fake.newEnvelopeReturnsOnCall = make(map[int]struct {
			result1 *network.Envelope
		})
	}
	fake.newEnvelopeReturnsOnCall[i] = struct {
		result1 *network.Envelope
	}{result1}
}

func (fake *Network) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Network) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dep.Network = new(Network)
