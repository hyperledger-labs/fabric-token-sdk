// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/ttx/dep"
)

type TokenManagementService struct {
	ChannelStub        func() string
	channelMutex       sync.RWMutex
	channelArgsForCall []struct {
	}
	channelReturns struct {
		result1 string
	}
	channelReturnsOnCall map[int]struct {
		result1 string
	}
	IDStub        func() token.TMSID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 token.TMSID
	}
	iDReturnsOnCall map[int]struct {
		result1 token.TMSID
	}
	NetworkStub        func() string
	networkMutex       sync.RWMutex
	networkArgsForCall []struct {
	}
	networkReturns struct {
		result1 string
	}
	networkReturnsOnCall map[int]struct {
		result1 string
	}
	NewFullRequestFromBytesStub        func([]byte) (*token.Request, error)
	newFullRequestFromBytesMutex       sync.RWMutex
	newFullRequestFromBytesArgsForCall []struct {
		arg1 []byte
	}
	newFullRequestFromBytesReturns struct {
		result1 *token.Request
		result2 error
	}
	newFullRequestFromBytesReturnsOnCall map[int]struct {
		result1 *token.Request
		result2 error
	}
	NewRequestStub        func(token.RequestAnchor) (*token.Request, error)
	newRequestMutex       sync.RWMutex
	newRequestArgsForCall []struct {
		arg1 token.RequestAnchor
	}
	newRequestReturns struct {
		result1 *token.Request
		result2 error
	}
	newRequestReturnsOnCall map[int]struct {
		result1 *token.Request
		result2 error
	}
	PublicParametersManagerStub        func() *token.PublicParametersManager
	publicParametersManagerMutex       sync.RWMutex
	publicParametersManagerArgsForCall []struct {
	}
	publicParametersManagerReturns struct {
		result1 *token.PublicParametersManager
	}
	publicParametersManagerReturnsOnCall map[int]struct {
		result1 *token.PublicParametersManager
	}
	SelectorManagerStub        func() (token.SelectorManager, error)
	selectorManagerMutex       sync.RWMutex
	selectorManagerArgsForCall []struct {
	}
	selectorManagerReturns struct {
		result1 token.SelectorManager
		result2 error
	}
	selectorManagerReturnsOnCall map[int]struct {
		result1 token.SelectorManager
		result2 error
	}
	SigServiceStub        func() *token.SignatureService
	sigServiceMutex       sync.RWMutex
	sigServiceArgsForCall []struct {
	}
	sigServiceReturns struct {
		result1 *token.SignatureService
	}
	sigServiceReturnsOnCall map[int]struct {
		result1 *token.SignatureService
	}
	VaultStub        func() *token.Vault
	vaultMutex       sync.RWMutex
	vaultArgsForCall []struct {
	}
	vaultReturns struct {
		result1 *token.Vault
	}
	vaultReturnsOnCall map[int]struct {
		result1 *token.Vault
	}
	WalletManagerStub        func() *token.WalletManager
	walletManagerMutex       sync.RWMutex
	walletManagerArgsForCall []struct {
	}
	walletManagerReturns struct {
		result1 *token.WalletManager
	}
	walletManagerReturnsOnCall map[int]struct {
		result1 *token.WalletManager
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TokenManagementService) Channel() string {
	fake.channelMutex.Lock()
	ret, specificReturn := fake.channelReturnsOnCall[len(fake.channelArgsForCall)]
	fake.channelArgsForCall = append(fake.channelArgsForCall, struct {
	}{})
	stub := fake.ChannelStub
	fakeReturns := fake.channelReturns
	fake.recordInvocation("Channel", []interface{}{})
	fake.channelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementService) ChannelCallCount() int {
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	return len(fake.channelArgsForCall)
}

func (fake *TokenManagementService) ChannelCalls(stub func() string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = stub
}

func (fake *TokenManagementService) ChannelReturns(result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	fake.channelReturns = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementService) ChannelReturnsOnCall(i int, result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	if fake.channelReturnsOnCall == nil {
		fake.channelReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.channelReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementService) ID() token.TMSID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementService) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *TokenManagementService) IDCalls(stub func() token.TMSID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *TokenManagementService) IDReturns(result1 token.TMSID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 token.TMSID
	}{result1}
}

func (fake *TokenManagementService) IDReturnsOnCall(i int, result1 token.TMSID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 token.TMSID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 token.TMSID
	}{result1}
}

func (fake *TokenManagementService) Network() string {
	fake.networkMutex.Lock()
	ret, specificReturn := fake.networkReturnsOnCall[len(fake.networkArgsForCall)]
	fake.networkArgsForCall = append(fake.networkArgsForCall, struct {
	}{})
	stub := fake.NetworkStub
	fakeReturns := fake.networkReturns
	fake.recordInvocation("Network", []interface{}{})
	fake.networkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementService) NetworkCallCount() int {
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	return len(fake.networkArgsForCall)
}

func (fake *TokenManagementService) NetworkCalls(stub func() string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = stub
}

func (fake *TokenManagementService) NetworkReturns(result1 string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	fake.networkReturns = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementService) NetworkReturnsOnCall(i int, result1 string) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	if fake.networkReturnsOnCall == nil {
		fake.networkReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.networkReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TokenManagementService) NewFullRequestFromBytes(arg1 []byte) (*token.Request, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newFullRequestFromBytesMutex.Lock()
	ret, specificReturn := fake.newFullRequestFromBytesReturnsOnCall[len(fake.newFullRequestFromBytesArgsForCall)]
	fake.newFullRequestFromBytesArgsForCall = append(fake.newFullRequestFromBytesArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.NewFullRequestFromBytesStub
	fakeReturns := fake.newFullRequestFromBytesReturns
	fake.recordInvocation("NewFullRequestFromBytes", []interface{}{arg1Copy})
	fake.newFullRequestFromBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenManagementService) NewFullRequestFromBytesCallCount() int {
	fake.newFullRequestFromBytesMutex.RLock()
	defer fake.newFullRequestFromBytesMutex.RUnlock()
	return len(fake.newFullRequestFromBytesArgsForCall)
}

func (fake *TokenManagementService) NewFullRequestFromBytesCalls(stub func([]byte) (*token.Request, error)) {
	fake.newFullRequestFromBytesMutex.Lock()
	defer fake.newFullRequestFromBytesMutex.Unlock()
	fake.NewFullRequestFromBytesStub = stub
}

func (fake *TokenManagementService) NewFullRequestFromBytesArgsForCall(i int) []byte {
	fake.newFullRequestFromBytesMutex.RLock()
	defer fake.newFullRequestFromBytesMutex.RUnlock()
	argsForCall := fake.newFullRequestFromBytesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenManagementService) NewFullRequestFromBytesReturns(result1 *token.Request, result2 error) {
	fake.newFullRequestFromBytesMutex.Lock()
	defer fake.newFullRequestFromBytesMutex.Unlock()
	fake.NewFullRequestFromBytesStub = nil
	fake.newFullRequestFromBytesReturns = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementService) NewFullRequestFromBytesReturnsOnCall(i int, result1 *token.Request, result2 error) {
	fake.newFullRequestFromBytesMutex.Lock()
	defer fake.newFullRequestFromBytesMutex.Unlock()
	fake.NewFullRequestFromBytesStub = nil
	if fake.newFullRequestFromBytesReturnsOnCall == nil {
		fake.newFullRequestFromBytesReturnsOnCall = make(map[int]struct {
			result1 *token.Request
			result2 error
		})
	}
	fake.newFullRequestFromBytesReturnsOnCall[i] = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementService) NewRequest(arg1 token.RequestAnchor) (*token.Request, error) {
	fake.newRequestMutex.Lock()
	ret, specificReturn := fake.newRequestReturnsOnCall[len(fake.newRequestArgsForCall)]
	fake.newRequestArgsForCall = append(fake.newRequestArgsForCall, struct {
		arg1 token.RequestAnchor
	}{arg1})
	stub := fake.NewRequestStub
	fakeReturns := fake.newRequestReturns
	fake.recordInvocation("NewRequest", []interface{}{arg1})
	fake.newRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenManagementService) NewRequestCallCount() int {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	return len(fake.newRequestArgsForCall)
}

func (fake *TokenManagementService) NewRequestCalls(stub func(token.RequestAnchor) (*token.Request, error)) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = stub
}

func (fake *TokenManagementService) NewRequestArgsForCall(i int) token.RequestAnchor {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	argsForCall := fake.newRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TokenManagementService) NewRequestReturns(result1 *token.Request, result2 error) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	fake.newRequestReturns = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementService) NewRequestReturnsOnCall(i int, result1 *token.Request, result2 error) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	if fake.newRequestReturnsOnCall == nil {
		fake.newRequestReturnsOnCall = make(map[int]struct {
			result1 *token.Request
			result2 error
		})
	}
	fake.newRequestReturnsOnCall[i] = struct {
		result1 *token.Request
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementService) PublicParametersManager() *token.PublicParametersManager {
	fake.publicParametersManagerMutex.Lock()
	ret, specificReturn := fake.publicParametersManagerReturnsOnCall[len(fake.publicParametersManagerArgsForCall)]
	fake.publicParametersManagerArgsForCall = append(fake.publicParametersManagerArgsForCall, struct {
	}{})
	stub := fake.PublicParametersManagerStub
	fakeReturns := fake.publicParametersManagerReturns
	fake.recordInvocation("PublicParametersManager", []interface{}{})
	fake.publicParametersManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementService) PublicParametersManagerCallCount() int {
	fake.publicParametersManagerMutex.RLock()
	defer fake.publicParametersManagerMutex.RUnlock()
	return len(fake.publicParametersManagerArgsForCall)
}

func (fake *TokenManagementService) PublicParametersManagerCalls(stub func() *token.PublicParametersManager) {
	fake.publicParametersManagerMutex.Lock()
	defer fake.publicParametersManagerMutex.Unlock()
	fake.PublicParametersManagerStub = stub
}

func (fake *TokenManagementService) PublicParametersManagerReturns(result1 *token.PublicParametersManager) {
	fake.publicParametersManagerMutex.Lock()
	defer fake.publicParametersManagerMutex.Unlock()
	fake.PublicParametersManagerStub = nil
	fake.publicParametersManagerReturns = struct {
		result1 *token.PublicParametersManager
	}{result1}
}

func (fake *TokenManagementService) PublicParametersManagerReturnsOnCall(i int, result1 *token.PublicParametersManager) {
	fake.publicParametersManagerMutex.Lock()
	defer fake.publicParametersManagerMutex.Unlock()
	fake.PublicParametersManagerStub = nil
	if fake.publicParametersManagerReturnsOnCall == nil {
		fake.publicParametersManagerReturnsOnCall = make(map[int]struct {
			result1 *token.PublicParametersManager
		})
	}
	fake.publicParametersManagerReturnsOnCall[i] = struct {
		result1 *token.PublicParametersManager
	}{result1}
}

func (fake *TokenManagementService) SelectorManager() (token.SelectorManager, error) {
	fake.selectorManagerMutex.Lock()
	ret, specificReturn := fake.selectorManagerReturnsOnCall[len(fake.selectorManagerArgsForCall)]
	fake.selectorManagerArgsForCall = append(fake.selectorManagerArgsForCall, struct {
	}{})
	stub := fake.SelectorManagerStub
	fakeReturns := fake.selectorManagerReturns
	fake.recordInvocation("SelectorManager", []interface{}{})
	fake.selectorManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenManagementService) SelectorManagerCallCount() int {
	fake.selectorManagerMutex.RLock()
	defer fake.selectorManagerMutex.RUnlock()
	return len(fake.selectorManagerArgsForCall)
}

func (fake *TokenManagementService) SelectorManagerCalls(stub func() (token.SelectorManager, error)) {
	fake.selectorManagerMutex.Lock()
	defer fake.selectorManagerMutex.Unlock()
	fake.SelectorManagerStub = stub
}

func (fake *TokenManagementService) SelectorManagerReturns(result1 token.SelectorManager, result2 error) {
	fake.selectorManagerMutex.Lock()
	defer fake.selectorManagerMutex.Unlock()
	fake.SelectorManagerStub = nil
	fake.selectorManagerReturns = struct {
		result1 token.SelectorManager
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementService) SelectorManagerReturnsOnCall(i int, result1 token.SelectorManager, result2 error) {
	fake.selectorManagerMutex.Lock()
	defer fake.selectorManagerMutex.Unlock()
	fake.SelectorManagerStub = nil
	if fake.selectorManagerReturnsOnCall == nil {
		fake.selectorManagerReturnsOnCall = make(map[int]struct {
			result1 token.SelectorManager
			result2 error
		})
	}
	fake.selectorManagerReturnsOnCall[i] = struct {
		result1 token.SelectorManager
		result2 error
	}{result1, result2}
}

func (fake *TokenManagementService) SigService() *token.SignatureService {
	fake.sigServiceMutex.Lock()
	ret, specificReturn := fake.sigServiceReturnsOnCall[len(fake.sigServiceArgsForCall)]
	fake.sigServiceArgsForCall = append(fake.sigServiceArgsForCall, struct {
	}{})
	stub := fake.SigServiceStub
	fakeReturns := fake.sigServiceReturns
	fake.recordInvocation("SigService", []interface{}{})
	fake.sigServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementService) SigServiceCallCount() int {
	fake.sigServiceMutex.RLock()
	defer fake.sigServiceMutex.RUnlock()
	return len(fake.sigServiceArgsForCall)
}

func (fake *TokenManagementService) SigServiceCalls(stub func() *token.SignatureService) {
	fake.sigServiceMutex.Lock()
	defer fake.sigServiceMutex.Unlock()
	fake.SigServiceStub = stub
}

func (fake *TokenManagementService) SigServiceReturns(result1 *token.SignatureService) {
	fake.sigServiceMutex.Lock()
	defer fake.sigServiceMutex.Unlock()
	fake.SigServiceStub = nil
	fake.sigServiceReturns = struct {
		result1 *token.SignatureService
	}{result1}
}

func (fake *TokenManagementService) SigServiceReturnsOnCall(i int, result1 *token.SignatureService) {
	fake.sigServiceMutex.Lock()
	defer fake.sigServiceMutex.Unlock()
	fake.SigServiceStub = nil
	if fake.sigServiceReturnsOnCall == nil {
		fake.sigServiceReturnsOnCall = make(map[int]struct {
			result1 *token.SignatureService
		})
	}
	fake.sigServiceReturnsOnCall[i] = struct {
		result1 *token.SignatureService
	}{result1}
}

func (fake *TokenManagementService) Vault() *token.Vault {
	fake.vaultMutex.Lock()
	ret, specificReturn := fake.vaultReturnsOnCall[len(fake.vaultArgsForCall)]
	fake.vaultArgsForCall = append(fake.vaultArgsForCall, struct {
	}{})
	stub := fake.VaultStub
	fakeReturns := fake.vaultReturns
	fake.recordInvocation("Vault", []interface{}{})
	fake.vaultMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementService) VaultCallCount() int {
	fake.vaultMutex.RLock()
	defer fake.vaultMutex.RUnlock()
	return len(fake.vaultArgsForCall)
}

func (fake *TokenManagementService) VaultCalls(stub func() *token.Vault) {
	fake.vaultMutex.Lock()
	defer fake.vaultMutex.Unlock()
	fake.VaultStub = stub
}

func (fake *TokenManagementService) VaultReturns(result1 *token.Vault) {
	fake.vaultMutex.Lock()
	defer fake.vaultMutex.Unlock()
	fake.VaultStub = nil
	fake.vaultReturns = struct {
		result1 *token.Vault
	}{result1}
}

func (fake *TokenManagementService) VaultReturnsOnCall(i int, result1 *token.Vault) {
	fake.vaultMutex.Lock()
	defer fake.vaultMutex.Unlock()
	fake.VaultStub = nil
	if fake.vaultReturnsOnCall == nil {
		fake.vaultReturnsOnCall = make(map[int]struct {
			result1 *token.Vault
		})
	}
	fake.vaultReturnsOnCall[i] = struct {
		result1 *token.Vault
	}{result1}
}

func (fake *TokenManagementService) WalletManager() *token.WalletManager {
	fake.walletManagerMutex.Lock()
	ret, specificReturn := fake.walletManagerReturnsOnCall[len(fake.walletManagerArgsForCall)]
	fake.walletManagerArgsForCall = append(fake.walletManagerArgsForCall, struct {
	}{})
	stub := fake.WalletManagerStub
	fakeReturns := fake.walletManagerReturns
	fake.recordInvocation("WalletManager", []interface{}{})
	fake.walletManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagementService) WalletManagerCallCount() int {
	fake.walletManagerMutex.RLock()
	defer fake.walletManagerMutex.RUnlock()
	return len(fake.walletManagerArgsForCall)
}

func (fake *TokenManagementService) WalletManagerCalls(stub func() *token.WalletManager) {
	fake.walletManagerMutex.Lock()
	defer fake.walletManagerMutex.Unlock()
	fake.WalletManagerStub = stub
}

func (fake *TokenManagementService) WalletManagerReturns(result1 *token.WalletManager) {
	fake.walletManagerMutex.Lock()
	defer fake.walletManagerMutex.Unlock()
	fake.WalletManagerStub = nil
	fake.walletManagerReturns = struct {
		result1 *token.WalletManager
	}{result1}
}

func (fake *TokenManagementService) WalletManagerReturnsOnCall(i int, result1 *token.WalletManager) {
	fake.walletManagerMutex.Lock()
	defer fake.walletManagerMutex.Unlock()
	fake.WalletManagerStub = nil
	if fake.walletManagerReturnsOnCall == nil {
		fake.walletManagerReturnsOnCall = make(map[int]struct {
			result1 *token.WalletManager
		})
	}
	fake.walletManagerReturnsOnCall[i] = struct {
		result1 *token.WalletManager
	}{result1}
}

func (fake *TokenManagementService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TokenManagementService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dep.TokenManagementService = new(TokenManagementService)
