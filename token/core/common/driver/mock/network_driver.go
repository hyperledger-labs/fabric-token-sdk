// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"
	"time"

	"github.com/hyperledger-labs/fabric-smart-client/platform/view/view"
	tokena "github.com/hyperledger-labs/fabric-token-sdk/token"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/token"
)

type Network struct {
	AddFinalityListenerStub        func(string, string, driver.FinalityListener) error
	addFinalityListenerMutex       sync.RWMutex
	addFinalityListenerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 driver.FinalityListener
	}
	addFinalityListenerReturns struct {
		result1 error
	}
	addFinalityListenerReturnsOnCall map[int]struct {
		result1 error
	}
	AreTokensSpentStub        func(context.Context, string, []*token.ID, []string) ([]bool, error)
	areTokensSpentMutex       sync.RWMutex
	areTokensSpentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []*token.ID
		arg4 []string
	}
	areTokensSpentReturns struct {
		result1 []bool
		result2 error
	}
	areTokensSpentReturnsOnCall map[int]struct {
		result1 []bool
		result2 error
	}
	BroadcastStub        func(context.Context, interface{}) error
	broadcastMutex       sync.RWMutex
	broadcastArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
	}
	broadcastReturns struct {
		result1 error
	}
	broadcastReturnsOnCall map[int]struct {
		result1 error
	}
	ChannelStub        func() string
	channelMutex       sync.RWMutex
	channelArgsForCall []struct {
	}
	channelReturns struct {
		result1 string
	}
	channelReturnsOnCall map[int]struct {
		result1 string
	}
	ComputeTxIDStub        func(*driver.TxID) string
	computeTxIDMutex       sync.RWMutex
	computeTxIDArgsForCall []struct {
		arg1 *driver.TxID
	}
	computeTxIDReturns struct {
		result1 string
	}
	computeTxIDReturnsOnCall map[int]struct {
		result1 string
	}
	ConnectStub        func(string) ([]tokena.ServiceOption, error)
	connectMutex       sync.RWMutex
	connectArgsForCall []struct {
		arg1 string
	}
	connectReturns struct {
		result1 []tokena.ServiceOption
		result2 error
	}
	connectReturnsOnCall map[int]struct {
		result1 []tokena.ServiceOption
		result2 error
	}
	FetchPublicParametersStub        func(string) ([]byte, error)
	fetchPublicParametersMutex       sync.RWMutex
	fetchPublicParametersArgsForCall []struct {
		arg1 string
	}
	fetchPublicParametersReturns struct {
		result1 []byte
		result2 error
	}
	fetchPublicParametersReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	LedgerStub        func() (driver.Ledger, error)
	ledgerMutex       sync.RWMutex
	ledgerArgsForCall []struct {
	}
	ledgerReturns struct {
		result1 driver.Ledger
		result2 error
	}
	ledgerReturnsOnCall map[int]struct {
		result1 driver.Ledger
		result2 error
	}
	LocalMembershipStub        func() driver.LocalMembership
	localMembershipMutex       sync.RWMutex
	localMembershipArgsForCall []struct {
	}
	localMembershipReturns struct {
		result1 driver.LocalMembership
	}
	localMembershipReturnsOnCall map[int]struct {
		result1 driver.LocalMembership
	}
	LookupTransferMetadataKeyStub        func(string, string, time.Duration) ([]byte, error)
	lookupTransferMetadataKeyMutex       sync.RWMutex
	lookupTransferMetadataKeyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 time.Duration
	}
	lookupTransferMetadataKeyReturns struct {
		result1 []byte
		result2 error
	}
	lookupTransferMetadataKeyReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	NewEnvelopeStub        func() driver.Envelope
	newEnvelopeMutex       sync.RWMutex
	newEnvelopeArgsForCall []struct {
	}
	newEnvelopeReturns struct {
		result1 driver.Envelope
	}
	newEnvelopeReturnsOnCall map[int]struct {
		result1 driver.Envelope
	}
	NormalizeStub        func(*tokena.ServiceOptions) (*tokena.ServiceOptions, error)
	normalizeMutex       sync.RWMutex
	normalizeArgsForCall []struct {
		arg1 *tokena.ServiceOptions
	}
	normalizeReturns struct {
		result1 *tokena.ServiceOptions
		result2 error
	}
	normalizeReturnsOnCall map[int]struct {
		result1 *tokena.ServiceOptions
		result2 error
	}
	QueryTokensStub        func(context.Context, string, []*token.ID) ([][]byte, error)
	queryTokensMutex       sync.RWMutex
	queryTokensArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []*token.ID
	}
	queryTokensReturns struct {
		result1 [][]byte
		result2 error
	}
	queryTokensReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 error
	}
	RequestApprovalStub        func(view.Context, *tokena.ManagementService, []byte, view.Identity, driver.TxID) (driver.Envelope, error)
	requestApprovalMutex       sync.RWMutex
	requestApprovalArgsForCall []struct {
		arg1 view.Context
		arg2 *tokena.ManagementService
		arg3 []byte
		arg4 view.Identity
		arg5 driver.TxID
	}
	requestApprovalReturns struct {
		result1 driver.Envelope
		result2 error
	}
	requestApprovalReturnsOnCall map[int]struct {
		result1 driver.Envelope
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Network) AddFinalityListener(arg1 string, arg2 string, arg3 driver.FinalityListener) error {
	fake.addFinalityListenerMutex.Lock()
	ret, specificReturn := fake.addFinalityListenerReturnsOnCall[len(fake.addFinalityListenerArgsForCall)]
	fake.addFinalityListenerArgsForCall = append(fake.addFinalityListenerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 driver.FinalityListener
	}{arg1, arg2, arg3})
	stub := fake.AddFinalityListenerStub
	fakeReturns := fake.addFinalityListenerReturns
	fake.recordInvocation("AddFinalityListener", []interface{}{arg1, arg2, arg3})
	fake.addFinalityListenerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) AddFinalityListenerCallCount() int {
	fake.addFinalityListenerMutex.RLock()
	defer fake.addFinalityListenerMutex.RUnlock()
	return len(fake.addFinalityListenerArgsForCall)
}

func (fake *Network) AddFinalityListenerCalls(stub func(string, string, driver.FinalityListener) error) {
	fake.addFinalityListenerMutex.Lock()
	defer fake.addFinalityListenerMutex.Unlock()
	fake.AddFinalityListenerStub = stub
}

func (fake *Network) AddFinalityListenerArgsForCall(i int) (string, string, driver.FinalityListener) {
	fake.addFinalityListenerMutex.RLock()
	defer fake.addFinalityListenerMutex.RUnlock()
	argsForCall := fake.addFinalityListenerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Network) AddFinalityListenerReturns(result1 error) {
	fake.addFinalityListenerMutex.Lock()
	defer fake.addFinalityListenerMutex.Unlock()
	fake.AddFinalityListenerStub = nil
	fake.addFinalityListenerReturns = struct {
		result1 error
	}{result1}
}

func (fake *Network) AddFinalityListenerReturnsOnCall(i int, result1 error) {
	fake.addFinalityListenerMutex.Lock()
	defer fake.addFinalityListenerMutex.Unlock()
	fake.AddFinalityListenerStub = nil
	if fake.addFinalityListenerReturnsOnCall == nil {
		fake.addFinalityListenerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFinalityListenerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Network) AreTokensSpent(arg1 context.Context, arg2 string, arg3 []*token.ID, arg4 []string) ([]bool, error) {
	var arg3Copy []*token.ID
	if arg3 != nil {
		arg3Copy = make([]*token.ID, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.areTokensSpentMutex.Lock()
	ret, specificReturn := fake.areTokensSpentReturnsOnCall[len(fake.areTokensSpentArgsForCall)]
	fake.areTokensSpentArgsForCall = append(fake.areTokensSpentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []*token.ID
		arg4 []string
	}{arg1, arg2, arg3Copy, arg4Copy})
	stub := fake.AreTokensSpentStub
	fakeReturns := fake.areTokensSpentReturns
	fake.recordInvocation("AreTokensSpent", []interface{}{arg1, arg2, arg3Copy, arg4Copy})
	fake.areTokensSpentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) AreTokensSpentCallCount() int {
	fake.areTokensSpentMutex.RLock()
	defer fake.areTokensSpentMutex.RUnlock()
	return len(fake.areTokensSpentArgsForCall)
}

func (fake *Network) AreTokensSpentCalls(stub func(context.Context, string, []*token.ID, []string) ([]bool, error)) {
	fake.areTokensSpentMutex.Lock()
	defer fake.areTokensSpentMutex.Unlock()
	fake.AreTokensSpentStub = stub
}

func (fake *Network) AreTokensSpentArgsForCall(i int) (context.Context, string, []*token.ID, []string) {
	fake.areTokensSpentMutex.RLock()
	defer fake.areTokensSpentMutex.RUnlock()
	argsForCall := fake.areTokensSpentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Network) AreTokensSpentReturns(result1 []bool, result2 error) {
	fake.areTokensSpentMutex.Lock()
	defer fake.areTokensSpentMutex.Unlock()
	fake.AreTokensSpentStub = nil
	fake.areTokensSpentReturns = struct {
		result1 []bool
		result2 error
	}{result1, result2}
}

func (fake *Network) AreTokensSpentReturnsOnCall(i int, result1 []bool, result2 error) {
	fake.areTokensSpentMutex.Lock()
	defer fake.areTokensSpentMutex.Unlock()
	fake.AreTokensSpentStub = nil
	if fake.areTokensSpentReturnsOnCall == nil {
		fake.areTokensSpentReturnsOnCall = make(map[int]struct {
			result1 []bool
			result2 error
		})
	}
	fake.areTokensSpentReturnsOnCall[i] = struct {
		result1 []bool
		result2 error
	}{result1, result2}
}

func (fake *Network) Broadcast(arg1 context.Context, arg2 interface{}) error {
	fake.broadcastMutex.Lock()
	ret, specificReturn := fake.broadcastReturnsOnCall[len(fake.broadcastArgsForCall)]
	fake.broadcastArgsForCall = append(fake.broadcastArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.BroadcastStub
	fakeReturns := fake.broadcastReturns
	fake.recordInvocation("Broadcast", []interface{}{arg1, arg2})
	fake.broadcastMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) BroadcastCallCount() int {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	return len(fake.broadcastArgsForCall)
}

func (fake *Network) BroadcastCalls(stub func(context.Context, interface{}) error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = stub
}

func (fake *Network) BroadcastArgsForCall(i int) (context.Context, interface{}) {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	argsForCall := fake.broadcastArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Network) BroadcastReturns(result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	fake.broadcastReturns = struct {
		result1 error
	}{result1}
}

func (fake *Network) BroadcastReturnsOnCall(i int, result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	if fake.broadcastReturnsOnCall == nil {
		fake.broadcastReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.broadcastReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Network) Channel() string {
	fake.channelMutex.Lock()
	ret, specificReturn := fake.channelReturnsOnCall[len(fake.channelArgsForCall)]
	fake.channelArgsForCall = append(fake.channelArgsForCall, struct {
	}{})
	stub := fake.ChannelStub
	fakeReturns := fake.channelReturns
	fake.recordInvocation("Channel", []interface{}{})
	fake.channelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) ChannelCallCount() int {
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	return len(fake.channelArgsForCall)
}

func (fake *Network) ChannelCalls(stub func() string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = stub
}

func (fake *Network) ChannelReturns(result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	fake.channelReturns = struct {
		result1 string
	}{result1}
}

func (fake *Network) ChannelReturnsOnCall(i int, result1 string) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	if fake.channelReturnsOnCall == nil {
		fake.channelReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.channelReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Network) ComputeTxID(arg1 *driver.TxID) string {
	fake.computeTxIDMutex.Lock()
	ret, specificReturn := fake.computeTxIDReturnsOnCall[len(fake.computeTxIDArgsForCall)]
	fake.computeTxIDArgsForCall = append(fake.computeTxIDArgsForCall, struct {
		arg1 *driver.TxID
	}{arg1})
	stub := fake.ComputeTxIDStub
	fakeReturns := fake.computeTxIDReturns
	fake.recordInvocation("ComputeTxID", []interface{}{arg1})
	fake.computeTxIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) ComputeTxIDCallCount() int {
	fake.computeTxIDMutex.RLock()
	defer fake.computeTxIDMutex.RUnlock()
	return len(fake.computeTxIDArgsForCall)
}

func (fake *Network) ComputeTxIDCalls(stub func(*driver.TxID) string) {
	fake.computeTxIDMutex.Lock()
	defer fake.computeTxIDMutex.Unlock()
	fake.ComputeTxIDStub = stub
}

func (fake *Network) ComputeTxIDArgsForCall(i int) *driver.TxID {
	fake.computeTxIDMutex.RLock()
	defer fake.computeTxIDMutex.RUnlock()
	argsForCall := fake.computeTxIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Network) ComputeTxIDReturns(result1 string) {
	fake.computeTxIDMutex.Lock()
	defer fake.computeTxIDMutex.Unlock()
	fake.ComputeTxIDStub = nil
	fake.computeTxIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *Network) ComputeTxIDReturnsOnCall(i int, result1 string) {
	fake.computeTxIDMutex.Lock()
	defer fake.computeTxIDMutex.Unlock()
	fake.ComputeTxIDStub = nil
	if fake.computeTxIDReturnsOnCall == nil {
		fake.computeTxIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.computeTxIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Network) Connect(arg1 string) ([]tokena.ServiceOption, error) {
	fake.connectMutex.Lock()
	ret, specificReturn := fake.connectReturnsOnCall[len(fake.connectArgsForCall)]
	fake.connectArgsForCall = append(fake.connectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConnectStub
	fakeReturns := fake.connectReturns
	fake.recordInvocation("Connect", []interface{}{arg1})
	fake.connectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) ConnectCallCount() int {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return len(fake.connectArgsForCall)
}

func (fake *Network) ConnectCalls(stub func(string) ([]tokena.ServiceOption, error)) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = stub
}

func (fake *Network) ConnectArgsForCall(i int) string {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	argsForCall := fake.connectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Network) ConnectReturns(result1 []tokena.ServiceOption, result2 error) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = nil
	fake.connectReturns = struct {
		result1 []tokena.ServiceOption
		result2 error
	}{result1, result2}
}

func (fake *Network) ConnectReturnsOnCall(i int, result1 []tokena.ServiceOption, result2 error) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = nil
	if fake.connectReturnsOnCall == nil {
		fake.connectReturnsOnCall = make(map[int]struct {
			result1 []tokena.ServiceOption
			result2 error
		})
	}
	fake.connectReturnsOnCall[i] = struct {
		result1 []tokena.ServiceOption
		result2 error
	}{result1, result2}
}

func (fake *Network) FetchPublicParameters(arg1 string) ([]byte, error) {
	fake.fetchPublicParametersMutex.Lock()
	ret, specificReturn := fake.fetchPublicParametersReturnsOnCall[len(fake.fetchPublicParametersArgsForCall)]
	fake.fetchPublicParametersArgsForCall = append(fake.fetchPublicParametersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FetchPublicParametersStub
	fakeReturns := fake.fetchPublicParametersReturns
	fake.recordInvocation("FetchPublicParameters", []interface{}{arg1})
	fake.fetchPublicParametersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) FetchPublicParametersCallCount() int {
	fake.fetchPublicParametersMutex.RLock()
	defer fake.fetchPublicParametersMutex.RUnlock()
	return len(fake.fetchPublicParametersArgsForCall)
}

func (fake *Network) FetchPublicParametersCalls(stub func(string) ([]byte, error)) {
	fake.fetchPublicParametersMutex.Lock()
	defer fake.fetchPublicParametersMutex.Unlock()
	fake.FetchPublicParametersStub = stub
}

func (fake *Network) FetchPublicParametersArgsForCall(i int) string {
	fake.fetchPublicParametersMutex.RLock()
	defer fake.fetchPublicParametersMutex.RUnlock()
	argsForCall := fake.fetchPublicParametersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Network) FetchPublicParametersReturns(result1 []byte, result2 error) {
	fake.fetchPublicParametersMutex.Lock()
	defer fake.fetchPublicParametersMutex.Unlock()
	fake.FetchPublicParametersStub = nil
	fake.fetchPublicParametersReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Network) FetchPublicParametersReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.fetchPublicParametersMutex.Lock()
	defer fake.fetchPublicParametersMutex.Unlock()
	fake.FetchPublicParametersStub = nil
	if fake.fetchPublicParametersReturnsOnCall == nil {
		fake.fetchPublicParametersReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.fetchPublicParametersReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Network) Ledger() (driver.Ledger, error) {
	fake.ledgerMutex.Lock()
	ret, specificReturn := fake.ledgerReturnsOnCall[len(fake.ledgerArgsForCall)]
	fake.ledgerArgsForCall = append(fake.ledgerArgsForCall, struct {
	}{})
	stub := fake.LedgerStub
	fakeReturns := fake.ledgerReturns
	fake.recordInvocation("Ledger", []interface{}{})
	fake.ledgerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) LedgerCallCount() int {
	fake.ledgerMutex.RLock()
	defer fake.ledgerMutex.RUnlock()
	return len(fake.ledgerArgsForCall)
}

func (fake *Network) LedgerCalls(stub func() (driver.Ledger, error)) {
	fake.ledgerMutex.Lock()
	defer fake.ledgerMutex.Unlock()
	fake.LedgerStub = stub
}

func (fake *Network) LedgerReturns(result1 driver.Ledger, result2 error) {
	fake.ledgerMutex.Lock()
	defer fake.ledgerMutex.Unlock()
	fake.LedgerStub = nil
	fake.ledgerReturns = struct {
		result1 driver.Ledger
		result2 error
	}{result1, result2}
}

func (fake *Network) LedgerReturnsOnCall(i int, result1 driver.Ledger, result2 error) {
	fake.ledgerMutex.Lock()
	defer fake.ledgerMutex.Unlock()
	fake.LedgerStub = nil
	if fake.ledgerReturnsOnCall == nil {
		fake.ledgerReturnsOnCall = make(map[int]struct {
			result1 driver.Ledger
			result2 error
		})
	}
	fake.ledgerReturnsOnCall[i] = struct {
		result1 driver.Ledger
		result2 error
	}{result1, result2}
}

func (fake *Network) LocalMembership() driver.LocalMembership {
	fake.localMembershipMutex.Lock()
	ret, specificReturn := fake.localMembershipReturnsOnCall[len(fake.localMembershipArgsForCall)]
	fake.localMembershipArgsForCall = append(fake.localMembershipArgsForCall, struct {
	}{})
	stub := fake.LocalMembershipStub
	fakeReturns := fake.localMembershipReturns
	fake.recordInvocation("LocalMembership", []interface{}{})
	fake.localMembershipMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) LocalMembershipCallCount() int {
	fake.localMembershipMutex.RLock()
	defer fake.localMembershipMutex.RUnlock()
	return len(fake.localMembershipArgsForCall)
}

func (fake *Network) LocalMembershipCalls(stub func() driver.LocalMembership) {
	fake.localMembershipMutex.Lock()
	defer fake.localMembershipMutex.Unlock()
	fake.LocalMembershipStub = stub
}

func (fake *Network) LocalMembershipReturns(result1 driver.LocalMembership) {
	fake.localMembershipMutex.Lock()
	defer fake.localMembershipMutex.Unlock()
	fake.LocalMembershipStub = nil
	fake.localMembershipReturns = struct {
		result1 driver.LocalMembership
	}{result1}
}

func (fake *Network) LocalMembershipReturnsOnCall(i int, result1 driver.LocalMembership) {
	fake.localMembershipMutex.Lock()
	defer fake.localMembershipMutex.Unlock()
	fake.LocalMembershipStub = nil
	if fake.localMembershipReturnsOnCall == nil {
		fake.localMembershipReturnsOnCall = make(map[int]struct {
			result1 driver.LocalMembership
		})
	}
	fake.localMembershipReturnsOnCall[i] = struct {
		result1 driver.LocalMembership
	}{result1}
}

func (fake *Network) LookupTransferMetadataKey(arg1 string, arg2 string, arg3 time.Duration) ([]byte, error) {
	fake.lookupTransferMetadataKeyMutex.Lock()
	ret, specificReturn := fake.lookupTransferMetadataKeyReturnsOnCall[len(fake.lookupTransferMetadataKeyArgsForCall)]
	fake.lookupTransferMetadataKeyArgsForCall = append(fake.lookupTransferMetadataKeyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	stub := fake.LookupTransferMetadataKeyStub
	fakeReturns := fake.lookupTransferMetadataKeyReturns
	fake.recordInvocation("LookupTransferMetadataKey", []interface{}{arg1, arg2, arg3})
	fake.lookupTransferMetadataKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) LookupTransferMetadataKeyCallCount() int {
	fake.lookupTransferMetadataKeyMutex.RLock()
	defer fake.lookupTransferMetadataKeyMutex.RUnlock()
	return len(fake.lookupTransferMetadataKeyArgsForCall)
}

func (fake *Network) LookupTransferMetadataKeyCalls(stub func(string, string, time.Duration) ([]byte, error)) {
	fake.lookupTransferMetadataKeyMutex.Lock()
	defer fake.lookupTransferMetadataKeyMutex.Unlock()
	fake.LookupTransferMetadataKeyStub = stub
}

func (fake *Network) LookupTransferMetadataKeyArgsForCall(i int) (string, string, time.Duration) {
	fake.lookupTransferMetadataKeyMutex.RLock()
	defer fake.lookupTransferMetadataKeyMutex.RUnlock()
	argsForCall := fake.lookupTransferMetadataKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Network) LookupTransferMetadataKeyReturns(result1 []byte, result2 error) {
	fake.lookupTransferMetadataKeyMutex.Lock()
	defer fake.lookupTransferMetadataKeyMutex.Unlock()
	fake.LookupTransferMetadataKeyStub = nil
	fake.lookupTransferMetadataKeyReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Network) LookupTransferMetadataKeyReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.lookupTransferMetadataKeyMutex.Lock()
	defer fake.lookupTransferMetadataKeyMutex.Unlock()
	fake.LookupTransferMetadataKeyStub = nil
	if fake.lookupTransferMetadataKeyReturnsOnCall == nil {
		fake.lookupTransferMetadataKeyReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.lookupTransferMetadataKeyReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Network) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *Network) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *Network) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *Network) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Network) NewEnvelope() driver.Envelope {
	fake.newEnvelopeMutex.Lock()
	ret, specificReturn := fake.newEnvelopeReturnsOnCall[len(fake.newEnvelopeArgsForCall)]
	fake.newEnvelopeArgsForCall = append(fake.newEnvelopeArgsForCall, struct {
	}{})
	stub := fake.NewEnvelopeStub
	fakeReturns := fake.newEnvelopeReturns
	fake.recordInvocation("NewEnvelope", []interface{}{})
	fake.newEnvelopeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Network) NewEnvelopeCallCount() int {
	fake.newEnvelopeMutex.RLock()
	defer fake.newEnvelopeMutex.RUnlock()
	return len(fake.newEnvelopeArgsForCall)
}

func (fake *Network) NewEnvelopeCalls(stub func() driver.Envelope) {
	fake.newEnvelopeMutex.Lock()
	defer fake.newEnvelopeMutex.Unlock()
	fake.NewEnvelopeStub = stub
}

func (fake *Network) NewEnvelopeReturns(result1 driver.Envelope) {
	fake.newEnvelopeMutex.Lock()
	defer fake.newEnvelopeMutex.Unlock()
	fake.NewEnvelopeStub = nil
	fake.newEnvelopeReturns = struct {
		result1 driver.Envelope
	}{result1}
}

func (fake *Network) NewEnvelopeReturnsOnCall(i int, result1 driver.Envelope) {
	fake.newEnvelopeMutex.Lock()
	defer fake.newEnvelopeMutex.Unlock()
	fake.NewEnvelopeStub = nil
	if fake.newEnvelopeReturnsOnCall == nil {
		fake.newEnvelopeReturnsOnCall = make(map[int]struct {
			result1 driver.Envelope
		})
	}
	fake.newEnvelopeReturnsOnCall[i] = struct {
		result1 driver.Envelope
	}{result1}
}

func (fake *Network) Normalize(arg1 *tokena.ServiceOptions) (*tokena.ServiceOptions, error) {
	fake.normalizeMutex.Lock()
	ret, specificReturn := fake.normalizeReturnsOnCall[len(fake.normalizeArgsForCall)]
	fake.normalizeArgsForCall = append(fake.normalizeArgsForCall, struct {
		arg1 *tokena.ServiceOptions
	}{arg1})
	stub := fake.NormalizeStub
	fakeReturns := fake.normalizeReturns
	fake.recordInvocation("Normalize", []interface{}{arg1})
	fake.normalizeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) NormalizeCallCount() int {
	fake.normalizeMutex.RLock()
	defer fake.normalizeMutex.RUnlock()
	return len(fake.normalizeArgsForCall)
}

func (fake *Network) NormalizeCalls(stub func(*tokena.ServiceOptions) (*tokena.ServiceOptions, error)) {
	fake.normalizeMutex.Lock()
	defer fake.normalizeMutex.Unlock()
	fake.NormalizeStub = stub
}

func (fake *Network) NormalizeArgsForCall(i int) *tokena.ServiceOptions {
	fake.normalizeMutex.RLock()
	defer fake.normalizeMutex.RUnlock()
	argsForCall := fake.normalizeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Network) NormalizeReturns(result1 *tokena.ServiceOptions, result2 error) {
	fake.normalizeMutex.Lock()
	defer fake.normalizeMutex.Unlock()
	fake.NormalizeStub = nil
	fake.normalizeReturns = struct {
		result1 *tokena.ServiceOptions
		result2 error
	}{result1, result2}
}

func (fake *Network) NormalizeReturnsOnCall(i int, result1 *tokena.ServiceOptions, result2 error) {
	fake.normalizeMutex.Lock()
	defer fake.normalizeMutex.Unlock()
	fake.NormalizeStub = nil
	if fake.normalizeReturnsOnCall == nil {
		fake.normalizeReturnsOnCall = make(map[int]struct {
			result1 *tokena.ServiceOptions
			result2 error
		})
	}
	fake.normalizeReturnsOnCall[i] = struct {
		result1 *tokena.ServiceOptions
		result2 error
	}{result1, result2}
}

func (fake *Network) QueryTokens(arg1 context.Context, arg2 string, arg3 []*token.ID) ([][]byte, error) {
	var arg3Copy []*token.ID
	if arg3 != nil {
		arg3Copy = make([]*token.ID, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.queryTokensMutex.Lock()
	ret, specificReturn := fake.queryTokensReturnsOnCall[len(fake.queryTokensArgsForCall)]
	fake.queryTokensArgsForCall = append(fake.queryTokensArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []*token.ID
	}{arg1, arg2, arg3Copy})
	stub := fake.QueryTokensStub
	fakeReturns := fake.queryTokensReturns
	fake.recordInvocation("QueryTokens", []interface{}{arg1, arg2, arg3Copy})
	fake.queryTokensMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) QueryTokensCallCount() int {
	fake.queryTokensMutex.RLock()
	defer fake.queryTokensMutex.RUnlock()
	return len(fake.queryTokensArgsForCall)
}

func (fake *Network) QueryTokensCalls(stub func(context.Context, string, []*token.ID) ([][]byte, error)) {
	fake.queryTokensMutex.Lock()
	defer fake.queryTokensMutex.Unlock()
	fake.QueryTokensStub = stub
}

func (fake *Network) QueryTokensArgsForCall(i int) (context.Context, string, []*token.ID) {
	fake.queryTokensMutex.RLock()
	defer fake.queryTokensMutex.RUnlock()
	argsForCall := fake.queryTokensArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Network) QueryTokensReturns(result1 [][]byte, result2 error) {
	fake.queryTokensMutex.Lock()
	defer fake.queryTokensMutex.Unlock()
	fake.QueryTokensStub = nil
	fake.queryTokensReturns = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *Network) QueryTokensReturnsOnCall(i int, result1 [][]byte, result2 error) {
	fake.queryTokensMutex.Lock()
	defer fake.queryTokensMutex.Unlock()
	fake.QueryTokensStub = nil
	if fake.queryTokensReturnsOnCall == nil {
		fake.queryTokensReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 error
		})
	}
	fake.queryTokensReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *Network) RequestApproval(arg1 view.Context, arg2 *tokena.ManagementService, arg3 []byte, arg4 view.Identity, arg5 driver.TxID) (driver.Envelope, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.requestApprovalMutex.Lock()
	ret, specificReturn := fake.requestApprovalReturnsOnCall[len(fake.requestApprovalArgsForCall)]
	fake.requestApprovalArgsForCall = append(fake.requestApprovalArgsForCall, struct {
		arg1 view.Context
		arg2 *tokena.ManagementService
		arg3 []byte
		arg4 view.Identity
		arg5 driver.TxID
	}{arg1, arg2, arg3Copy, arg4, arg5})
	stub := fake.RequestApprovalStub
	fakeReturns := fake.requestApprovalReturns
	fake.recordInvocation("RequestApproval", []interface{}{arg1, arg2, arg3Copy, arg4, arg5})
	fake.requestApprovalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Network) RequestApprovalCallCount() int {
	fake.requestApprovalMutex.RLock()
	defer fake.requestApprovalMutex.RUnlock()
	return len(fake.requestApprovalArgsForCall)
}

func (fake *Network) RequestApprovalCalls(stub func(view.Context, *tokena.ManagementService, []byte, view.Identity, driver.TxID) (driver.Envelope, error)) {
	fake.requestApprovalMutex.Lock()
	defer fake.requestApprovalMutex.Unlock()
	fake.RequestApprovalStub = stub
}

func (fake *Network) RequestApprovalArgsForCall(i int) (view.Context, *tokena.ManagementService, []byte, view.Identity, driver.TxID) {
	fake.requestApprovalMutex.RLock()
	defer fake.requestApprovalMutex.RUnlock()
	argsForCall := fake.requestApprovalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *Network) RequestApprovalReturns(result1 driver.Envelope, result2 error) {
	fake.requestApprovalMutex.Lock()
	defer fake.requestApprovalMutex.Unlock()
	fake.RequestApprovalStub = nil
	fake.requestApprovalReturns = struct {
		result1 driver.Envelope
		result2 error
	}{result1, result2}
}

func (fake *Network) RequestApprovalReturnsOnCall(i int, result1 driver.Envelope, result2 error) {
	fake.requestApprovalMutex.Lock()
	defer fake.requestApprovalMutex.Unlock()
	fake.RequestApprovalStub = nil
	if fake.requestApprovalReturnsOnCall == nil {
		fake.requestApprovalReturnsOnCall = make(map[int]struct {
			result1 driver.Envelope
			result2 error
		})
	}
	fake.requestApprovalReturnsOnCall[i] = struct {
		result1 driver.Envelope
		result2 error
	}{result1, result2}
}

func (fake *Network) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Network) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.Network = new(Network)
