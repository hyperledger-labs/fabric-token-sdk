/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package benchmark

import (
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/IBM/idemix/bccsp/types"
	math "github.com/IBM/mathlib"
	"github.com/hyperledger-labs/fabric-smart-client/pkg/utils/errors"
	"github.com/hyperledger-labs/fabric-smart-client/platform/fabric/core/generic/msp/x509"
	math2 "github.com/hyperledger-labs/fabric-token-sdk/token/core/common/crypto/math"
	"github.com/hyperledger-labs/fabric-token-sdk/token/core/zkatdlog/nogh/v1/setup"
	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/identity"
	idemix2 "github.com/hyperledger-labs/fabric-token-sdk/token/services/identity/idemix"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/identity/idemix/crypto"
	ix509 "github.com/hyperledger-labs/fabric-token-sdk/token/services/identity/x509"
	crypto2 "github.com/hyperledger-labs/fabric-token-sdk/token/services/identity/x509/crypto"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/storage/db/kvs"
)

type SetupConfigurationSer struct {
	PP      string `json:"pp"` // Encoded in base64
	Bits    uint64 `json:"bits"`
	CurveID int    `json:"curveID"`
}

// SetupConfiguration holds the prepared public parameters and related
// identities/signers used by a single benchmark configuration.
//
// Fields:
//   - PP: public parameters produced by the protocol setup.
//   - OwnerIdentity: identity information for the owner used in the benchmark.
//   - AuditorSigner / IssuerSigner: ephemeral ECDSA signers for the auditor and issuer.
type SetupConfiguration struct {
	PP            *setup.PublicParams
	OwnerIdentity *OwnerIdentity
	AuditorSigner *Signer
	IssuerSigner  *Signer
	Bits          uint64
	CurveID       math.CurveID
}

// SetupConfigurations contains a set of named benchmark configurations.
// The map key is generated by the key(bits, curveID) helper.
type SetupConfigurations struct {
	Configurations map[string]*SetupConfiguration
}

// NewSetupConfigurations loads test data from the given idemixTestdataPath and
// builds setup configurations for each combination of the provided bit sizes
// and curveIDs. It returns a container mapping keys to configurations or an
// error if any setup step fails.
func NewSetupConfigurations(idemixTestdataPath string, bits []uint64, curveIDs []math.CurveID) (*SetupConfigurations, error) {
	configurations := map[string]*SetupConfiguration{}
	for _, curveID := range curveIDs {
		var ipk []byte
		var err error
		var oID *OwnerIdentity
		switch curveID {
		case math.BN254:
			idemixPath := filepath.Join(idemixTestdataPath, "bn254", "idemix")
			ipk, err = os.ReadFile(filepath.Join(idemixPath, "msp", "IssuerPublicKey"))
			if err != nil {
				return nil, err
			}
			oID, err = loadOwnerIdentity(context.Background(), idemixPath, curveID)
			if err != nil {
				return nil, err
			}
		case math.BLS12_381_BBS_GURVY:
			fallthrough
		case math2.BLS12_381_BBS_GURVY_FAST_RNG:
			idemixPath := filepath.Join(idemixTestdataPath, "bls12_381_bbs", "idemix")
			ipk, err = os.ReadFile(filepath.Join(idemixPath, "msp", "IssuerPublicKey"))
			if err != nil {
				return nil, err
			}
			oID, err = loadOwnerIdentity(context.Background(), idemixPath, curveID)
			if err != nil {
				return nil, err
			}
		default:
			return nil, errors.Errorf("curveID [%d] not found", curveID)
		}

		auditorSigner, err := PrepareECDSASigner()
		if err != nil {
			return nil, err
		}
		issuerSigner, err := NewECDSASigner()
		if err != nil {
			return nil, err
		}

		for _, bit := range bits {
			pp, err := setup.Setup(bit, ipk, curveID)
			if err != nil {
				return nil, err
			}
			issuerID, err := issuerSigner.Serialize()
			if err != nil {
				return nil, err
			}
			pp.AddIssuer(issuerID)
			auditorID, err := auditorSigner.Serialize()
			if err != nil {
				return nil, err
			}
			pp.AddAuditor(auditorID)
			configurations[key(bit, curveID)] = &SetupConfiguration{
				Bits:          bit,
				CurveID:       curveID,
				PP:            pp,
				OwnerIdentity: oID,
				AuditorSigner: auditorSigner,
				IssuerSigner:  issuerSigner,
			}
		}
	}

	return &SetupConfigurations{
		Configurations: configurations,
	}, nil
}

// GetPublicParams returns the public parameters associated with the given
// bit size and curveID. If no configuration exists for the provided key an
// error is returned.
func (c *SetupConfigurations) GetPublicParams(bits uint64, curveID math.CurveID) (*setup.PublicParams, error) {
	configuration, ok := c.Configurations[key(bits, curveID)]
	if !ok {
		return nil, fmt.Errorf("configuration not found")
	}

	return configuration.PP, nil
}

// GetSetupConfiguration returns the full SetupConfiguration for the provided
// bit size and curveID. It returns an error if the configuration is missing.
func (c *SetupConfigurations) GetSetupConfiguration(bits uint64, curveID math.CurveID) (*SetupConfiguration, error) {
	configuration, ok := c.Configurations[key(bits, curveID)]
	if !ok {
		return nil, fmt.Errorf("configuration not found")
	}

	return configuration, nil
}

func key(bits uint64, curveID math.CurveID) string {
	return fmt.Sprintf("%d-%s", bits, math2.CurveIDToString(curveID))
}

// SaveTo writes each configuration to disk under the provided directory.
// For each entry in the Configurations map a folder with the map key is
// created. Inside that folder a file named `pp.json` is written. The file
// contains a JSON document with the base64-encoded serialized public
// parameters and the metadata bits and curve_id.
func (c *SetupConfigurations) SaveTo(dir string) error {
	if c == nil {
		return errors.Errorf("nil SetupConfigurations")
	}
	// Ensure target base directory exists
	if err := os.MkdirAll(dir, 0750); err != nil {
		return errors.Wrapf(err, "failed creating base dir [%s]")
	}

	for k, cfg := range c.Configurations {
		if strings.ContainsAny(k, "/\\") {
			return errors.Errorf("invalid configuration key: %s", k)
		}
		if cfg == nil {
			return errors.Errorf("nil configuration for key: %s", k)
		}
		if cfg.PP == nil {
			return errors.Errorf("nil public parameters for key: %s", k)
		}

		// serialize public params
		ppBytes, err := cfg.PP.Serialize()
		if err != nil {
			return errors.WithMessagef(err, "failed serializing public params for key: %s", k)
		}

		// prepare JSON payload
		payload := &SetupConfigurationSer{
			PP:      base64.StdEncoding.EncodeToString(ppBytes),
			Bits:    cfg.Bits,
			CurveID: int(cfg.CurveID),
		}
		data, err := json.MarshalIndent(payload, "", "  ")
		if err != nil {
			return errors.Wrap(err, "failed marshalling json payload")
		}

		// create target directory and write
		targetDir := filepath.Join(dir, filepath.Base(k))
		if err := os.MkdirAll(targetDir, 0750); err != nil {
			return errors.WithMessagef(err, "failed creating dir for key: %s", k)
		}

		// Write params.txt containing base64(ppBytes)
		paramsEncoded := payload.PP
		finalParamsPath := filepath.Join(targetDir, "params.txt")
		if err := os.WriteFile(finalParamsPath, []byte(paramsEncoded), 0o644); err != nil {
			return errors.WithMessagef(err, "failed writing params file for key: %s", k)
		}

		// Write pp.json file
		finalPath := filepath.Join(targetDir, "pp.json")
		if err := os.WriteFile(finalPath, data, 0o644); err != nil {
			return errors.WithMessagef(err, "failed writing pp.json for key: %s", k)
		}
	}

	return nil
}

// OwnerIdentity represents the owner identity used by benchmarks. It
// contains the wrapped identity, the audit information and a signing
// identity capable of producing proofs for the owner.
type OwnerIdentity struct {
	ID        driver.Identity
	AuditInfo *crypto.AuditInfo
	Signer    driver.SigningIdentity
}

func loadOwnerIdentity(ctx context.Context, dir string, curveID math.CurveID) (*OwnerIdentity, error) {
	backend, err := kvs.NewInMemory()
	if err != nil {
		return nil, err
	}
	config, err := crypto.NewConfig(dir)
	if err != nil {
		return nil, err
	}
	keyStore, err := crypto.NewKeyStore(curveID, kvs.Keystore(backend))
	if err != nil {
		return nil, err
	}
	cryptoProvider, err := crypto.NewBCCSP(keyStore, curveID)
	if err != nil {
		return nil, err
	}
	p, err := idemix2.NewKeyManager(config, types.EidNymRhNym, cryptoProvider)
	if err != nil {
		return nil, err
	}

	identityDescriptor, err := p.Identity(ctx, nil)
	if err != nil {
		return nil, err
	}
	id := identityDescriptor.Identity
	audit := identityDescriptor.AuditInfo

	auditInfo, err := p.DeserializeAuditInfo(ctx, audit)
	if err != nil {
		return nil, err
	}
	err = auditInfo.Match(ctx, id)
	if err != nil {
		return nil, err
	}

	signer, err := p.DeserializeSigningIdentity(ctx, id)
	if err != nil {
		return nil, err
	}

	id, err = identity.WrapWithType(idemix2.IdentityType, id)
	if err != nil {
		return nil, err
	}

	return &OwnerIdentity{
		ID:        id,
		AuditInfo: auditInfo,
		Signer:    signer,
	}, nil
}

// PrepareECDSASigner creates and returns a new ephemeral ECDSA-based Signer.
// This function is a small helper that currently delegates to NewECDSASigner.
func PrepareECDSASigner() (*Signer, error) {
	signer, err := NewECDSASigner()
	if err != nil {
		return nil, err
	}

	return signer, nil
}

// Signer wraps an ECDSA private key and a driver.Signer implementation. It
// is used to produce signatures and to serialize the corresponding public
// key as an identity when wiring up public parameters for benchmarks.
type Signer struct {
	SK     *ecdsa.PrivateKey
	Signer driver.Signer
}

// NewECDSASigner generates a new ephemeral P-256 ECDSA key pair and returns
// a Signer that uses that key. The private key is kept in-memory only.
func NewECDSASigner() (*Signer, error) {
	// Create ephemeral key and store it in the context
	sk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, err
	}

	return &Signer{SK: sk, Signer: crypto2.NewEcdsaSigner(sk)}, nil
}

// Sign signs the provided message using the underlying driver.Signer.
func (d *Signer) Sign(message []byte) ([]byte, error) {
	return d.Signer.Sign(message)
}

// Serialize returns a wrapped x509 identity containing the signer's public
// key encoded as PEM. The returned bytes are ready to be used as an identity
// payload by components that accept ix509 identities.
func (d *Signer) Serialize() ([]byte, error) {
	pkRaw, err := x509.PemEncodeKey(&d.SK.PublicKey)
	if err != nil {
		return nil, errors.Wrap(err, "failed marshalling public key")
	}

	wrap, err := identity.WrapWithType(ix509.IdentityType, pkRaw)
	if err != nil {
		return nil, errors.Wrap(err, "failed wrapping identity")
	}

	return wrap, nil
}
