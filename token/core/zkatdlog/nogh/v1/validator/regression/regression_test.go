/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package regression_test

import (
	"embed"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"path/filepath"
	"testing"

	"github.com/hyperledger-labs/fabric-token-sdk/token"
	"github.com/hyperledger-labs/fabric-token-sdk/token/core"
	fabtoken "github.com/hyperledger-labs/fabric-token-sdk/token/core/fabtoken/v1/driver"
	dlog "github.com/hyperledger-labs/fabric-token-sdk/token/core/zkatdlog/nogh/v1/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/services/network/fabric/tcc"
	tk "github.com/hyperledger-labs/fabric-token-sdk/token/token"
	"github.com/stretchr/testify/require"
)

//go:embed testdata
var testDataFS embed.FS

// TestRegression runs previously recorded regression test vectors contained in the
// `testdata/<variant>` directories. Each directory contains a `params.txt` and a
// sequence of JSON files under `transfers/output.<n>.json` representing serialized
// token requests and their associated txids. The test unmarshals each recorded
// request and verifies it against the validator to ensure the library remains
// backwards compatible.
//
// Notes:
//   - The testdata used here is generated by `testdata/generator`. If you need to
//     re-generate vectors for a new setup, run that generator and commit the
//     produced artifacts to the corresponding `testdata/...` directory.
//   - The test expects 64 transfer vectors (output.0..output.63). Update the loop
//     range in `testRegression` if you add or remove vectors.
func TestRegression(t *testing.T) {
	t.Parallel()
	for _, action := range []string{"transfers", "issues", "redeems", "swaps"} {
		testRegressionParallel(t, "testdata/32-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i1_o1", action))
		testRegressionParallel(t, "testdata/32-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i1_o2", action))
		testRegressionParallel(t, "testdata/32-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i2_o1", action))
		testRegressionParallel(t, "testdata/32-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i2_o2", action))

		testRegressionParallel(t, "testdata/64-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i1_o1", action))
		testRegressionParallel(t, "testdata/64-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i1_o2", action))
		testRegressionParallel(t, "testdata/64-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i2_o1", action))
		testRegressionParallel(t, "testdata/64-BLS12_381_BBS_GURVY", fmt.Sprintf("%s_i2_o2", action))

		testRegressionParallel(t, "testdata/32-BN254", fmt.Sprintf("%s_i1_o1", action))
		testRegressionParallel(t, "testdata/32-BN254", fmt.Sprintf("%s_i1_o2", action))
		testRegressionParallel(t, "testdata/32-BN254", fmt.Sprintf("%s_i2_o1", action))
		testRegressionParallel(t, "testdata/32-BN254", fmt.Sprintf("%s_i2_o2", action))

		testRegressionParallel(t, "testdata/64-BN254", fmt.Sprintf("%s_i1_o1", action))
		testRegressionParallel(t, "testdata/64-BN254", fmt.Sprintf("%s_i1_o2", action))
		testRegressionParallel(t, "testdata/64-BN254", fmt.Sprintf("%s_i2_o1", action))
		testRegressionParallel(t, "testdata/64-BN254", fmt.Sprintf("%s_i2_o2", action))
	}
}

func testRegressionParallel(t *testing.T, rootDir, subFolder string) {
	t.Helper()
	t.Run(fmt.Sprintf("%s-%s", rootDir, subFolder), func(t *testing.T) {
		t.Parallel()
		testRegression(t, rootDir, subFolder)
	})
}

func testRegression(t *testing.T, rootDir, subFolder string) {
	t.Helper()
	t.Logf("regression test for [%s:%s]", rootDir, subFolder)
	paramsData, err := testDataFS.ReadFile(filepath.Join(rootDir, "params.txt"))
	require.NoError(t, err)

	ppRaw, err := base64.StdEncoding.DecodeString(string(paramsData))
	require.NoError(t, err)

	_, tokenValidator, err := tokenServicesFactory(ppRaw)
	require.NoError(t, err)

	var tokenData struct {
		ReqRaw []byte `json:"req_raw"`
		TXID   string `json:"txid"`
	}
	for i := range 64 {
		jsonData, err := testDataFS.ReadFile(
			filepath.Join(
				rootDir,
				subFolder,
				fmt.Sprintf("output.%d.json", i),
			),
		)
		require.NoError(t, err)
		err = json.Unmarshal(jsonData, &tokenData)
		require.NoError(t, err)
		_, _, err = tokenValidator.UnmarshallAndVerifyWithMetadata(
			t.Context(),
			&fakeLedger{},
			token.RequestAnchor(tokenData.TXID),
			tokenData.ReqRaw,
		)
		require.NoError(t, err)
	}
}

func tokenServicesFactory(bytes []byte) (tcc.PublicParameters, tcc.Validator, error) {
	is := core.NewPPManagerFactoryService(fabtoken.NewPPMFactory(), dlog.NewPPMFactory())

	ppm, err := is.PublicParametersFromBytes(bytes)
	if err != nil {
		return nil, nil, err
	}
	v, err := is.DefaultValidator(ppm)
	if err != nil {
		return nil, nil, err
	}

	return ppm, token.NewValidator(v), nil
}

type fakeLedger struct{}

func (*fakeLedger) GetState(_ tk.ID) ([]byte, error) {
	panic("ciao")
}
