// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
)

type TokenManagerService struct {
	AuditorServiceStub        func() driver.AuditorService
	auditorServiceMutex       sync.RWMutex
	auditorServiceArgsForCall []struct {
	}
	auditorServiceReturns struct {
		result1 driver.AuditorService
	}
	auditorServiceReturnsOnCall map[int]struct {
		result1 driver.AuditorService
	}
	AuthorizationStub        func() driver.Authorization
	authorizationMutex       sync.RWMutex
	authorizationArgsForCall []struct {
	}
	authorizationReturns struct {
		result1 driver.Authorization
	}
	authorizationReturnsOnCall map[int]struct {
		result1 driver.Authorization
	}
	CertificationServiceStub        func() driver.CertificationService
	certificationServiceMutex       sync.RWMutex
	certificationServiceArgsForCall []struct {
	}
	certificationServiceReturns struct {
		result1 driver.CertificationService
	}
	certificationServiceReturnsOnCall map[int]struct {
		result1 driver.CertificationService
	}
	ConfigurationStub        func() driver.Configuration
	configurationMutex       sync.RWMutex
	configurationArgsForCall []struct {
	}
	configurationReturns struct {
		result1 driver.Configuration
	}
	configurationReturnsOnCall map[int]struct {
		result1 driver.Configuration
	}
	DeserializerStub        func() driver.Deserializer
	deserializerMutex       sync.RWMutex
	deserializerArgsForCall []struct {
	}
	deserializerReturns struct {
		result1 driver.Deserializer
	}
	deserializerReturnsOnCall map[int]struct {
		result1 driver.Deserializer
	}
	DoneStub        func() error
	doneMutex       sync.RWMutex
	doneArgsForCall []struct {
	}
	doneReturns struct {
		result1 error
	}
	doneReturnsOnCall map[int]struct {
		result1 error
	}
	IdentityProviderStub        func() driver.IdentityProvider
	identityProviderMutex       sync.RWMutex
	identityProviderArgsForCall []struct {
	}
	identityProviderReturns struct {
		result1 driver.IdentityProvider
	}
	identityProviderReturnsOnCall map[int]struct {
		result1 driver.IdentityProvider
	}
	IssueServiceStub        func() driver.IssueService
	issueServiceMutex       sync.RWMutex
	issueServiceArgsForCall []struct {
	}
	issueServiceReturns struct {
		result1 driver.IssueService
	}
	issueServiceReturnsOnCall map[int]struct {
		result1 driver.IssueService
	}
	PublicParamsManagerStub        func() driver.PublicParamsManager
	publicParamsManagerMutex       sync.RWMutex
	publicParamsManagerArgsForCall []struct {
	}
	publicParamsManagerReturns struct {
		result1 driver.PublicParamsManager
	}
	publicParamsManagerReturnsOnCall map[int]struct {
		result1 driver.PublicParamsManager
	}
	TokensServiceStub        func() driver.TokensService
	tokensServiceMutex       sync.RWMutex
	tokensServiceArgsForCall []struct {
	}
	tokensServiceReturns struct {
		result1 driver.TokensService
	}
	tokensServiceReturnsOnCall map[int]struct {
		result1 driver.TokensService
	}
	TokensUpgradeServiceStub        func() driver.TokensUpgradeService
	tokensUpgradeServiceMutex       sync.RWMutex
	tokensUpgradeServiceArgsForCall []struct {
	}
	tokensUpgradeServiceReturns struct {
		result1 driver.TokensUpgradeService
	}
	tokensUpgradeServiceReturnsOnCall map[int]struct {
		result1 driver.TokensUpgradeService
	}
	TransferServiceStub        func() driver.TransferService
	transferServiceMutex       sync.RWMutex
	transferServiceArgsForCall []struct {
	}
	transferServiceReturns struct {
		result1 driver.TransferService
	}
	transferServiceReturnsOnCall map[int]struct {
		result1 driver.TransferService
	}
	ValidatorStub        func() (driver.Validator, error)
	validatorMutex       sync.RWMutex
	validatorArgsForCall []struct {
	}
	validatorReturns struct {
		result1 driver.Validator
		result2 error
	}
	validatorReturnsOnCall map[int]struct {
		result1 driver.Validator
		result2 error
	}
	WalletServiceStub        func() driver.WalletService
	walletServiceMutex       sync.RWMutex
	walletServiceArgsForCall []struct {
	}
	walletServiceReturns struct {
		result1 driver.WalletService
	}
	walletServiceReturnsOnCall map[int]struct {
		result1 driver.WalletService
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TokenManagerService) AuditorService() driver.AuditorService {
	fake.auditorServiceMutex.Lock()
	ret, specificReturn := fake.auditorServiceReturnsOnCall[len(fake.auditorServiceArgsForCall)]
	fake.auditorServiceArgsForCall = append(fake.auditorServiceArgsForCall, struct {
	}{})
	stub := fake.AuditorServiceStub
	fakeReturns := fake.auditorServiceReturns
	fake.recordInvocation("AuditorService", []interface{}{})
	fake.auditorServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) AuditorServiceCallCount() int {
	fake.auditorServiceMutex.RLock()
	defer fake.auditorServiceMutex.RUnlock()
	return len(fake.auditorServiceArgsForCall)
}

func (fake *TokenManagerService) AuditorServiceCalls(stub func() driver.AuditorService) {
	fake.auditorServiceMutex.Lock()
	defer fake.auditorServiceMutex.Unlock()
	fake.AuditorServiceStub = stub
}

func (fake *TokenManagerService) AuditorServiceReturns(result1 driver.AuditorService) {
	fake.auditorServiceMutex.Lock()
	defer fake.auditorServiceMutex.Unlock()
	fake.AuditorServiceStub = nil
	fake.auditorServiceReturns = struct {
		result1 driver.AuditorService
	}{result1}
}

func (fake *TokenManagerService) AuditorServiceReturnsOnCall(i int, result1 driver.AuditorService) {
	fake.auditorServiceMutex.Lock()
	defer fake.auditorServiceMutex.Unlock()
	fake.AuditorServiceStub = nil
	if fake.auditorServiceReturnsOnCall == nil {
		fake.auditorServiceReturnsOnCall = make(map[int]struct {
			result1 driver.AuditorService
		})
	}
	fake.auditorServiceReturnsOnCall[i] = struct {
		result1 driver.AuditorService
	}{result1}
}

func (fake *TokenManagerService) Authorization() driver.Authorization {
	fake.authorizationMutex.Lock()
	ret, specificReturn := fake.authorizationReturnsOnCall[len(fake.authorizationArgsForCall)]
	fake.authorizationArgsForCall = append(fake.authorizationArgsForCall, struct {
	}{})
	stub := fake.AuthorizationStub
	fakeReturns := fake.authorizationReturns
	fake.recordInvocation("Authorization", []interface{}{})
	fake.authorizationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) AuthorizationCallCount() int {
	fake.authorizationMutex.RLock()
	defer fake.authorizationMutex.RUnlock()
	return len(fake.authorizationArgsForCall)
}

func (fake *TokenManagerService) AuthorizationCalls(stub func() driver.Authorization) {
	fake.authorizationMutex.Lock()
	defer fake.authorizationMutex.Unlock()
	fake.AuthorizationStub = stub
}

func (fake *TokenManagerService) AuthorizationReturns(result1 driver.Authorization) {
	fake.authorizationMutex.Lock()
	defer fake.authorizationMutex.Unlock()
	fake.AuthorizationStub = nil
	fake.authorizationReturns = struct {
		result1 driver.Authorization
	}{result1}
}

func (fake *TokenManagerService) AuthorizationReturnsOnCall(i int, result1 driver.Authorization) {
	fake.authorizationMutex.Lock()
	defer fake.authorizationMutex.Unlock()
	fake.AuthorizationStub = nil
	if fake.authorizationReturnsOnCall == nil {
		fake.authorizationReturnsOnCall = make(map[int]struct {
			result1 driver.Authorization
		})
	}
	fake.authorizationReturnsOnCall[i] = struct {
		result1 driver.Authorization
	}{result1}
}

func (fake *TokenManagerService) CertificationService() driver.CertificationService {
	fake.certificationServiceMutex.Lock()
	ret, specificReturn := fake.certificationServiceReturnsOnCall[len(fake.certificationServiceArgsForCall)]
	fake.certificationServiceArgsForCall = append(fake.certificationServiceArgsForCall, struct {
	}{})
	stub := fake.CertificationServiceStub
	fakeReturns := fake.certificationServiceReturns
	fake.recordInvocation("CertificationService", []interface{}{})
	fake.certificationServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) CertificationServiceCallCount() int {
	fake.certificationServiceMutex.RLock()
	defer fake.certificationServiceMutex.RUnlock()
	return len(fake.certificationServiceArgsForCall)
}

func (fake *TokenManagerService) CertificationServiceCalls(stub func() driver.CertificationService) {
	fake.certificationServiceMutex.Lock()
	defer fake.certificationServiceMutex.Unlock()
	fake.CertificationServiceStub = stub
}

func (fake *TokenManagerService) CertificationServiceReturns(result1 driver.CertificationService) {
	fake.certificationServiceMutex.Lock()
	defer fake.certificationServiceMutex.Unlock()
	fake.CertificationServiceStub = nil
	fake.certificationServiceReturns = struct {
		result1 driver.CertificationService
	}{result1}
}

func (fake *TokenManagerService) CertificationServiceReturnsOnCall(i int, result1 driver.CertificationService) {
	fake.certificationServiceMutex.Lock()
	defer fake.certificationServiceMutex.Unlock()
	fake.CertificationServiceStub = nil
	if fake.certificationServiceReturnsOnCall == nil {
		fake.certificationServiceReturnsOnCall = make(map[int]struct {
			result1 driver.CertificationService
		})
	}
	fake.certificationServiceReturnsOnCall[i] = struct {
		result1 driver.CertificationService
	}{result1}
}

func (fake *TokenManagerService) Configuration() driver.Configuration {
	fake.configurationMutex.Lock()
	ret, specificReturn := fake.configurationReturnsOnCall[len(fake.configurationArgsForCall)]
	fake.configurationArgsForCall = append(fake.configurationArgsForCall, struct {
	}{})
	stub := fake.ConfigurationStub
	fakeReturns := fake.configurationReturns
	fake.recordInvocation("Configuration", []interface{}{})
	fake.configurationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) ConfigurationCallCount() int {
	fake.configurationMutex.RLock()
	defer fake.configurationMutex.RUnlock()
	return len(fake.configurationArgsForCall)
}

func (fake *TokenManagerService) ConfigurationCalls(stub func() driver.Configuration) {
	fake.configurationMutex.Lock()
	defer fake.configurationMutex.Unlock()
	fake.ConfigurationStub = stub
}

func (fake *TokenManagerService) ConfigurationReturns(result1 driver.Configuration) {
	fake.configurationMutex.Lock()
	defer fake.configurationMutex.Unlock()
	fake.ConfigurationStub = nil
	fake.configurationReturns = struct {
		result1 driver.Configuration
	}{result1}
}

func (fake *TokenManagerService) ConfigurationReturnsOnCall(i int, result1 driver.Configuration) {
	fake.configurationMutex.Lock()
	defer fake.configurationMutex.Unlock()
	fake.ConfigurationStub = nil
	if fake.configurationReturnsOnCall == nil {
		fake.configurationReturnsOnCall = make(map[int]struct {
			result1 driver.Configuration
		})
	}
	fake.configurationReturnsOnCall[i] = struct {
		result1 driver.Configuration
	}{result1}
}

func (fake *TokenManagerService) Deserializer() driver.Deserializer {
	fake.deserializerMutex.Lock()
	ret, specificReturn := fake.deserializerReturnsOnCall[len(fake.deserializerArgsForCall)]
	fake.deserializerArgsForCall = append(fake.deserializerArgsForCall, struct {
	}{})
	stub := fake.DeserializerStub
	fakeReturns := fake.deserializerReturns
	fake.recordInvocation("Deserializer", []interface{}{})
	fake.deserializerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) DeserializerCallCount() int {
	fake.deserializerMutex.RLock()
	defer fake.deserializerMutex.RUnlock()
	return len(fake.deserializerArgsForCall)
}

func (fake *TokenManagerService) DeserializerCalls(stub func() driver.Deserializer) {
	fake.deserializerMutex.Lock()
	defer fake.deserializerMutex.Unlock()
	fake.DeserializerStub = stub
}

func (fake *TokenManagerService) DeserializerReturns(result1 driver.Deserializer) {
	fake.deserializerMutex.Lock()
	defer fake.deserializerMutex.Unlock()
	fake.DeserializerStub = nil
	fake.deserializerReturns = struct {
		result1 driver.Deserializer
	}{result1}
}

func (fake *TokenManagerService) DeserializerReturnsOnCall(i int, result1 driver.Deserializer) {
	fake.deserializerMutex.Lock()
	defer fake.deserializerMutex.Unlock()
	fake.DeserializerStub = nil
	if fake.deserializerReturnsOnCall == nil {
		fake.deserializerReturnsOnCall = make(map[int]struct {
			result1 driver.Deserializer
		})
	}
	fake.deserializerReturnsOnCall[i] = struct {
		result1 driver.Deserializer
	}{result1}
}

func (fake *TokenManagerService) Done() error {
	fake.doneMutex.Lock()
	ret, specificReturn := fake.doneReturnsOnCall[len(fake.doneArgsForCall)]
	fake.doneArgsForCall = append(fake.doneArgsForCall, struct {
	}{})
	stub := fake.DoneStub
	fakeReturns := fake.doneReturns
	fake.recordInvocation("Done", []interface{}{})
	fake.doneMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) DoneCallCount() int {
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	return len(fake.doneArgsForCall)
}

func (fake *TokenManagerService) DoneCalls(stub func() error) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = stub
}

func (fake *TokenManagerService) DoneReturns(result1 error) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = nil
	fake.doneReturns = struct {
		result1 error
	}{result1}
}

func (fake *TokenManagerService) DoneReturnsOnCall(i int, result1 error) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = nil
	if fake.doneReturnsOnCall == nil {
		fake.doneReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doneReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TokenManagerService) IdentityProvider() driver.IdentityProvider {
	fake.identityProviderMutex.Lock()
	ret, specificReturn := fake.identityProviderReturnsOnCall[len(fake.identityProviderArgsForCall)]
	fake.identityProviderArgsForCall = append(fake.identityProviderArgsForCall, struct {
	}{})
	stub := fake.IdentityProviderStub
	fakeReturns := fake.identityProviderReturns
	fake.recordInvocation("IdentityProvider", []interface{}{})
	fake.identityProviderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) IdentityProviderCallCount() int {
	fake.identityProviderMutex.RLock()
	defer fake.identityProviderMutex.RUnlock()
	return len(fake.identityProviderArgsForCall)
}

func (fake *TokenManagerService) IdentityProviderCalls(stub func() driver.IdentityProvider) {
	fake.identityProviderMutex.Lock()
	defer fake.identityProviderMutex.Unlock()
	fake.IdentityProviderStub = stub
}

func (fake *TokenManagerService) IdentityProviderReturns(result1 driver.IdentityProvider) {
	fake.identityProviderMutex.Lock()
	defer fake.identityProviderMutex.Unlock()
	fake.IdentityProviderStub = nil
	fake.identityProviderReturns = struct {
		result1 driver.IdentityProvider
	}{result1}
}

func (fake *TokenManagerService) IdentityProviderReturnsOnCall(i int, result1 driver.IdentityProvider) {
	fake.identityProviderMutex.Lock()
	defer fake.identityProviderMutex.Unlock()
	fake.IdentityProviderStub = nil
	if fake.identityProviderReturnsOnCall == nil {
		fake.identityProviderReturnsOnCall = make(map[int]struct {
			result1 driver.IdentityProvider
		})
	}
	fake.identityProviderReturnsOnCall[i] = struct {
		result1 driver.IdentityProvider
	}{result1}
}

func (fake *TokenManagerService) IssueService() driver.IssueService {
	fake.issueServiceMutex.Lock()
	ret, specificReturn := fake.issueServiceReturnsOnCall[len(fake.issueServiceArgsForCall)]
	fake.issueServiceArgsForCall = append(fake.issueServiceArgsForCall, struct {
	}{})
	stub := fake.IssueServiceStub
	fakeReturns := fake.issueServiceReturns
	fake.recordInvocation("IssueService", []interface{}{})
	fake.issueServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) IssueServiceCallCount() int {
	fake.issueServiceMutex.RLock()
	defer fake.issueServiceMutex.RUnlock()
	return len(fake.issueServiceArgsForCall)
}

func (fake *TokenManagerService) IssueServiceCalls(stub func() driver.IssueService) {
	fake.issueServiceMutex.Lock()
	defer fake.issueServiceMutex.Unlock()
	fake.IssueServiceStub = stub
}

func (fake *TokenManagerService) IssueServiceReturns(result1 driver.IssueService) {
	fake.issueServiceMutex.Lock()
	defer fake.issueServiceMutex.Unlock()
	fake.IssueServiceStub = nil
	fake.issueServiceReturns = struct {
		result1 driver.IssueService
	}{result1}
}

func (fake *TokenManagerService) IssueServiceReturnsOnCall(i int, result1 driver.IssueService) {
	fake.issueServiceMutex.Lock()
	defer fake.issueServiceMutex.Unlock()
	fake.IssueServiceStub = nil
	if fake.issueServiceReturnsOnCall == nil {
		fake.issueServiceReturnsOnCall = make(map[int]struct {
			result1 driver.IssueService
		})
	}
	fake.issueServiceReturnsOnCall[i] = struct {
		result1 driver.IssueService
	}{result1}
}

func (fake *TokenManagerService) PublicParamsManager() driver.PublicParamsManager {
	fake.publicParamsManagerMutex.Lock()
	ret, specificReturn := fake.publicParamsManagerReturnsOnCall[len(fake.publicParamsManagerArgsForCall)]
	fake.publicParamsManagerArgsForCall = append(fake.publicParamsManagerArgsForCall, struct {
	}{})
	stub := fake.PublicParamsManagerStub
	fakeReturns := fake.publicParamsManagerReturns
	fake.recordInvocation("PublicParamsManager", []interface{}{})
	fake.publicParamsManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) PublicParamsManagerCallCount() int {
	fake.publicParamsManagerMutex.RLock()
	defer fake.publicParamsManagerMutex.RUnlock()
	return len(fake.publicParamsManagerArgsForCall)
}

func (fake *TokenManagerService) PublicParamsManagerCalls(stub func() driver.PublicParamsManager) {
	fake.publicParamsManagerMutex.Lock()
	defer fake.publicParamsManagerMutex.Unlock()
	fake.PublicParamsManagerStub = stub
}

func (fake *TokenManagerService) PublicParamsManagerReturns(result1 driver.PublicParamsManager) {
	fake.publicParamsManagerMutex.Lock()
	defer fake.publicParamsManagerMutex.Unlock()
	fake.PublicParamsManagerStub = nil
	fake.publicParamsManagerReturns = struct {
		result1 driver.PublicParamsManager
	}{result1}
}

func (fake *TokenManagerService) PublicParamsManagerReturnsOnCall(i int, result1 driver.PublicParamsManager) {
	fake.publicParamsManagerMutex.Lock()
	defer fake.publicParamsManagerMutex.Unlock()
	fake.PublicParamsManagerStub = nil
	if fake.publicParamsManagerReturnsOnCall == nil {
		fake.publicParamsManagerReturnsOnCall = make(map[int]struct {
			result1 driver.PublicParamsManager
		})
	}
	fake.publicParamsManagerReturnsOnCall[i] = struct {
		result1 driver.PublicParamsManager
	}{result1}
}

func (fake *TokenManagerService) TokensService() driver.TokensService {
	fake.tokensServiceMutex.Lock()
	ret, specificReturn := fake.tokensServiceReturnsOnCall[len(fake.tokensServiceArgsForCall)]
	fake.tokensServiceArgsForCall = append(fake.tokensServiceArgsForCall, struct {
	}{})
	stub := fake.TokensServiceStub
	fakeReturns := fake.tokensServiceReturns
	fake.recordInvocation("TokensService", []interface{}{})
	fake.tokensServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) TokensServiceCallCount() int {
	fake.tokensServiceMutex.RLock()
	defer fake.tokensServiceMutex.RUnlock()
	return len(fake.tokensServiceArgsForCall)
}

func (fake *TokenManagerService) TokensServiceCalls(stub func() driver.TokensService) {
	fake.tokensServiceMutex.Lock()
	defer fake.tokensServiceMutex.Unlock()
	fake.TokensServiceStub = stub
}

func (fake *TokenManagerService) TokensServiceReturns(result1 driver.TokensService) {
	fake.tokensServiceMutex.Lock()
	defer fake.tokensServiceMutex.Unlock()
	fake.TokensServiceStub = nil
	fake.tokensServiceReturns = struct {
		result1 driver.TokensService
	}{result1}
}

func (fake *TokenManagerService) TokensServiceReturnsOnCall(i int, result1 driver.TokensService) {
	fake.tokensServiceMutex.Lock()
	defer fake.tokensServiceMutex.Unlock()
	fake.TokensServiceStub = nil
	if fake.tokensServiceReturnsOnCall == nil {
		fake.tokensServiceReturnsOnCall = make(map[int]struct {
			result1 driver.TokensService
		})
	}
	fake.tokensServiceReturnsOnCall[i] = struct {
		result1 driver.TokensService
	}{result1}
}

func (fake *TokenManagerService) TokensUpgradeService() driver.TokensUpgradeService {
	fake.tokensUpgradeServiceMutex.Lock()
	ret, specificReturn := fake.tokensUpgradeServiceReturnsOnCall[len(fake.tokensUpgradeServiceArgsForCall)]
	fake.tokensUpgradeServiceArgsForCall = append(fake.tokensUpgradeServiceArgsForCall, struct {
	}{})
	stub := fake.TokensUpgradeServiceStub
	fakeReturns := fake.tokensUpgradeServiceReturns
	fake.recordInvocation("TokensUpgradeService", []interface{}{})
	fake.tokensUpgradeServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) TokensUpgradeServiceCallCount() int {
	fake.tokensUpgradeServiceMutex.RLock()
	defer fake.tokensUpgradeServiceMutex.RUnlock()
	return len(fake.tokensUpgradeServiceArgsForCall)
}

func (fake *TokenManagerService) TokensUpgradeServiceCalls(stub func() driver.TokensUpgradeService) {
	fake.tokensUpgradeServiceMutex.Lock()
	defer fake.tokensUpgradeServiceMutex.Unlock()
	fake.TokensUpgradeServiceStub = stub
}

func (fake *TokenManagerService) TokensUpgradeServiceReturns(result1 driver.TokensUpgradeService) {
	fake.tokensUpgradeServiceMutex.Lock()
	defer fake.tokensUpgradeServiceMutex.Unlock()
	fake.TokensUpgradeServiceStub = nil
	fake.tokensUpgradeServiceReturns = struct {
		result1 driver.TokensUpgradeService
	}{result1}
}

func (fake *TokenManagerService) TokensUpgradeServiceReturnsOnCall(i int, result1 driver.TokensUpgradeService) {
	fake.tokensUpgradeServiceMutex.Lock()
	defer fake.tokensUpgradeServiceMutex.Unlock()
	fake.TokensUpgradeServiceStub = nil
	if fake.tokensUpgradeServiceReturnsOnCall == nil {
		fake.tokensUpgradeServiceReturnsOnCall = make(map[int]struct {
			result1 driver.TokensUpgradeService
		})
	}
	fake.tokensUpgradeServiceReturnsOnCall[i] = struct {
		result1 driver.TokensUpgradeService
	}{result1}
}

func (fake *TokenManagerService) TransferService() driver.TransferService {
	fake.transferServiceMutex.Lock()
	ret, specificReturn := fake.transferServiceReturnsOnCall[len(fake.transferServiceArgsForCall)]
	fake.transferServiceArgsForCall = append(fake.transferServiceArgsForCall, struct {
	}{})
	stub := fake.TransferServiceStub
	fakeReturns := fake.transferServiceReturns
	fake.recordInvocation("TransferService", []interface{}{})
	fake.transferServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) TransferServiceCallCount() int {
	fake.transferServiceMutex.RLock()
	defer fake.transferServiceMutex.RUnlock()
	return len(fake.transferServiceArgsForCall)
}

func (fake *TokenManagerService) TransferServiceCalls(stub func() driver.TransferService) {
	fake.transferServiceMutex.Lock()
	defer fake.transferServiceMutex.Unlock()
	fake.TransferServiceStub = stub
}

func (fake *TokenManagerService) TransferServiceReturns(result1 driver.TransferService) {
	fake.transferServiceMutex.Lock()
	defer fake.transferServiceMutex.Unlock()
	fake.TransferServiceStub = nil
	fake.transferServiceReturns = struct {
		result1 driver.TransferService
	}{result1}
}

func (fake *TokenManagerService) TransferServiceReturnsOnCall(i int, result1 driver.TransferService) {
	fake.transferServiceMutex.Lock()
	defer fake.transferServiceMutex.Unlock()
	fake.TransferServiceStub = nil
	if fake.transferServiceReturnsOnCall == nil {
		fake.transferServiceReturnsOnCall = make(map[int]struct {
			result1 driver.TransferService
		})
	}
	fake.transferServiceReturnsOnCall[i] = struct {
		result1 driver.TransferService
	}{result1}
}

func (fake *TokenManagerService) Validator() (driver.Validator, error) {
	fake.validatorMutex.Lock()
	ret, specificReturn := fake.validatorReturnsOnCall[len(fake.validatorArgsForCall)]
	fake.validatorArgsForCall = append(fake.validatorArgsForCall, struct {
	}{})
	stub := fake.ValidatorStub
	fakeReturns := fake.validatorReturns
	fake.recordInvocation("Validator", []interface{}{})
	fake.validatorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenManagerService) ValidatorCallCount() int {
	fake.validatorMutex.RLock()
	defer fake.validatorMutex.RUnlock()
	return len(fake.validatorArgsForCall)
}

func (fake *TokenManagerService) ValidatorCalls(stub func() (driver.Validator, error)) {
	fake.validatorMutex.Lock()
	defer fake.validatorMutex.Unlock()
	fake.ValidatorStub = stub
}

func (fake *TokenManagerService) ValidatorReturns(result1 driver.Validator, result2 error) {
	fake.validatorMutex.Lock()
	defer fake.validatorMutex.Unlock()
	fake.ValidatorStub = nil
	fake.validatorReturns = struct {
		result1 driver.Validator
		result2 error
	}{result1, result2}
}

func (fake *TokenManagerService) ValidatorReturnsOnCall(i int, result1 driver.Validator, result2 error) {
	fake.validatorMutex.Lock()
	defer fake.validatorMutex.Unlock()
	fake.ValidatorStub = nil
	if fake.validatorReturnsOnCall == nil {
		fake.validatorReturnsOnCall = make(map[int]struct {
			result1 driver.Validator
			result2 error
		})
	}
	fake.validatorReturnsOnCall[i] = struct {
		result1 driver.Validator
		result2 error
	}{result1, result2}
}

func (fake *TokenManagerService) WalletService() driver.WalletService {
	fake.walletServiceMutex.Lock()
	ret, specificReturn := fake.walletServiceReturnsOnCall[len(fake.walletServiceArgsForCall)]
	fake.walletServiceArgsForCall = append(fake.walletServiceArgsForCall, struct {
	}{})
	stub := fake.WalletServiceStub
	fakeReturns := fake.walletServiceReturns
	fake.recordInvocation("WalletService", []interface{}{})
	fake.walletServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TokenManagerService) WalletServiceCallCount() int {
	fake.walletServiceMutex.RLock()
	defer fake.walletServiceMutex.RUnlock()
	return len(fake.walletServiceArgsForCall)
}

func (fake *TokenManagerService) WalletServiceCalls(stub func() driver.WalletService) {
	fake.walletServiceMutex.Lock()
	defer fake.walletServiceMutex.Unlock()
	fake.WalletServiceStub = stub
}

func (fake *TokenManagerService) WalletServiceReturns(result1 driver.WalletService) {
	fake.walletServiceMutex.Lock()
	defer fake.walletServiceMutex.Unlock()
	fake.WalletServiceStub = nil
	fake.walletServiceReturns = struct {
		result1 driver.WalletService
	}{result1}
}

func (fake *TokenManagerService) WalletServiceReturnsOnCall(i int, result1 driver.WalletService) {
	fake.walletServiceMutex.Lock()
	defer fake.walletServiceMutex.Unlock()
	fake.WalletServiceStub = nil
	if fake.walletServiceReturnsOnCall == nil {
		fake.walletServiceReturnsOnCall = make(map[int]struct {
			result1 driver.WalletService
		})
	}
	fake.walletServiceReturnsOnCall[i] = struct {
		result1 driver.WalletService
	}{result1}
}

func (fake *TokenManagerService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.auditorServiceMutex.RLock()
	defer fake.auditorServiceMutex.RUnlock()
	fake.authorizationMutex.RLock()
	defer fake.authorizationMutex.RUnlock()
	fake.certificationServiceMutex.RLock()
	defer fake.certificationServiceMutex.RUnlock()
	fake.configurationMutex.RLock()
	defer fake.configurationMutex.RUnlock()
	fake.deserializerMutex.RLock()
	defer fake.deserializerMutex.RUnlock()
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	fake.identityProviderMutex.RLock()
	defer fake.identityProviderMutex.RUnlock()
	fake.issueServiceMutex.RLock()
	defer fake.issueServiceMutex.RUnlock()
	fake.publicParamsManagerMutex.RLock()
	defer fake.publicParamsManagerMutex.RUnlock()
	fake.tokensServiceMutex.RLock()
	defer fake.tokensServiceMutex.RUnlock()
	fake.tokensUpgradeServiceMutex.RLock()
	defer fake.tokensUpgradeServiceMutex.RUnlock()
	fake.transferServiceMutex.RLock()
	defer fake.transferServiceMutex.RUnlock()
	fake.validatorMutex.RLock()
	defer fake.validatorMutex.RUnlock()
	fake.walletServiceMutex.RLock()
	defer fake.walletServiceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TokenManagerService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.TokenManagerService = new(TokenManagerService)
