// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/token"
)

type TransferService struct {
	DeserializeTransferActionStub        func([]byte) (driver.TransferAction, error)
	deserializeTransferActionMutex       sync.RWMutex
	deserializeTransferActionArgsForCall []struct {
		arg1 []byte
	}
	deserializeTransferActionReturns struct {
		result1 driver.TransferAction
		result2 error
	}
	deserializeTransferActionReturnsOnCall map[int]struct {
		result1 driver.TransferAction
		result2 error
	}
	TransferStub        func(context.Context, driver.TokenRequestAnchor, driver.OwnerWallet, []*token.ID, []*token.Token, *driver.TransferOptions) (driver.TransferAction, *driver.TransferMetadata, error)
	transferMutex       sync.RWMutex
	transferArgsForCall []struct {
		arg1 context.Context
		arg2 driver.TokenRequestAnchor
		arg3 driver.OwnerWallet
		arg4 []*token.ID
		arg5 []*token.Token
		arg6 *driver.TransferOptions
	}
	transferReturns struct {
		result1 driver.TransferAction
		result2 *driver.TransferMetadata
		result3 error
	}
	transferReturnsOnCall map[int]struct {
		result1 driver.TransferAction
		result2 *driver.TransferMetadata
		result3 error
	}
	VerifyTransferStub        func(context.Context, driver.TransferAction, []*driver.TransferOutputMetadata) error
	verifyTransferMutex       sync.RWMutex
	verifyTransferArgsForCall []struct {
		arg1 context.Context
		arg2 driver.TransferAction
		arg3 []*driver.TransferOutputMetadata
	}
	verifyTransferReturns struct {
		result1 error
	}
	verifyTransferReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TransferService) DeserializeTransferAction(arg1 []byte) (driver.TransferAction, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deserializeTransferActionMutex.Lock()
	ret, specificReturn := fake.deserializeTransferActionReturnsOnCall[len(fake.deserializeTransferActionArgsForCall)]
	fake.deserializeTransferActionArgsForCall = append(fake.deserializeTransferActionArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.DeserializeTransferActionStub
	fakeReturns := fake.deserializeTransferActionReturns
	fake.recordInvocation("DeserializeTransferAction", []interface{}{arg1Copy})
	fake.deserializeTransferActionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransferService) DeserializeTransferActionCallCount() int {
	fake.deserializeTransferActionMutex.RLock()
	defer fake.deserializeTransferActionMutex.RUnlock()
	return len(fake.deserializeTransferActionArgsForCall)
}

func (fake *TransferService) DeserializeTransferActionCalls(stub func([]byte) (driver.TransferAction, error)) {
	fake.deserializeTransferActionMutex.Lock()
	defer fake.deserializeTransferActionMutex.Unlock()
	fake.DeserializeTransferActionStub = stub
}

func (fake *TransferService) DeserializeTransferActionArgsForCall(i int) []byte {
	fake.deserializeTransferActionMutex.RLock()
	defer fake.deserializeTransferActionMutex.RUnlock()
	argsForCall := fake.deserializeTransferActionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransferService) DeserializeTransferActionReturns(result1 driver.TransferAction, result2 error) {
	fake.deserializeTransferActionMutex.Lock()
	defer fake.deserializeTransferActionMutex.Unlock()
	fake.DeserializeTransferActionStub = nil
	fake.deserializeTransferActionReturns = struct {
		result1 driver.TransferAction
		result2 error
	}{result1, result2}
}

func (fake *TransferService) DeserializeTransferActionReturnsOnCall(i int, result1 driver.TransferAction, result2 error) {
	fake.deserializeTransferActionMutex.Lock()
	defer fake.deserializeTransferActionMutex.Unlock()
	fake.DeserializeTransferActionStub = nil
	if fake.deserializeTransferActionReturnsOnCall == nil {
		fake.deserializeTransferActionReturnsOnCall = make(map[int]struct {
			result1 driver.TransferAction
			result2 error
		})
	}
	fake.deserializeTransferActionReturnsOnCall[i] = struct {
		result1 driver.TransferAction
		result2 error
	}{result1, result2}
}

func (fake *TransferService) Transfer(arg1 context.Context, arg2 driver.TokenRequestAnchor, arg3 driver.OwnerWallet, arg4 []*token.ID, arg5 []*token.Token, arg6 *driver.TransferOptions) (driver.TransferAction, *driver.TransferMetadata, error) {
	var arg4Copy []*token.ID
	if arg4 != nil {
		arg4Copy = make([]*token.ID, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []*token.Token
	if arg5 != nil {
		arg5Copy = make([]*token.Token, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.transferMutex.Lock()
	ret, specificReturn := fake.transferReturnsOnCall[len(fake.transferArgsForCall)]
	fake.transferArgsForCall = append(fake.transferArgsForCall, struct {
		arg1 context.Context
		arg2 driver.TokenRequestAnchor
		arg3 driver.OwnerWallet
		arg4 []*token.ID
		arg5 []*token.Token
		arg6 *driver.TransferOptions
	}{arg1, arg2, arg3, arg4Copy, arg5Copy, arg6})
	stub := fake.TransferStub
	fakeReturns := fake.transferReturns
	fake.recordInvocation("Transfer", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy, arg6})
	fake.transferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *TransferService) TransferCallCount() int {
	fake.transferMutex.RLock()
	defer fake.transferMutex.RUnlock()
	return len(fake.transferArgsForCall)
}

func (fake *TransferService) TransferCalls(stub func(context.Context, driver.TokenRequestAnchor, driver.OwnerWallet, []*token.ID, []*token.Token, *driver.TransferOptions) (driver.TransferAction, *driver.TransferMetadata, error)) {
	fake.transferMutex.Lock()
	defer fake.transferMutex.Unlock()
	fake.TransferStub = stub
}

func (fake *TransferService) TransferArgsForCall(i int) (context.Context, driver.TokenRequestAnchor, driver.OwnerWallet, []*token.ID, []*token.Token, *driver.TransferOptions) {
	fake.transferMutex.RLock()
	defer fake.transferMutex.RUnlock()
	argsForCall := fake.transferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *TransferService) TransferReturns(result1 driver.TransferAction, result2 *driver.TransferMetadata, result3 error) {
	fake.transferMutex.Lock()
	defer fake.transferMutex.Unlock()
	fake.TransferStub = nil
	fake.transferReturns = struct {
		result1 driver.TransferAction
		result2 *driver.TransferMetadata
		result3 error
	}{result1, result2, result3}
}

func (fake *TransferService) TransferReturnsOnCall(i int, result1 driver.TransferAction, result2 *driver.TransferMetadata, result3 error) {
	fake.transferMutex.Lock()
	defer fake.transferMutex.Unlock()
	fake.TransferStub = nil
	if fake.transferReturnsOnCall == nil {
		fake.transferReturnsOnCall = make(map[int]struct {
			result1 driver.TransferAction
			result2 *driver.TransferMetadata
			result3 error
		})
	}
	fake.transferReturnsOnCall[i] = struct {
		result1 driver.TransferAction
		result2 *driver.TransferMetadata
		result3 error
	}{result1, result2, result3}
}

func (fake *TransferService) VerifyTransfer(arg1 context.Context, arg2 driver.TransferAction, arg3 []*driver.TransferOutputMetadata) error {
	var arg3Copy []*driver.TransferOutputMetadata
	if arg3 != nil {
		arg3Copy = make([]*driver.TransferOutputMetadata, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.verifyTransferMutex.Lock()
	ret, specificReturn := fake.verifyTransferReturnsOnCall[len(fake.verifyTransferArgsForCall)]
	fake.verifyTransferArgsForCall = append(fake.verifyTransferArgsForCall, struct {
		arg1 context.Context
		arg2 driver.TransferAction
		arg3 []*driver.TransferOutputMetadata
	}{arg1, arg2, arg3Copy})
	stub := fake.VerifyTransferStub
	fakeReturns := fake.verifyTransferReturns
	fake.recordInvocation("VerifyTransfer", []interface{}{arg1, arg2, arg3Copy})
	fake.verifyTransferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransferService) VerifyTransferCallCount() int {
	fake.verifyTransferMutex.RLock()
	defer fake.verifyTransferMutex.RUnlock()
	return len(fake.verifyTransferArgsForCall)
}

func (fake *TransferService) VerifyTransferCalls(stub func(context.Context, driver.TransferAction, []*driver.TransferOutputMetadata) error) {
	fake.verifyTransferMutex.Lock()
	defer fake.verifyTransferMutex.Unlock()
	fake.VerifyTransferStub = stub
}

func (fake *TransferService) VerifyTransferArgsForCall(i int) (context.Context, driver.TransferAction, []*driver.TransferOutputMetadata) {
	fake.verifyTransferMutex.RLock()
	defer fake.verifyTransferMutex.RUnlock()
	argsForCall := fake.verifyTransferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TransferService) VerifyTransferReturns(result1 error) {
	fake.verifyTransferMutex.Lock()
	defer fake.verifyTransferMutex.Unlock()
	fake.VerifyTransferStub = nil
	fake.verifyTransferReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransferService) VerifyTransferReturnsOnCall(i int, result1 error) {
	fake.verifyTransferMutex.Lock()
	defer fake.verifyTransferMutex.Unlock()
	fake.VerifyTransferStub = nil
	if fake.verifyTransferReturnsOnCall == nil {
		fake.verifyTransferReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyTransferReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransferService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deserializeTransferActionMutex.RLock()
	defer fake.deserializeTransferActionMutex.RUnlock()
	fake.transferMutex.RLock()
	defer fake.transferMutex.RUnlock()
	fake.verifyTransferMutex.RLock()
	defer fake.verifyTransferMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TransferService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.TransferService = new(TransferService)
