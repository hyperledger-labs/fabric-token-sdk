// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
)

type PublicParameters struct {
	AuditorsStub        func() []driver.Identity
	auditorsMutex       sync.RWMutex
	auditorsArgsForCall []struct {
	}
	auditorsReturns struct {
		result1 []driver.Identity
	}
	auditorsReturnsOnCall map[int]struct {
		result1 []driver.Identity
	}
	CertificationDriverStub        func() string
	certificationDriverMutex       sync.RWMutex
	certificationDriverArgsForCall []struct {
	}
	certificationDriverReturns struct {
		result1 string
	}
	certificationDriverReturnsOnCall map[int]struct {
		result1 string
	}
	ExtrasStub        func() driver.Extras
	extrasMutex       sync.RWMutex
	extrasArgsForCall []struct {
	}
	extrasReturns struct {
		result1 driver.Extras
	}
	extrasReturnsOnCall map[int]struct {
		result1 driver.Extras
	}
	GraphHidingStub        func() bool
	graphHidingMutex       sync.RWMutex
	graphHidingArgsForCall []struct {
	}
	graphHidingReturns struct {
		result1 bool
	}
	graphHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	IssuersStub        func() []driver.Identity
	issuersMutex       sync.RWMutex
	issuersArgsForCall []struct {
	}
	issuersReturns struct {
		result1 []driver.Identity
	}
	issuersReturnsOnCall map[int]struct {
		result1 []driver.Identity
	}
	MaxTokenValueStub        func() uint64
	maxTokenValueMutex       sync.RWMutex
	maxTokenValueArgsForCall []struct {
	}
	maxTokenValueReturns struct {
		result1 uint64
	}
	maxTokenValueReturnsOnCall map[int]struct {
		result1 uint64
	}
	PrecisionStub        func() uint64
	precisionMutex       sync.RWMutex
	precisionArgsForCall []struct {
	}
	precisionReturns struct {
		result1 uint64
	}
	precisionReturnsOnCall map[int]struct {
		result1 uint64
	}
	SerializeStub        func() ([]byte, error)
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct {
	}
	serializeReturns struct {
		result1 []byte
		result2 error
	}
	serializeReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
	}
	stringReturns struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	TokenDataHidingStub        func() bool
	tokenDataHidingMutex       sync.RWMutex
	tokenDataHidingArgsForCall []struct {
	}
	tokenDataHidingReturns struct {
		result1 bool
	}
	tokenDataHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	TokenDriverNameStub        func() driver.TokenDriverName
	tokenDriverNameMutex       sync.RWMutex
	tokenDriverNameArgsForCall []struct {
	}
	tokenDriverNameReturns struct {
		result1 driver.TokenDriverName
	}
	tokenDriverNameReturnsOnCall map[int]struct {
		result1 driver.TokenDriverName
	}
	TokenDriverVersionStub        func() driver.TokenDriverVersion
	tokenDriverVersionMutex       sync.RWMutex
	tokenDriverVersionArgsForCall []struct {
	}
	tokenDriverVersionReturns struct {
		result1 driver.TokenDriverVersion
	}
	tokenDriverVersionReturnsOnCall map[int]struct {
		result1 driver.TokenDriverVersion
	}
	ValidateStub        func() error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
	}
	validateReturns struct {
		result1 error
	}
	validateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *PublicParameters) Auditors() []driver.Identity {
	fake.auditorsMutex.Lock()
	ret, specificReturn := fake.auditorsReturnsOnCall[len(fake.auditorsArgsForCall)]
	fake.auditorsArgsForCall = append(fake.auditorsArgsForCall, struct {
	}{})
	stub := fake.AuditorsStub
	fakeReturns := fake.auditorsReturns
	fake.recordInvocation("Auditors", []interface{}{})
	fake.auditorsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) AuditorsCallCount() int {
	fake.auditorsMutex.RLock()
	defer fake.auditorsMutex.RUnlock()
	return len(fake.auditorsArgsForCall)
}

func (fake *PublicParameters) AuditorsCalls(stub func() []driver.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = stub
}

func (fake *PublicParameters) AuditorsReturns(result1 []driver.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = nil
	fake.auditorsReturns = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) AuditorsReturnsOnCall(i int, result1 []driver.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = nil
	if fake.auditorsReturnsOnCall == nil {
		fake.auditorsReturnsOnCall = make(map[int]struct {
			result1 []driver.Identity
		})
	}
	fake.auditorsReturnsOnCall[i] = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) CertificationDriver() string {
	fake.certificationDriverMutex.Lock()
	ret, specificReturn := fake.certificationDriverReturnsOnCall[len(fake.certificationDriverArgsForCall)]
	fake.certificationDriverArgsForCall = append(fake.certificationDriverArgsForCall, struct {
	}{})
	stub := fake.CertificationDriverStub
	fakeReturns := fake.certificationDriverReturns
	fake.recordInvocation("CertificationDriver", []interface{}{})
	fake.certificationDriverMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) CertificationDriverCallCount() int {
	fake.certificationDriverMutex.RLock()
	defer fake.certificationDriverMutex.RUnlock()
	return len(fake.certificationDriverArgsForCall)
}

func (fake *PublicParameters) CertificationDriverCalls(stub func() string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = stub
}

func (fake *PublicParameters) CertificationDriverReturns(result1 string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = nil
	fake.certificationDriverReturns = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) CertificationDriverReturnsOnCall(i int, result1 string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = nil
	if fake.certificationDriverReturnsOnCall == nil {
		fake.certificationDriverReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.certificationDriverReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) Extras() driver.Extras {
	fake.extrasMutex.Lock()
	ret, specificReturn := fake.extrasReturnsOnCall[len(fake.extrasArgsForCall)]
	fake.extrasArgsForCall = append(fake.extrasArgsForCall, struct {
	}{})
	stub := fake.ExtrasStub
	fakeReturns := fake.extrasReturns
	fake.recordInvocation("Extras", []interface{}{})
	fake.extrasMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) ExtrasCallCount() int {
	fake.extrasMutex.RLock()
	defer fake.extrasMutex.RUnlock()
	return len(fake.extrasArgsForCall)
}

func (fake *PublicParameters) ExtrasCalls(stub func() driver.Extras) {
	fake.extrasMutex.Lock()
	defer fake.extrasMutex.Unlock()
	fake.ExtrasStub = stub
}

func (fake *PublicParameters) ExtrasReturns(result1 driver.Extras) {
	fake.extrasMutex.Lock()
	defer fake.extrasMutex.Unlock()
	fake.ExtrasStub = nil
	fake.extrasReturns = struct {
		result1 driver.Extras
	}{result1}
}

func (fake *PublicParameters) ExtrasReturnsOnCall(i int, result1 driver.Extras) {
	fake.extrasMutex.Lock()
	defer fake.extrasMutex.Unlock()
	fake.ExtrasStub = nil
	if fake.extrasReturnsOnCall == nil {
		fake.extrasReturnsOnCall = make(map[int]struct {
			result1 driver.Extras
		})
	}
	fake.extrasReturnsOnCall[i] = struct {
		result1 driver.Extras
	}{result1}
}

func (fake *PublicParameters) GraphHiding() bool {
	fake.graphHidingMutex.Lock()
	ret, specificReturn := fake.graphHidingReturnsOnCall[len(fake.graphHidingArgsForCall)]
	fake.graphHidingArgsForCall = append(fake.graphHidingArgsForCall, struct {
	}{})
	stub := fake.GraphHidingStub
	fakeReturns := fake.graphHidingReturns
	fake.recordInvocation("GraphHiding", []interface{}{})
	fake.graphHidingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) GraphHidingCallCount() int {
	fake.graphHidingMutex.RLock()
	defer fake.graphHidingMutex.RUnlock()
	return len(fake.graphHidingArgsForCall)
}

func (fake *PublicParameters) GraphHidingCalls(stub func() bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = stub
}

func (fake *PublicParameters) GraphHidingReturns(result1 bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = nil
	fake.graphHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) GraphHidingReturnsOnCall(i int, result1 bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = nil
	if fake.graphHidingReturnsOnCall == nil {
		fake.graphHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.graphHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) Issuers() []driver.Identity {
	fake.issuersMutex.Lock()
	ret, specificReturn := fake.issuersReturnsOnCall[len(fake.issuersArgsForCall)]
	fake.issuersArgsForCall = append(fake.issuersArgsForCall, struct {
	}{})
	stub := fake.IssuersStub
	fakeReturns := fake.issuersReturns
	fake.recordInvocation("Issuers", []interface{}{})
	fake.issuersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) IssuersCallCount() int {
	fake.issuersMutex.RLock()
	defer fake.issuersMutex.RUnlock()
	return len(fake.issuersArgsForCall)
}

func (fake *PublicParameters) IssuersCalls(stub func() []driver.Identity) {
	fake.issuersMutex.Lock()
	defer fake.issuersMutex.Unlock()
	fake.IssuersStub = stub
}

func (fake *PublicParameters) IssuersReturns(result1 []driver.Identity) {
	fake.issuersMutex.Lock()
	defer fake.issuersMutex.Unlock()
	fake.IssuersStub = nil
	fake.issuersReturns = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) IssuersReturnsOnCall(i int, result1 []driver.Identity) {
	fake.issuersMutex.Lock()
	defer fake.issuersMutex.Unlock()
	fake.IssuersStub = nil
	if fake.issuersReturnsOnCall == nil {
		fake.issuersReturnsOnCall = make(map[int]struct {
			result1 []driver.Identity
		})
	}
	fake.issuersReturnsOnCall[i] = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) MaxTokenValue() uint64 {
	fake.maxTokenValueMutex.Lock()
	ret, specificReturn := fake.maxTokenValueReturnsOnCall[len(fake.maxTokenValueArgsForCall)]
	fake.maxTokenValueArgsForCall = append(fake.maxTokenValueArgsForCall, struct {
	}{})
	stub := fake.MaxTokenValueStub
	fakeReturns := fake.maxTokenValueReturns
	fake.recordInvocation("MaxTokenValue", []interface{}{})
	fake.maxTokenValueMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) MaxTokenValueCallCount() int {
	fake.maxTokenValueMutex.RLock()
	defer fake.maxTokenValueMutex.RUnlock()
	return len(fake.maxTokenValueArgsForCall)
}

func (fake *PublicParameters) MaxTokenValueCalls(stub func() uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = stub
}

func (fake *PublicParameters) MaxTokenValueReturns(result1 uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = nil
	fake.maxTokenValueReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) MaxTokenValueReturnsOnCall(i int, result1 uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = nil
	if fake.maxTokenValueReturnsOnCall == nil {
		fake.maxTokenValueReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.maxTokenValueReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) Precision() uint64 {
	fake.precisionMutex.Lock()
	ret, specificReturn := fake.precisionReturnsOnCall[len(fake.precisionArgsForCall)]
	fake.precisionArgsForCall = append(fake.precisionArgsForCall, struct {
	}{})
	stub := fake.PrecisionStub
	fakeReturns := fake.precisionReturns
	fake.recordInvocation("Precision", []interface{}{})
	fake.precisionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) PrecisionCallCount() int {
	fake.precisionMutex.RLock()
	defer fake.precisionMutex.RUnlock()
	return len(fake.precisionArgsForCall)
}

func (fake *PublicParameters) PrecisionCalls(stub func() uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = stub
}

func (fake *PublicParameters) PrecisionReturns(result1 uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = nil
	fake.precisionReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) PrecisionReturnsOnCall(i int, result1 uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = nil
	if fake.precisionReturnsOnCall == nil {
		fake.precisionReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.precisionReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) Serialize() ([]byte, error) {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct {
	}{})
	stub := fake.SerializeStub
	fakeReturns := fake.serializeReturns
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PublicParameters) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *PublicParameters) SerializeCalls(stub func() ([]byte, error)) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = stub
}

func (fake *PublicParameters) SerializeReturns(result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) SerializeReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
	}{})
	stub := fake.StringStub
	fakeReturns := fake.stringReturns
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *PublicParameters) StringCalls(stub func() string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *PublicParameters) StringReturns(result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) StringReturnsOnCall(i int, result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) TokenDataHiding() bool {
	fake.tokenDataHidingMutex.Lock()
	ret, specificReturn := fake.tokenDataHidingReturnsOnCall[len(fake.tokenDataHidingArgsForCall)]
	fake.tokenDataHidingArgsForCall = append(fake.tokenDataHidingArgsForCall, struct {
	}{})
	stub := fake.TokenDataHidingStub
	fakeReturns := fake.tokenDataHidingReturns
	fake.recordInvocation("TokenDataHiding", []interface{}{})
	fake.tokenDataHidingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) TokenDataHidingCallCount() int {
	fake.tokenDataHidingMutex.RLock()
	defer fake.tokenDataHidingMutex.RUnlock()
	return len(fake.tokenDataHidingArgsForCall)
}

func (fake *PublicParameters) TokenDataHidingCalls(stub func() bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = stub
}

func (fake *PublicParameters) TokenDataHidingReturns(result1 bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = nil
	fake.tokenDataHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) TokenDataHidingReturnsOnCall(i int, result1 bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = nil
	if fake.tokenDataHidingReturnsOnCall == nil {
		fake.tokenDataHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tokenDataHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) TokenDriverName() driver.TokenDriverName {
	fake.tokenDriverNameMutex.Lock()
	ret, specificReturn := fake.tokenDriverNameReturnsOnCall[len(fake.tokenDriverNameArgsForCall)]
	fake.tokenDriverNameArgsForCall = append(fake.tokenDriverNameArgsForCall, struct {
	}{})
	stub := fake.TokenDriverNameStub
	fakeReturns := fake.tokenDriverNameReturns
	fake.recordInvocation("TokenDriverName", []interface{}{})
	fake.tokenDriverNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) TokenDriverNameCallCount() int {
	fake.tokenDriverNameMutex.RLock()
	defer fake.tokenDriverNameMutex.RUnlock()
	return len(fake.tokenDriverNameArgsForCall)
}

func (fake *PublicParameters) TokenDriverNameCalls(stub func() driver.TokenDriverName) {
	fake.tokenDriverNameMutex.Lock()
	defer fake.tokenDriverNameMutex.Unlock()
	fake.TokenDriverNameStub = stub
}

func (fake *PublicParameters) TokenDriverNameReturns(result1 driver.TokenDriverName) {
	fake.tokenDriverNameMutex.Lock()
	defer fake.tokenDriverNameMutex.Unlock()
	fake.TokenDriverNameStub = nil
	fake.tokenDriverNameReturns = struct {
		result1 driver.TokenDriverName
	}{result1}
}

func (fake *PublicParameters) TokenDriverNameReturnsOnCall(i int, result1 driver.TokenDriverName) {
	fake.tokenDriverNameMutex.Lock()
	defer fake.tokenDriverNameMutex.Unlock()
	fake.TokenDriverNameStub = nil
	if fake.tokenDriverNameReturnsOnCall == nil {
		fake.tokenDriverNameReturnsOnCall = make(map[int]struct {
			result1 driver.TokenDriverName
		})
	}
	fake.tokenDriverNameReturnsOnCall[i] = struct {
		result1 driver.TokenDriverName
	}{result1}
}

func (fake *PublicParameters) TokenDriverVersion() driver.TokenDriverVersion {
	fake.tokenDriverVersionMutex.Lock()
	ret, specificReturn := fake.tokenDriverVersionReturnsOnCall[len(fake.tokenDriverVersionArgsForCall)]
	fake.tokenDriverVersionArgsForCall = append(fake.tokenDriverVersionArgsForCall, struct {
	}{})
	stub := fake.TokenDriverVersionStub
	fakeReturns := fake.tokenDriverVersionReturns
	fake.recordInvocation("TokenDriverVersion", []interface{}{})
	fake.tokenDriverVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) TokenDriverVersionCallCount() int {
	fake.tokenDriverVersionMutex.RLock()
	defer fake.tokenDriverVersionMutex.RUnlock()
	return len(fake.tokenDriverVersionArgsForCall)
}

func (fake *PublicParameters) TokenDriverVersionCalls(stub func() driver.TokenDriverVersion) {
	fake.tokenDriverVersionMutex.Lock()
	defer fake.tokenDriverVersionMutex.Unlock()
	fake.TokenDriverVersionStub = stub
}

func (fake *PublicParameters) TokenDriverVersionReturns(result1 driver.TokenDriverVersion) {
	fake.tokenDriverVersionMutex.Lock()
	defer fake.tokenDriverVersionMutex.Unlock()
	fake.TokenDriverVersionStub = nil
	fake.tokenDriverVersionReturns = struct {
		result1 driver.TokenDriverVersion
	}{result1}
}

func (fake *PublicParameters) TokenDriverVersionReturnsOnCall(i int, result1 driver.TokenDriverVersion) {
	fake.tokenDriverVersionMutex.Lock()
	defer fake.tokenDriverVersionMutex.Unlock()
	fake.TokenDriverVersionStub = nil
	if fake.tokenDriverVersionReturnsOnCall == nil {
		fake.tokenDriverVersionReturnsOnCall = make(map[int]struct {
			result1 driver.TokenDriverVersion
		})
	}
	fake.tokenDriverVersionReturnsOnCall[i] = struct {
		result1 driver.TokenDriverVersion
	}{result1}
}

func (fake *PublicParameters) Validate() error {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
	}{})
	stub := fake.ValidateStub
	fakeReturns := fake.validateReturns
	fake.recordInvocation("Validate", []interface{}{})
	fake.validateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *PublicParameters) ValidateCalls(stub func() error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *PublicParameters) ValidateReturns(result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *PublicParameters) ValidateReturnsOnCall(i int, result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PublicParameters) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.auditorsMutex.RLock()
	defer fake.auditorsMutex.RUnlock()
	fake.certificationDriverMutex.RLock()
	defer fake.certificationDriverMutex.RUnlock()
	fake.extrasMutex.RLock()
	defer fake.extrasMutex.RUnlock()
	fake.graphHidingMutex.RLock()
	defer fake.graphHidingMutex.RUnlock()
	fake.issuersMutex.RLock()
	defer fake.issuersMutex.RUnlock()
	fake.maxTokenValueMutex.RLock()
	defer fake.maxTokenValueMutex.RUnlock()
	fake.precisionMutex.RLock()
	defer fake.precisionMutex.RUnlock()
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.tokenDataHidingMutex.RLock()
	defer fake.tokenDataHidingMutex.RUnlock()
	fake.tokenDriverNameMutex.RLock()
	defer fake.tokenDriverNameMutex.RUnlock()
	fake.tokenDriverVersionMutex.RLock()
	defer fake.tokenDriverVersionMutex.RUnlock()
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *PublicParameters) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.PublicParameters = new(PublicParameters)
