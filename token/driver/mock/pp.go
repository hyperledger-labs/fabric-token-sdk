// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-smart-client/platform/view/view"
	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
)

type PublicParameters struct {
	AuditorsStub        func() []view.Identity
	auditorsMutex       sync.RWMutex
	auditorsArgsForCall []struct {
	}
	auditorsReturns struct {
		result1 []view.Identity
	}
	auditorsReturnsOnCall map[int]struct {
		result1 []view.Identity
	}
	BytesStub        func() ([]byte, error)
	bytesMutex       sync.RWMutex
	bytesArgsForCall []struct {
	}
	bytesReturns struct {
		result1 []byte
		result2 error
	}
	bytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	CertificationDriverStub        func() string
	certificationDriverMutex       sync.RWMutex
	certificationDriverArgsForCall []struct {
	}
	certificationDriverReturns struct {
		result1 string
	}
	certificationDriverReturnsOnCall map[int]struct {
		result1 string
	}
	GraphHidingStub        func() bool
	graphHidingMutex       sync.RWMutex
	graphHidingArgsForCall []struct {
	}
	graphHidingReturns struct {
		result1 bool
	}
	graphHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	IdentifierStub        func() string
	identifierMutex       sync.RWMutex
	identifierArgsForCall []struct {
	}
	identifierReturns struct {
		result1 string
	}
	identifierReturnsOnCall map[int]struct {
		result1 string
	}
	MaxTokenValueStub        func() uint64
	maxTokenValueMutex       sync.RWMutex
	maxTokenValueArgsForCall []struct {
	}
	maxTokenValueReturns struct {
		result1 uint64
	}
	maxTokenValueReturnsOnCall map[int]struct {
		result1 uint64
	}
	PrecisionStub        func() uint64
	precisionMutex       sync.RWMutex
	precisionArgsForCall []struct {
	}
	precisionReturns struct {
		result1 uint64
	}
	precisionReturnsOnCall map[int]struct {
		result1 uint64
	}
	SerializeStub        func() ([]byte, error)
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct {
	}
	serializeReturns struct {
		result1 []byte
		result2 error
	}
	serializeReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
	}
	stringReturns struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	TokenDataHidingStub        func() bool
	tokenDataHidingMutex       sync.RWMutex
	tokenDataHidingArgsForCall []struct {
	}
	tokenDataHidingReturns struct {
		result1 bool
	}
	tokenDataHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	ValidateStub        func() error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
	}
	validateReturns struct {
		result1 error
	}
	validateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *PublicParameters) Auditors() []view.Identity {
	fake.auditorsMutex.Lock()
	ret, specificReturn := fake.auditorsReturnsOnCall[len(fake.auditorsArgsForCall)]
	fake.auditorsArgsForCall = append(fake.auditorsArgsForCall, struct {
	}{})
	stub := fake.AuditorsStub
	fakeReturns := fake.auditorsReturns
	fake.recordInvocation("Auditors", []interface{}{})
	fake.auditorsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) AuditorsCallCount() int {
	fake.auditorsMutex.RLock()
	defer fake.auditorsMutex.RUnlock()
	return len(fake.auditorsArgsForCall)
}

func (fake *PublicParameters) AuditorsCalls(stub func() []view.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = stub
}

func (fake *PublicParameters) AuditorsReturns(result1 []view.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = nil
	fake.auditorsReturns = struct {
		result1 []view.Identity
	}{result1}
}

func (fake *PublicParameters) AuditorsReturnsOnCall(i int, result1 []view.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = nil
	if fake.auditorsReturnsOnCall == nil {
		fake.auditorsReturnsOnCall = make(map[int]struct {
			result1 []view.Identity
		})
	}
	fake.auditorsReturnsOnCall[i] = struct {
		result1 []view.Identity
	}{result1}
}

func (fake *PublicParameters) Bytes() ([]byte, error) {
	fake.bytesMutex.Lock()
	ret, specificReturn := fake.bytesReturnsOnCall[len(fake.bytesArgsForCall)]
	fake.bytesArgsForCall = append(fake.bytesArgsForCall, struct {
	}{})
	stub := fake.BytesStub
	fakeReturns := fake.bytesReturns
	fake.recordInvocation("Bytes", []interface{}{})
	fake.bytesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PublicParameters) BytesCallCount() int {
	fake.bytesMutex.RLock()
	defer fake.bytesMutex.RUnlock()
	return len(fake.bytesArgsForCall)
}

func (fake *PublicParameters) BytesCalls(stub func() ([]byte, error)) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = stub
}

func (fake *PublicParameters) BytesReturns(result1 []byte, result2 error) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = nil
	fake.bytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) BytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.bytesMutex.Lock()
	defer fake.bytesMutex.Unlock()
	fake.BytesStub = nil
	if fake.bytesReturnsOnCall == nil {
		fake.bytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.bytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) CertificationDriver() string {
	fake.certificationDriverMutex.Lock()
	ret, specificReturn := fake.certificationDriverReturnsOnCall[len(fake.certificationDriverArgsForCall)]
	fake.certificationDriverArgsForCall = append(fake.certificationDriverArgsForCall, struct {
	}{})
	stub := fake.CertificationDriverStub
	fakeReturns := fake.certificationDriverReturns
	fake.recordInvocation("CertificationDriver", []interface{}{})
	fake.certificationDriverMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) CertificationDriverCallCount() int {
	fake.certificationDriverMutex.RLock()
	defer fake.certificationDriverMutex.RUnlock()
	return len(fake.certificationDriverArgsForCall)
}

func (fake *PublicParameters) CertificationDriverCalls(stub func() string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = stub
}

func (fake *PublicParameters) CertificationDriverReturns(result1 string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = nil
	fake.certificationDriverReturns = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) CertificationDriverReturnsOnCall(i int, result1 string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = nil
	if fake.certificationDriverReturnsOnCall == nil {
		fake.certificationDriverReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.certificationDriverReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) GraphHiding() bool {
	fake.graphHidingMutex.Lock()
	ret, specificReturn := fake.graphHidingReturnsOnCall[len(fake.graphHidingArgsForCall)]
	fake.graphHidingArgsForCall = append(fake.graphHidingArgsForCall, struct {
	}{})
	stub := fake.GraphHidingStub
	fakeReturns := fake.graphHidingReturns
	fake.recordInvocation("GraphHiding", []interface{}{})
	fake.graphHidingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) GraphHidingCallCount() int {
	fake.graphHidingMutex.RLock()
	defer fake.graphHidingMutex.RUnlock()
	return len(fake.graphHidingArgsForCall)
}

func (fake *PublicParameters) GraphHidingCalls(stub func() bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = stub
}

func (fake *PublicParameters) GraphHidingReturns(result1 bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = nil
	fake.graphHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) GraphHidingReturnsOnCall(i int, result1 bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = nil
	if fake.graphHidingReturnsOnCall == nil {
		fake.graphHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.graphHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) Identifier() string {
	fake.identifierMutex.Lock()
	ret, specificReturn := fake.identifierReturnsOnCall[len(fake.identifierArgsForCall)]
	fake.identifierArgsForCall = append(fake.identifierArgsForCall, struct {
	}{})
	stub := fake.IdentifierStub
	fakeReturns := fake.identifierReturns
	fake.recordInvocation("Identifier", []interface{}{})
	fake.identifierMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) IdentifierCallCount() int {
	fake.identifierMutex.RLock()
	defer fake.identifierMutex.RUnlock()
	return len(fake.identifierArgsForCall)
}

func (fake *PublicParameters) IdentifierCalls(stub func() string) {
	fake.identifierMutex.Lock()
	defer fake.identifierMutex.Unlock()
	fake.IdentifierStub = stub
}

func (fake *PublicParameters) IdentifierReturns(result1 string) {
	fake.identifierMutex.Lock()
	defer fake.identifierMutex.Unlock()
	fake.IdentifierStub = nil
	fake.identifierReturns = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) IdentifierReturnsOnCall(i int, result1 string) {
	fake.identifierMutex.Lock()
	defer fake.identifierMutex.Unlock()
	fake.IdentifierStub = nil
	if fake.identifierReturnsOnCall == nil {
		fake.identifierReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.identifierReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) MaxTokenValue() uint64 {
	fake.maxTokenValueMutex.Lock()
	ret, specificReturn := fake.maxTokenValueReturnsOnCall[len(fake.maxTokenValueArgsForCall)]
	fake.maxTokenValueArgsForCall = append(fake.maxTokenValueArgsForCall, struct {
	}{})
	stub := fake.MaxTokenValueStub
	fakeReturns := fake.maxTokenValueReturns
	fake.recordInvocation("MaxTokenValue", []interface{}{})
	fake.maxTokenValueMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) MaxTokenValueCallCount() int {
	fake.maxTokenValueMutex.RLock()
	defer fake.maxTokenValueMutex.RUnlock()
	return len(fake.maxTokenValueArgsForCall)
}

func (fake *PublicParameters) MaxTokenValueCalls(stub func() uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = stub
}

func (fake *PublicParameters) MaxTokenValueReturns(result1 uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = nil
	fake.maxTokenValueReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) MaxTokenValueReturnsOnCall(i int, result1 uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = nil
	if fake.maxTokenValueReturnsOnCall == nil {
		fake.maxTokenValueReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.maxTokenValueReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) Precision() uint64 {
	fake.precisionMutex.Lock()
	ret, specificReturn := fake.precisionReturnsOnCall[len(fake.precisionArgsForCall)]
	fake.precisionArgsForCall = append(fake.precisionArgsForCall, struct {
	}{})
	stub := fake.PrecisionStub
	fakeReturns := fake.precisionReturns
	fake.recordInvocation("Precision", []interface{}{})
	fake.precisionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) PrecisionCallCount() int {
	fake.precisionMutex.RLock()
	defer fake.precisionMutex.RUnlock()
	return len(fake.precisionArgsForCall)
}

func (fake *PublicParameters) PrecisionCalls(stub func() uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = stub
}

func (fake *PublicParameters) PrecisionReturns(result1 uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = nil
	fake.precisionReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) PrecisionReturnsOnCall(i int, result1 uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = nil
	if fake.precisionReturnsOnCall == nil {
		fake.precisionReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.precisionReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) Serialize() ([]byte, error) {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct {
	}{})
	stub := fake.SerializeStub
	fakeReturns := fake.serializeReturns
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PublicParameters) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *PublicParameters) SerializeCalls(stub func() ([]byte, error)) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = stub
}

func (fake *PublicParameters) SerializeReturns(result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) SerializeReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
	}{})
	stub := fake.StringStub
	fakeReturns := fake.stringReturns
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *PublicParameters) StringCalls(stub func() string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *PublicParameters) StringReturns(result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) StringReturnsOnCall(i int, result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) TokenDataHiding() bool {
	fake.tokenDataHidingMutex.Lock()
	ret, specificReturn := fake.tokenDataHidingReturnsOnCall[len(fake.tokenDataHidingArgsForCall)]
	fake.tokenDataHidingArgsForCall = append(fake.tokenDataHidingArgsForCall, struct {
	}{})
	stub := fake.TokenDataHidingStub
	fakeReturns := fake.tokenDataHidingReturns
	fake.recordInvocation("TokenDataHiding", []interface{}{})
	fake.tokenDataHidingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) TokenDataHidingCallCount() int {
	fake.tokenDataHidingMutex.RLock()
	defer fake.tokenDataHidingMutex.RUnlock()
	return len(fake.tokenDataHidingArgsForCall)
}

func (fake *PublicParameters) TokenDataHidingCalls(stub func() bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = stub
}

func (fake *PublicParameters) TokenDataHidingReturns(result1 bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = nil
	fake.tokenDataHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) TokenDataHidingReturnsOnCall(i int, result1 bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = nil
	if fake.tokenDataHidingReturnsOnCall == nil {
		fake.tokenDataHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tokenDataHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) Validate() error {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
	}{})
	stub := fake.ValidateStub
	fakeReturns := fake.validateReturns
	fake.recordInvocation("Validate", []interface{}{})
	fake.validateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *PublicParameters) ValidateCalls(stub func() error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *PublicParameters) ValidateReturns(result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *PublicParameters) ValidateReturnsOnCall(i int, result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PublicParameters) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.auditorsMutex.RLock()
	defer fake.auditorsMutex.RUnlock()
	fake.bytesMutex.RLock()
	defer fake.bytesMutex.RUnlock()
	fake.certificationDriverMutex.RLock()
	defer fake.certificationDriverMutex.RUnlock()
	fake.graphHidingMutex.RLock()
	defer fake.graphHidingMutex.RUnlock()
	fake.identifierMutex.RLock()
	defer fake.identifierMutex.RUnlock()
	fake.maxTokenValueMutex.RLock()
	defer fake.maxTokenValueMutex.RUnlock()
	fake.precisionMutex.RLock()
	defer fake.precisionMutex.RUnlock()
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.tokenDataHidingMutex.RLock()
	defer fake.tokenDataHidingMutex.RUnlock()
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *PublicParameters) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.PublicParameters = new(PublicParameters)
