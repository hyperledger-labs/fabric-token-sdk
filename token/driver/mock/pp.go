// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
)

type PublicParameters struct {
	AuditorsStub        func() []driver.Identity
	auditorsMutex       sync.RWMutex
	auditorsArgsForCall []struct {
	}
	auditorsReturns struct {
		result1 []driver.Identity
	}
	auditorsReturnsOnCall map[int]struct {
		result1 []driver.Identity
	}
	CertificationDriverStub        func() string
	certificationDriverMutex       sync.RWMutex
	certificationDriverArgsForCall []struct {
	}
	certificationDriverReturns struct {
		result1 string
	}
	certificationDriverReturnsOnCall map[int]struct {
		result1 string
	}
	GraphHidingStub        func() bool
	graphHidingMutex       sync.RWMutex
	graphHidingArgsForCall []struct {
	}
	graphHidingReturns struct {
		result1 bool
	}
	graphHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	IssuersStub        func() []driver.Identity
	issuersMutex       sync.RWMutex
	issuersArgsForCall []struct {
	}
	issuersReturns struct {
		result1 []driver.Identity
	}
	issuersReturnsOnCall map[int]struct {
		result1 []driver.Identity
	}
	MaxTokenValueStub        func() uint64
	maxTokenValueMutex       sync.RWMutex
	maxTokenValueArgsForCall []struct {
	}
	maxTokenValueReturns struct {
		result1 uint64
	}
	maxTokenValueReturnsOnCall map[int]struct {
		result1 uint64
	}
	PrecisionStub        func() uint64
	precisionMutex       sync.RWMutex
	precisionArgsForCall []struct {
	}
	precisionReturns struct {
		result1 uint64
	}
	precisionReturnsOnCall map[int]struct {
		result1 uint64
	}
	SerializeStub        func() ([]byte, error)
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct {
	}
	serializeReturns struct {
		result1 []byte
		result2 error
	}
	serializeReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
	}
	stringReturns struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	TokenDataHidingStub        func() bool
	tokenDataHidingMutex       sync.RWMutex
	tokenDataHidingArgsForCall []struct {
	}
	tokenDataHidingReturns struct {
		result1 bool
	}
	tokenDataHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	TokenDriverNameStub        func() driver.TokenDriverName
	tokenDriverNameMutex       sync.RWMutex
	tokenDriverNameArgsForCall []struct {
	}
	tokenDriverNameReturns struct {
		result1 driver.TokenDriverName
	}
	tokenDriverNameReturnsOnCall map[int]struct {
		result1 driver.TokenDriverName
	}
	TokenDriverVersionStub        func() driver.TokenDriverVersion
	tokenDriverVersionMutex       sync.RWMutex
	tokenDriverVersionArgsForCall []struct {
	}
	tokenDriverVersionReturns struct {
		result1 driver.TokenDriverVersion
	}
	tokenDriverVersionReturnsOnCall map[int]struct {
		result1 driver.TokenDriverVersion
	}
	ValidateStub        func() error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
	}
	validateReturns struct {
		result1 error
	}
	validateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *PublicParameters) Auditors() []driver.Identity {
	fake.auditorsMutex.Lock()
	ret, specificReturn := fake.auditorsReturnsOnCall[len(fake.auditorsArgsForCall)]
	fake.auditorsArgsForCall = append(fake.auditorsArgsForCall, struct {
	}{})
	stub := fake.AuditorsStub
	fakeReturns := fake.auditorsReturns
	fake.recordInvocation("Auditors", []interface{}{})
	fake.auditorsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) AuditorsCallCount() int {
	fake.auditorsMutex.RLock()
	defer fake.auditorsMutex.RUnlock()
	return len(fake.auditorsArgsForCall)
}

func (fake *PublicParameters) AuditorsCalls(stub func() []driver.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = stub
}

func (fake *PublicParameters) AuditorsReturns(result1 []driver.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = nil
	fake.auditorsReturns = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) AuditorsReturnsOnCall(i int, result1 []driver.Identity) {
	fake.auditorsMutex.Lock()
	defer fake.auditorsMutex.Unlock()
	fake.AuditorsStub = nil
	if fake.auditorsReturnsOnCall == nil {
		fake.auditorsReturnsOnCall = make(map[int]struct {
			result1 []driver.Identity
		})
	}
	fake.auditorsReturnsOnCall[i] = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) CertificationDriver() string {
	fake.certificationDriverMutex.Lock()
	ret, specificReturn := fake.certificationDriverReturnsOnCall[len(fake.certificationDriverArgsForCall)]
	fake.certificationDriverArgsForCall = append(fake.certificationDriverArgsForCall, struct {
	}{})
	stub := fake.CertificationDriverStub
	fakeReturns := fake.certificationDriverReturns
	fake.recordInvocation("CertificationDriver", []interface{}{})
	fake.certificationDriverMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) CertificationDriverCallCount() int {
	fake.certificationDriverMutex.RLock()
	defer fake.certificationDriverMutex.RUnlock()
	return len(fake.certificationDriverArgsForCall)
}

func (fake *PublicParameters) CertificationDriverCalls(stub func() string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = stub
}

func (fake *PublicParameters) CertificationDriverReturns(result1 string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = nil
	fake.certificationDriverReturns = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) CertificationDriverReturnsOnCall(i int, result1 string) {
	fake.certificationDriverMutex.Lock()
	defer fake.certificationDriverMutex.Unlock()
	fake.CertificationDriverStub = nil
	if fake.certificationDriverReturnsOnCall == nil {
		fake.certificationDriverReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.certificationDriverReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) GraphHiding() bool {
	fake.graphHidingMutex.Lock()
	ret, specificReturn := fake.graphHidingReturnsOnCall[len(fake.graphHidingArgsForCall)]
	fake.graphHidingArgsForCall = append(fake.graphHidingArgsForCall, struct {
	}{})
	stub := fake.GraphHidingStub
	fakeReturns := fake.graphHidingReturns
	fake.recordInvocation("GraphHiding", []interface{}{})
	fake.graphHidingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) GraphHidingCallCount() int {
	fake.graphHidingMutex.RLock()
	defer fake.graphHidingMutex.RUnlock()
	return len(fake.graphHidingArgsForCall)
}

func (fake *PublicParameters) GraphHidingCalls(stub func() bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = stub
}

func (fake *PublicParameters) GraphHidingReturns(result1 bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = nil
	fake.graphHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) GraphHidingReturnsOnCall(i int, result1 bool) {
	fake.graphHidingMutex.Lock()
	defer fake.graphHidingMutex.Unlock()
	fake.GraphHidingStub = nil
	if fake.graphHidingReturnsOnCall == nil {
		fake.graphHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.graphHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) Issuers() []driver.Identity {
	fake.issuersMutex.Lock()
	ret, specificReturn := fake.issuersReturnsOnCall[len(fake.issuersArgsForCall)]
	fake.issuersArgsForCall = append(fake.issuersArgsForCall, struct {
	}{})
	stub := fake.IssuersStub
	fakeReturns := fake.issuersReturns
	fake.recordInvocation("Issuers", []interface{}{})
	fake.issuersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) IssuersCallCount() int {
	fake.issuersMutex.RLock()
	defer fake.issuersMutex.RUnlock()
	return len(fake.issuersArgsForCall)
}

func (fake *PublicParameters) IssuersCalls(stub func() []driver.Identity) {
	fake.issuersMutex.Lock()
	defer fake.issuersMutex.Unlock()
	fake.IssuersStub = stub
}

func (fake *PublicParameters) IssuersReturns(result1 []driver.Identity) {
	fake.issuersMutex.Lock()
	defer fake.issuersMutex.Unlock()
	fake.IssuersStub = nil
	fake.issuersReturns = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) IssuersReturnsOnCall(i int, result1 []driver.Identity) {
	fake.issuersMutex.Lock()
	defer fake.issuersMutex.Unlock()
	fake.IssuersStub = nil
	if fake.issuersReturnsOnCall == nil {
		fake.issuersReturnsOnCall = make(map[int]struct {
			result1 []driver.Identity
		})
	}
	fake.issuersReturnsOnCall[i] = struct {
		result1 []driver.Identity
	}{result1}
}

func (fake *PublicParameters) MaxTokenValue() uint64 {
	fake.maxTokenValueMutex.Lock()
	ret, specificReturn := fake.maxTokenValueReturnsOnCall[len(fake.maxTokenValueArgsForCall)]
	fake.maxTokenValueArgsForCall = append(fake.maxTokenValueArgsForCall, struct {
	}{})
	stub := fake.MaxTokenValueStub
	fakeReturns := fake.maxTokenValueReturns
	fake.recordInvocation("MaxTokenValue", []interface{}{})
	fake.maxTokenValueMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) MaxTokenValueCallCount() int {
	fake.maxTokenValueMutex.RLock()
	defer fake.maxTokenValueMutex.RUnlock()
	return len(fake.maxTokenValueArgsForCall)
}

func (fake *PublicParameters) MaxTokenValueCalls(stub func() uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = stub
}

func (fake *PublicParameters) MaxTokenValueReturns(result1 uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = nil
	fake.maxTokenValueReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) MaxTokenValueReturnsOnCall(i int, result1 uint64) {
	fake.maxTokenValueMutex.Lock()
	defer fake.maxTokenValueMutex.Unlock()
	fake.MaxTokenValueStub = nil
	if fake.maxTokenValueReturnsOnCall == nil {
		fake.maxTokenValueReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.maxTokenValueReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) Precision() uint64 {
	fake.precisionMutex.Lock()
	ret, specificReturn := fake.precisionReturnsOnCall[len(fake.precisionArgsForCall)]
	fake.precisionArgsForCall = append(fake.precisionArgsForCall, struct {
	}{})
	stub := fake.PrecisionStub
	fakeReturns := fake.precisionReturns
	fake.recordInvocation("Precision", []interface{}{})
	fake.precisionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) PrecisionCallCount() int {
	fake.precisionMutex.RLock()
	defer fake.precisionMutex.RUnlock()
	return len(fake.precisionArgsForCall)
}

func (fake *PublicParameters) PrecisionCalls(stub func() uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = stub
}

func (fake *PublicParameters) PrecisionReturns(result1 uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = nil
	fake.precisionReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) PrecisionReturnsOnCall(i int, result1 uint64) {
	fake.precisionMutex.Lock()
	defer fake.precisionMutex.Unlock()
	fake.PrecisionStub = nil
	if fake.precisionReturnsOnCall == nil {
		fake.precisionReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.precisionReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *PublicParameters) Serialize() ([]byte, error) {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct {
	}{})
	stub := fake.SerializeStub
	fakeReturns := fake.serializeReturns
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PublicParameters) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *PublicParameters) SerializeCalls(stub func() ([]byte, error)) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = stub
}

func (fake *PublicParameters) SerializeReturns(result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) SerializeReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *PublicParameters) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
	}{})
	stub := fake.StringStub
	fakeReturns := fake.stringReturns
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *PublicParameters) StringCalls(stub func() string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *PublicParameters) StringReturns(result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) StringReturnsOnCall(i int, result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *PublicParameters) TokenDataHiding() bool {
	fake.tokenDataHidingMutex.Lock()
	ret, specificReturn := fake.tokenDataHidingReturnsOnCall[len(fake.tokenDataHidingArgsForCall)]
	fake.tokenDataHidingArgsForCall = append(fake.tokenDataHidingArgsForCall, struct {
	}{})
	stub := fake.TokenDataHidingStub
	fakeReturns := fake.tokenDataHidingReturns
	fake.recordInvocation("TokenDataHiding", []interface{}{})
	fake.tokenDataHidingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) TokenDataHidingCallCount() int {
	fake.tokenDataHidingMutex.RLock()
	defer fake.tokenDataHidingMutex.RUnlock()
	return len(fake.tokenDataHidingArgsForCall)
}

func (fake *PublicParameters) TokenDataHidingCalls(stub func() bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = stub
}

func (fake *PublicParameters) TokenDataHidingReturns(result1 bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = nil
	fake.tokenDataHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) TokenDataHidingReturnsOnCall(i int, result1 bool) {
	fake.tokenDataHidingMutex.Lock()
	defer fake.tokenDataHidingMutex.Unlock()
	fake.TokenDataHidingStub = nil
	if fake.tokenDataHidingReturnsOnCall == nil {
		fake.tokenDataHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tokenDataHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *PublicParameters) TokenDriverName() driver.TokenDriverName {
	fake.tokenDriverNameMutex.Lock()
	ret, specificReturn := fake.tokenDriverNameReturnsOnCall[len(fake.tokenDriverNameArgsForCall)]
	fake.tokenDriverNameArgsForCall = append(fake.tokenDriverNameArgsForCall, struct {
	}{})
	stub := fake.TokenDriverNameStub
	fakeReturns := fake.tokenDriverNameReturns
	fake.recordInvocation("TokenDriverName", []interface{}{})
	fake.tokenDriverNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) TokenDriverNameCallCount() int {
	fake.tokenDriverNameMutex.RLock()
	defer fake.tokenDriverNameMutex.RUnlock()
	return len(fake.tokenDriverNameArgsForCall)
}

func (fake *PublicParameters) TokenDriverNameCalls(stub func() driver.TokenDriverName) {
	fake.tokenDriverNameMutex.Lock()
	defer fake.tokenDriverNameMutex.Unlock()
	fake.TokenDriverNameStub = stub
}

func (fake *PublicParameters) TokenDriverNameReturns(result1 driver.TokenDriverName) {
	fake.tokenDriverNameMutex.Lock()
	defer fake.tokenDriverNameMutex.Unlock()
	fake.TokenDriverNameStub = nil
	fake.tokenDriverNameReturns = struct {
		result1 driver.TokenDriverName
	}{result1}
}

func (fake *PublicParameters) TokenDriverNameReturnsOnCall(i int, result1 driver.TokenDriverName) {
	fake.tokenDriverNameMutex.Lock()
	defer fake.tokenDriverNameMutex.Unlock()
	fake.TokenDriverNameStub = nil
	if fake.tokenDriverNameReturnsOnCall == nil {
		fake.tokenDriverNameReturnsOnCall = make(map[int]struct {
			result1 driver.TokenDriverName
		})
	}
	fake.tokenDriverNameReturnsOnCall[i] = struct {
		result1 driver.TokenDriverName
	}{result1}
}

func (fake *PublicParameters) TokenDriverVersion() driver.TokenDriverVersion {
	fake.tokenDriverVersionMutex.Lock()
	ret, specificReturn := fake.tokenDriverVersionReturnsOnCall[len(fake.tokenDriverVersionArgsForCall)]
	fake.tokenDriverVersionArgsForCall = append(fake.tokenDriverVersionArgsForCall, struct {
	}{})
	stub := fake.TokenDriverVersionStub
	fakeReturns := fake.tokenDriverVersionReturns
	fake.recordInvocation("TokenDriverVersion", []interface{}{})
	fake.tokenDriverVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) TokenDriverVersionCallCount() int {
	fake.tokenDriverVersionMutex.RLock()
	defer fake.tokenDriverVersionMutex.RUnlock()
	return len(fake.tokenDriverVersionArgsForCall)
}

func (fake *PublicParameters) TokenDriverVersionCalls(stub func() driver.TokenDriverVersion) {
	fake.tokenDriverVersionMutex.Lock()
	defer fake.tokenDriverVersionMutex.Unlock()
	fake.TokenDriverVersionStub = stub
}

func (fake *PublicParameters) TokenDriverVersionReturns(result1 driver.TokenDriverVersion) {
	fake.tokenDriverVersionMutex.Lock()
	defer fake.tokenDriverVersionMutex.Unlock()
	fake.TokenDriverVersionStub = nil
	fake.tokenDriverVersionReturns = struct {
		result1 driver.TokenDriverVersion
	}{result1}
}

func (fake *PublicParameters) TokenDriverVersionReturnsOnCall(i int, result1 driver.TokenDriverVersion) {
	fake.tokenDriverVersionMutex.Lock()
	defer fake.tokenDriverVersionMutex.Unlock()
	fake.TokenDriverVersionStub = nil
	if fake.tokenDriverVersionReturnsOnCall == nil {
		fake.tokenDriverVersionReturnsOnCall = make(map[int]struct {
			result1 driver.TokenDriverVersion
		})
	}
	fake.tokenDriverVersionReturnsOnCall[i] = struct {
		result1 driver.TokenDriverVersion
	}{result1}
}

func (fake *PublicParameters) Validate() error {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
	}{})
	stub := fake.ValidateStub
	fakeReturns := fake.validateReturns
	fake.recordInvocation("Validate", []interface{}{})
	fake.validateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PublicParameters) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *PublicParameters) ValidateCalls(stub func() error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *PublicParameters) ValidateReturns(result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *PublicParameters) ValidateReturnsOnCall(i int, result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PublicParameters) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *PublicParameters) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.PublicParameters = new(PublicParameters)
