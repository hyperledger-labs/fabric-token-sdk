// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/driver"
	"github.com/hyperledger-labs/fabric-token-sdk/token/token"
)

type OwnerWallet struct {
	BalanceStub        func(context.Context, *driver.ListTokensOptions) (uint64, error)
	balanceMutex       sync.RWMutex
	balanceArgsForCall []struct {
		arg1 context.Context
		arg2 *driver.ListTokensOptions
	}
	balanceReturns struct {
		result1 uint64
		result2 error
	}
	balanceReturnsOnCall map[int]struct {
		result1 uint64
		result2 error
	}
	ContainsStub        func(context.Context, driver.Identity) bool
	containsMutex       sync.RWMutex
	containsArgsForCall []struct {
		arg1 context.Context
		arg2 driver.Identity
	}
	containsReturns struct {
		result1 bool
	}
	containsReturnsOnCall map[int]struct {
		result1 bool
	}
	ContainsTokenStub        func(context.Context, *token.UnspentToken) bool
	containsTokenMutex       sync.RWMutex
	containsTokenArgsForCall []struct {
		arg1 context.Context
		arg2 *token.UnspentToken
	}
	containsTokenReturns struct {
		result1 bool
	}
	containsTokenReturnsOnCall map[int]struct {
		result1 bool
	}
	EnrollmentIDStub        func() string
	enrollmentIDMutex       sync.RWMutex
	enrollmentIDArgsForCall []struct {
	}
	enrollmentIDReturns struct {
		result1 string
	}
	enrollmentIDReturnsOnCall map[int]struct {
		result1 string
	}
	GetAuditInfoStub        func(context.Context, driver.Identity) ([]byte, error)
	getAuditInfoMutex       sync.RWMutex
	getAuditInfoArgsForCall []struct {
		arg1 context.Context
		arg2 driver.Identity
	}
	getAuditInfoReturns struct {
		result1 []byte
		result2 error
	}
	getAuditInfoReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetRecipientDataStub        func(context.Context) (*driver.RecipientData, error)
	getRecipientDataMutex       sync.RWMutex
	getRecipientDataArgsForCall []struct {
		arg1 context.Context
	}
	getRecipientDataReturns struct {
		result1 *driver.RecipientData
		result2 error
	}
	getRecipientDataReturnsOnCall map[int]struct {
		result1 *driver.RecipientData
		result2 error
	}
	GetRecipientIdentityStub        func(context.Context) (driver.Identity, error)
	getRecipientIdentityMutex       sync.RWMutex
	getRecipientIdentityArgsForCall []struct {
		arg1 context.Context
	}
	getRecipientIdentityReturns struct {
		result1 driver.Identity
		result2 error
	}
	getRecipientIdentityReturnsOnCall map[int]struct {
		result1 driver.Identity
		result2 error
	}
	GetSignerStub        func(context.Context, driver.Identity) (driver.Signer, error)
	getSignerMutex       sync.RWMutex
	getSignerArgsForCall []struct {
		arg1 context.Context
		arg2 driver.Identity
	}
	getSignerReturns struct {
		result1 driver.Signer
		result2 error
	}
	getSignerReturnsOnCall map[int]struct {
		result1 driver.Signer
		result2 error
	}
	GetTokenMetadataStub        func(driver.Identity) ([]byte, error)
	getTokenMetadataMutex       sync.RWMutex
	getTokenMetadataArgsForCall []struct {
		arg1 driver.Identity
	}
	getTokenMetadataReturns struct {
		result1 []byte
		result2 error
	}
	getTokenMetadataReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetTokenMetadataAuditInfoStub        func(driver.Identity) ([]byte, error)
	getTokenMetadataAuditInfoMutex       sync.RWMutex
	getTokenMetadataAuditInfoArgsForCall []struct {
		arg1 driver.Identity
	}
	getTokenMetadataAuditInfoReturns struct {
		result1 []byte
		result2 error
	}
	getTokenMetadataAuditInfoReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	ListTokensStub        func(*driver.ListTokensOptions) (*token.UnspentTokens, error)
	listTokensMutex       sync.RWMutex
	listTokensArgsForCall []struct {
		arg1 *driver.ListTokensOptions
	}
	listTokensReturns struct {
		result1 *token.UnspentTokens
		result2 error
	}
	listTokensReturnsOnCall map[int]struct {
		result1 *token.UnspentTokens
		result2 error
	}
	ListTokensIteratorStub        func(*driver.ListTokensOptions) (driver.UnspentTokensIterator, error)
	listTokensIteratorMutex       sync.RWMutex
	listTokensIteratorArgsForCall []struct {
		arg1 *driver.ListTokensOptions
	}
	listTokensIteratorReturns struct {
		result1 driver.UnspentTokensIterator
		result2 error
	}
	listTokensIteratorReturnsOnCall map[int]struct {
		result1 driver.UnspentTokensIterator
		result2 error
	}
	RegisterRecipientStub        func(context.Context, *driver.RecipientData) error
	registerRecipientMutex       sync.RWMutex
	registerRecipientArgsForCall []struct {
		arg1 context.Context
		arg2 *driver.RecipientData
	}
	registerRecipientReturns struct {
		result1 error
	}
	registerRecipientReturnsOnCall map[int]struct {
		result1 error
	}
	RemoteStub        func() bool
	remoteMutex       sync.RWMutex
	remoteArgsForCall []struct {
	}
	remoteReturns struct {
		result1 bool
	}
	remoteReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *OwnerWallet) Balance(arg1 context.Context, arg2 *driver.ListTokensOptions) (uint64, error) {
	fake.balanceMutex.Lock()
	ret, specificReturn := fake.balanceReturnsOnCall[len(fake.balanceArgsForCall)]
	fake.balanceArgsForCall = append(fake.balanceArgsForCall, struct {
		arg1 context.Context
		arg2 *driver.ListTokensOptions
	}{arg1, arg2})
	stub := fake.BalanceStub
	fakeReturns := fake.balanceReturns
	fake.recordInvocation("Balance", []interface{}{arg1, arg2})
	fake.balanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) BalanceCallCount() int {
	fake.balanceMutex.RLock()
	defer fake.balanceMutex.RUnlock()
	return len(fake.balanceArgsForCall)
}

func (fake *OwnerWallet) BalanceCalls(stub func(context.Context, *driver.ListTokensOptions) (uint64, error)) {
	fake.balanceMutex.Lock()
	defer fake.balanceMutex.Unlock()
	fake.BalanceStub = stub
}

func (fake *OwnerWallet) BalanceArgsForCall(i int) (context.Context, *driver.ListTokensOptions) {
	fake.balanceMutex.RLock()
	defer fake.balanceMutex.RUnlock()
	argsForCall := fake.balanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *OwnerWallet) BalanceReturns(result1 uint64, result2 error) {
	fake.balanceMutex.Lock()
	defer fake.balanceMutex.Unlock()
	fake.BalanceStub = nil
	fake.balanceReturns = struct {
		result1 uint64
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) BalanceReturnsOnCall(i int, result1 uint64, result2 error) {
	fake.balanceMutex.Lock()
	defer fake.balanceMutex.Unlock()
	fake.BalanceStub = nil
	if fake.balanceReturnsOnCall == nil {
		fake.balanceReturnsOnCall = make(map[int]struct {
			result1 uint64
			result2 error
		})
	}
	fake.balanceReturnsOnCall[i] = struct {
		result1 uint64
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) Contains(arg1 context.Context, arg2 driver.Identity) bool {
	fake.containsMutex.Lock()
	ret, specificReturn := fake.containsReturnsOnCall[len(fake.containsArgsForCall)]
	fake.containsArgsForCall = append(fake.containsArgsForCall, struct {
		arg1 context.Context
		arg2 driver.Identity
	}{arg1, arg2})
	stub := fake.ContainsStub
	fakeReturns := fake.containsReturns
	fake.recordInvocation("Contains", []interface{}{arg1, arg2})
	fake.containsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *OwnerWallet) ContainsCallCount() int {
	fake.containsMutex.RLock()
	defer fake.containsMutex.RUnlock()
	return len(fake.containsArgsForCall)
}

func (fake *OwnerWallet) ContainsCalls(stub func(context.Context, driver.Identity) bool) {
	fake.containsMutex.Lock()
	defer fake.containsMutex.Unlock()
	fake.ContainsStub = stub
}

func (fake *OwnerWallet) ContainsArgsForCall(i int) (context.Context, driver.Identity) {
	fake.containsMutex.RLock()
	defer fake.containsMutex.RUnlock()
	argsForCall := fake.containsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *OwnerWallet) ContainsReturns(result1 bool) {
	fake.containsMutex.Lock()
	defer fake.containsMutex.Unlock()
	fake.ContainsStub = nil
	fake.containsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *OwnerWallet) ContainsReturnsOnCall(i int, result1 bool) {
	fake.containsMutex.Lock()
	defer fake.containsMutex.Unlock()
	fake.ContainsStub = nil
	if fake.containsReturnsOnCall == nil {
		fake.containsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.containsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *OwnerWallet) ContainsToken(arg1 context.Context, arg2 *token.UnspentToken) bool {
	fake.containsTokenMutex.Lock()
	ret, specificReturn := fake.containsTokenReturnsOnCall[len(fake.containsTokenArgsForCall)]
	fake.containsTokenArgsForCall = append(fake.containsTokenArgsForCall, struct {
		arg1 context.Context
		arg2 *token.UnspentToken
	}{arg1, arg2})
	stub := fake.ContainsTokenStub
	fakeReturns := fake.containsTokenReturns
	fake.recordInvocation("ContainsToken", []interface{}{arg1, arg2})
	fake.containsTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *OwnerWallet) ContainsTokenCallCount() int {
	fake.containsTokenMutex.RLock()
	defer fake.containsTokenMutex.RUnlock()
	return len(fake.containsTokenArgsForCall)
}

func (fake *OwnerWallet) ContainsTokenCalls(stub func(context.Context, *token.UnspentToken) bool) {
	fake.containsTokenMutex.Lock()
	defer fake.containsTokenMutex.Unlock()
	fake.ContainsTokenStub = stub
}

func (fake *OwnerWallet) ContainsTokenArgsForCall(i int) (context.Context, *token.UnspentToken) {
	fake.containsTokenMutex.RLock()
	defer fake.containsTokenMutex.RUnlock()
	argsForCall := fake.containsTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *OwnerWallet) ContainsTokenReturns(result1 bool) {
	fake.containsTokenMutex.Lock()
	defer fake.containsTokenMutex.Unlock()
	fake.ContainsTokenStub = nil
	fake.containsTokenReturns = struct {
		result1 bool
	}{result1}
}

func (fake *OwnerWallet) ContainsTokenReturnsOnCall(i int, result1 bool) {
	fake.containsTokenMutex.Lock()
	defer fake.containsTokenMutex.Unlock()
	fake.ContainsTokenStub = nil
	if fake.containsTokenReturnsOnCall == nil {
		fake.containsTokenReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.containsTokenReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *OwnerWallet) EnrollmentID() string {
	fake.enrollmentIDMutex.Lock()
	ret, specificReturn := fake.enrollmentIDReturnsOnCall[len(fake.enrollmentIDArgsForCall)]
	fake.enrollmentIDArgsForCall = append(fake.enrollmentIDArgsForCall, struct {
	}{})
	stub := fake.EnrollmentIDStub
	fakeReturns := fake.enrollmentIDReturns
	fake.recordInvocation("EnrollmentID", []interface{}{})
	fake.enrollmentIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *OwnerWallet) EnrollmentIDCallCount() int {
	fake.enrollmentIDMutex.RLock()
	defer fake.enrollmentIDMutex.RUnlock()
	return len(fake.enrollmentIDArgsForCall)
}

func (fake *OwnerWallet) EnrollmentIDCalls(stub func() string) {
	fake.enrollmentIDMutex.Lock()
	defer fake.enrollmentIDMutex.Unlock()
	fake.EnrollmentIDStub = stub
}

func (fake *OwnerWallet) EnrollmentIDReturns(result1 string) {
	fake.enrollmentIDMutex.Lock()
	defer fake.enrollmentIDMutex.Unlock()
	fake.EnrollmentIDStub = nil
	fake.enrollmentIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *OwnerWallet) EnrollmentIDReturnsOnCall(i int, result1 string) {
	fake.enrollmentIDMutex.Lock()
	defer fake.enrollmentIDMutex.Unlock()
	fake.EnrollmentIDStub = nil
	if fake.enrollmentIDReturnsOnCall == nil {
		fake.enrollmentIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.enrollmentIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *OwnerWallet) GetAuditInfo(arg1 context.Context, arg2 driver.Identity) ([]byte, error) {
	fake.getAuditInfoMutex.Lock()
	ret, specificReturn := fake.getAuditInfoReturnsOnCall[len(fake.getAuditInfoArgsForCall)]
	fake.getAuditInfoArgsForCall = append(fake.getAuditInfoArgsForCall, struct {
		arg1 context.Context
		arg2 driver.Identity
	}{arg1, arg2})
	stub := fake.GetAuditInfoStub
	fakeReturns := fake.getAuditInfoReturns
	fake.recordInvocation("GetAuditInfo", []interface{}{arg1, arg2})
	fake.getAuditInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) GetAuditInfoCallCount() int {
	fake.getAuditInfoMutex.RLock()
	defer fake.getAuditInfoMutex.RUnlock()
	return len(fake.getAuditInfoArgsForCall)
}

func (fake *OwnerWallet) GetAuditInfoCalls(stub func(context.Context, driver.Identity) ([]byte, error)) {
	fake.getAuditInfoMutex.Lock()
	defer fake.getAuditInfoMutex.Unlock()
	fake.GetAuditInfoStub = stub
}

func (fake *OwnerWallet) GetAuditInfoArgsForCall(i int) (context.Context, driver.Identity) {
	fake.getAuditInfoMutex.RLock()
	defer fake.getAuditInfoMutex.RUnlock()
	argsForCall := fake.getAuditInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *OwnerWallet) GetAuditInfoReturns(result1 []byte, result2 error) {
	fake.getAuditInfoMutex.Lock()
	defer fake.getAuditInfoMutex.Unlock()
	fake.GetAuditInfoStub = nil
	fake.getAuditInfoReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetAuditInfoReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getAuditInfoMutex.Lock()
	defer fake.getAuditInfoMutex.Unlock()
	fake.GetAuditInfoStub = nil
	if fake.getAuditInfoReturnsOnCall == nil {
		fake.getAuditInfoReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getAuditInfoReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetRecipientData(arg1 context.Context) (*driver.RecipientData, error) {
	fake.getRecipientDataMutex.Lock()
	ret, specificReturn := fake.getRecipientDataReturnsOnCall[len(fake.getRecipientDataArgsForCall)]
	fake.getRecipientDataArgsForCall = append(fake.getRecipientDataArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetRecipientDataStub
	fakeReturns := fake.getRecipientDataReturns
	fake.recordInvocation("GetRecipientData", []interface{}{arg1})
	fake.getRecipientDataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) GetRecipientDataCallCount() int {
	fake.getRecipientDataMutex.RLock()
	defer fake.getRecipientDataMutex.RUnlock()
	return len(fake.getRecipientDataArgsForCall)
}

func (fake *OwnerWallet) GetRecipientDataCalls(stub func(context.Context) (*driver.RecipientData, error)) {
	fake.getRecipientDataMutex.Lock()
	defer fake.getRecipientDataMutex.Unlock()
	fake.GetRecipientDataStub = stub
}

func (fake *OwnerWallet) GetRecipientDataArgsForCall(i int) context.Context {
	fake.getRecipientDataMutex.RLock()
	defer fake.getRecipientDataMutex.RUnlock()
	argsForCall := fake.getRecipientDataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *OwnerWallet) GetRecipientDataReturns(result1 *driver.RecipientData, result2 error) {
	fake.getRecipientDataMutex.Lock()
	defer fake.getRecipientDataMutex.Unlock()
	fake.GetRecipientDataStub = nil
	fake.getRecipientDataReturns = struct {
		result1 *driver.RecipientData
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetRecipientDataReturnsOnCall(i int, result1 *driver.RecipientData, result2 error) {
	fake.getRecipientDataMutex.Lock()
	defer fake.getRecipientDataMutex.Unlock()
	fake.GetRecipientDataStub = nil
	if fake.getRecipientDataReturnsOnCall == nil {
		fake.getRecipientDataReturnsOnCall = make(map[int]struct {
			result1 *driver.RecipientData
			result2 error
		})
	}
	fake.getRecipientDataReturnsOnCall[i] = struct {
		result1 *driver.RecipientData
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetRecipientIdentity(arg1 context.Context) (driver.Identity, error) {
	fake.getRecipientIdentityMutex.Lock()
	ret, specificReturn := fake.getRecipientIdentityReturnsOnCall[len(fake.getRecipientIdentityArgsForCall)]
	fake.getRecipientIdentityArgsForCall = append(fake.getRecipientIdentityArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetRecipientIdentityStub
	fakeReturns := fake.getRecipientIdentityReturns
	fake.recordInvocation("GetRecipientIdentity", []interface{}{arg1})
	fake.getRecipientIdentityMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) GetRecipientIdentityCallCount() int {
	fake.getRecipientIdentityMutex.RLock()
	defer fake.getRecipientIdentityMutex.RUnlock()
	return len(fake.getRecipientIdentityArgsForCall)
}

func (fake *OwnerWallet) GetRecipientIdentityCalls(stub func(context.Context) (driver.Identity, error)) {
	fake.getRecipientIdentityMutex.Lock()
	defer fake.getRecipientIdentityMutex.Unlock()
	fake.GetRecipientIdentityStub = stub
}

func (fake *OwnerWallet) GetRecipientIdentityArgsForCall(i int) context.Context {
	fake.getRecipientIdentityMutex.RLock()
	defer fake.getRecipientIdentityMutex.RUnlock()
	argsForCall := fake.getRecipientIdentityArgsForCall[i]
	return argsForCall.arg1
}

func (fake *OwnerWallet) GetRecipientIdentityReturns(result1 driver.Identity, result2 error) {
	fake.getRecipientIdentityMutex.Lock()
	defer fake.getRecipientIdentityMutex.Unlock()
	fake.GetRecipientIdentityStub = nil
	fake.getRecipientIdentityReturns = struct {
		result1 driver.Identity
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetRecipientIdentityReturnsOnCall(i int, result1 driver.Identity, result2 error) {
	fake.getRecipientIdentityMutex.Lock()
	defer fake.getRecipientIdentityMutex.Unlock()
	fake.GetRecipientIdentityStub = nil
	if fake.getRecipientIdentityReturnsOnCall == nil {
		fake.getRecipientIdentityReturnsOnCall = make(map[int]struct {
			result1 driver.Identity
			result2 error
		})
	}
	fake.getRecipientIdentityReturnsOnCall[i] = struct {
		result1 driver.Identity
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetSigner(arg1 context.Context, arg2 driver.Identity) (driver.Signer, error) {
	fake.getSignerMutex.Lock()
	ret, specificReturn := fake.getSignerReturnsOnCall[len(fake.getSignerArgsForCall)]
	fake.getSignerArgsForCall = append(fake.getSignerArgsForCall, struct {
		arg1 context.Context
		arg2 driver.Identity
	}{arg1, arg2})
	stub := fake.GetSignerStub
	fakeReturns := fake.getSignerReturns
	fake.recordInvocation("GetSigner", []interface{}{arg1, arg2})
	fake.getSignerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) GetSignerCallCount() int {
	fake.getSignerMutex.RLock()
	defer fake.getSignerMutex.RUnlock()
	return len(fake.getSignerArgsForCall)
}

func (fake *OwnerWallet) GetSignerCalls(stub func(context.Context, driver.Identity) (driver.Signer, error)) {
	fake.getSignerMutex.Lock()
	defer fake.getSignerMutex.Unlock()
	fake.GetSignerStub = stub
}

func (fake *OwnerWallet) GetSignerArgsForCall(i int) (context.Context, driver.Identity) {
	fake.getSignerMutex.RLock()
	defer fake.getSignerMutex.RUnlock()
	argsForCall := fake.getSignerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *OwnerWallet) GetSignerReturns(result1 driver.Signer, result2 error) {
	fake.getSignerMutex.Lock()
	defer fake.getSignerMutex.Unlock()
	fake.GetSignerStub = nil
	fake.getSignerReturns = struct {
		result1 driver.Signer
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetSignerReturnsOnCall(i int, result1 driver.Signer, result2 error) {
	fake.getSignerMutex.Lock()
	defer fake.getSignerMutex.Unlock()
	fake.GetSignerStub = nil
	if fake.getSignerReturnsOnCall == nil {
		fake.getSignerReturnsOnCall = make(map[int]struct {
			result1 driver.Signer
			result2 error
		})
	}
	fake.getSignerReturnsOnCall[i] = struct {
		result1 driver.Signer
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetTokenMetadata(arg1 driver.Identity) ([]byte, error) {
	fake.getTokenMetadataMutex.Lock()
	ret, specificReturn := fake.getTokenMetadataReturnsOnCall[len(fake.getTokenMetadataArgsForCall)]
	fake.getTokenMetadataArgsForCall = append(fake.getTokenMetadataArgsForCall, struct {
		arg1 driver.Identity
	}{arg1})
	stub := fake.GetTokenMetadataStub
	fakeReturns := fake.getTokenMetadataReturns
	fake.recordInvocation("GetTokenMetadata", []interface{}{arg1})
	fake.getTokenMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) GetTokenMetadataCallCount() int {
	fake.getTokenMetadataMutex.RLock()
	defer fake.getTokenMetadataMutex.RUnlock()
	return len(fake.getTokenMetadataArgsForCall)
}

func (fake *OwnerWallet) GetTokenMetadataCalls(stub func(driver.Identity) ([]byte, error)) {
	fake.getTokenMetadataMutex.Lock()
	defer fake.getTokenMetadataMutex.Unlock()
	fake.GetTokenMetadataStub = stub
}

func (fake *OwnerWallet) GetTokenMetadataArgsForCall(i int) driver.Identity {
	fake.getTokenMetadataMutex.RLock()
	defer fake.getTokenMetadataMutex.RUnlock()
	argsForCall := fake.getTokenMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *OwnerWallet) GetTokenMetadataReturns(result1 []byte, result2 error) {
	fake.getTokenMetadataMutex.Lock()
	defer fake.getTokenMetadataMutex.Unlock()
	fake.GetTokenMetadataStub = nil
	fake.getTokenMetadataReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetTokenMetadataReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getTokenMetadataMutex.Lock()
	defer fake.getTokenMetadataMutex.Unlock()
	fake.GetTokenMetadataStub = nil
	if fake.getTokenMetadataReturnsOnCall == nil {
		fake.getTokenMetadataReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getTokenMetadataReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetTokenMetadataAuditInfo(arg1 driver.Identity) ([]byte, error) {
	fake.getTokenMetadataAuditInfoMutex.Lock()
	ret, specificReturn := fake.getTokenMetadataAuditInfoReturnsOnCall[len(fake.getTokenMetadataAuditInfoArgsForCall)]
	fake.getTokenMetadataAuditInfoArgsForCall = append(fake.getTokenMetadataAuditInfoArgsForCall, struct {
		arg1 driver.Identity
	}{arg1})
	stub := fake.GetTokenMetadataAuditInfoStub
	fakeReturns := fake.getTokenMetadataAuditInfoReturns
	fake.recordInvocation("GetTokenMetadataAuditInfo", []interface{}{arg1})
	fake.getTokenMetadataAuditInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) GetTokenMetadataAuditInfoCallCount() int {
	fake.getTokenMetadataAuditInfoMutex.RLock()
	defer fake.getTokenMetadataAuditInfoMutex.RUnlock()
	return len(fake.getTokenMetadataAuditInfoArgsForCall)
}

func (fake *OwnerWallet) GetTokenMetadataAuditInfoCalls(stub func(driver.Identity) ([]byte, error)) {
	fake.getTokenMetadataAuditInfoMutex.Lock()
	defer fake.getTokenMetadataAuditInfoMutex.Unlock()
	fake.GetTokenMetadataAuditInfoStub = stub
}

func (fake *OwnerWallet) GetTokenMetadataAuditInfoArgsForCall(i int) driver.Identity {
	fake.getTokenMetadataAuditInfoMutex.RLock()
	defer fake.getTokenMetadataAuditInfoMutex.RUnlock()
	argsForCall := fake.getTokenMetadataAuditInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *OwnerWallet) GetTokenMetadataAuditInfoReturns(result1 []byte, result2 error) {
	fake.getTokenMetadataAuditInfoMutex.Lock()
	defer fake.getTokenMetadataAuditInfoMutex.Unlock()
	fake.GetTokenMetadataAuditInfoStub = nil
	fake.getTokenMetadataAuditInfoReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) GetTokenMetadataAuditInfoReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getTokenMetadataAuditInfoMutex.Lock()
	defer fake.getTokenMetadataAuditInfoMutex.Unlock()
	fake.GetTokenMetadataAuditInfoStub = nil
	if fake.getTokenMetadataAuditInfoReturnsOnCall == nil {
		fake.getTokenMetadataAuditInfoReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getTokenMetadataAuditInfoReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *OwnerWallet) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *OwnerWallet) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *OwnerWallet) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *OwnerWallet) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *OwnerWallet) ListTokens(arg1 *driver.ListTokensOptions) (*token.UnspentTokens, error) {
	fake.listTokensMutex.Lock()
	ret, specificReturn := fake.listTokensReturnsOnCall[len(fake.listTokensArgsForCall)]
	fake.listTokensArgsForCall = append(fake.listTokensArgsForCall, struct {
		arg1 *driver.ListTokensOptions
	}{arg1})
	stub := fake.ListTokensStub
	fakeReturns := fake.listTokensReturns
	fake.recordInvocation("ListTokens", []interface{}{arg1})
	fake.listTokensMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) ListTokensCallCount() int {
	fake.listTokensMutex.RLock()
	defer fake.listTokensMutex.RUnlock()
	return len(fake.listTokensArgsForCall)
}

func (fake *OwnerWallet) ListTokensCalls(stub func(*driver.ListTokensOptions) (*token.UnspentTokens, error)) {
	fake.listTokensMutex.Lock()
	defer fake.listTokensMutex.Unlock()
	fake.ListTokensStub = stub
}

func (fake *OwnerWallet) ListTokensArgsForCall(i int) *driver.ListTokensOptions {
	fake.listTokensMutex.RLock()
	defer fake.listTokensMutex.RUnlock()
	argsForCall := fake.listTokensArgsForCall[i]
	return argsForCall.arg1
}

func (fake *OwnerWallet) ListTokensReturns(result1 *token.UnspentTokens, result2 error) {
	fake.listTokensMutex.Lock()
	defer fake.listTokensMutex.Unlock()
	fake.ListTokensStub = nil
	fake.listTokensReturns = struct {
		result1 *token.UnspentTokens
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) ListTokensReturnsOnCall(i int, result1 *token.UnspentTokens, result2 error) {
	fake.listTokensMutex.Lock()
	defer fake.listTokensMutex.Unlock()
	fake.ListTokensStub = nil
	if fake.listTokensReturnsOnCall == nil {
		fake.listTokensReturnsOnCall = make(map[int]struct {
			result1 *token.UnspentTokens
			result2 error
		})
	}
	fake.listTokensReturnsOnCall[i] = struct {
		result1 *token.UnspentTokens
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) ListTokensIterator(arg1 *driver.ListTokensOptions) (driver.UnspentTokensIterator, error) {
	fake.listTokensIteratorMutex.Lock()
	ret, specificReturn := fake.listTokensIteratorReturnsOnCall[len(fake.listTokensIteratorArgsForCall)]
	fake.listTokensIteratorArgsForCall = append(fake.listTokensIteratorArgsForCall, struct {
		arg1 *driver.ListTokensOptions
	}{arg1})
	stub := fake.ListTokensIteratorStub
	fakeReturns := fake.listTokensIteratorReturns
	fake.recordInvocation("ListTokensIterator", []interface{}{arg1})
	fake.listTokensIteratorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *OwnerWallet) ListTokensIteratorCallCount() int {
	fake.listTokensIteratorMutex.RLock()
	defer fake.listTokensIteratorMutex.RUnlock()
	return len(fake.listTokensIteratorArgsForCall)
}

func (fake *OwnerWallet) ListTokensIteratorCalls(stub func(*driver.ListTokensOptions) (driver.UnspentTokensIterator, error)) {
	fake.listTokensIteratorMutex.Lock()
	defer fake.listTokensIteratorMutex.Unlock()
	fake.ListTokensIteratorStub = stub
}

func (fake *OwnerWallet) ListTokensIteratorArgsForCall(i int) *driver.ListTokensOptions {
	fake.listTokensIteratorMutex.RLock()
	defer fake.listTokensIteratorMutex.RUnlock()
	argsForCall := fake.listTokensIteratorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *OwnerWallet) ListTokensIteratorReturns(result1 driver.UnspentTokensIterator, result2 error) {
	fake.listTokensIteratorMutex.Lock()
	defer fake.listTokensIteratorMutex.Unlock()
	fake.ListTokensIteratorStub = nil
	fake.listTokensIteratorReturns = struct {
		result1 driver.UnspentTokensIterator
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) ListTokensIteratorReturnsOnCall(i int, result1 driver.UnspentTokensIterator, result2 error) {
	fake.listTokensIteratorMutex.Lock()
	defer fake.listTokensIteratorMutex.Unlock()
	fake.ListTokensIteratorStub = nil
	if fake.listTokensIteratorReturnsOnCall == nil {
		fake.listTokensIteratorReturnsOnCall = make(map[int]struct {
			result1 driver.UnspentTokensIterator
			result2 error
		})
	}
	fake.listTokensIteratorReturnsOnCall[i] = struct {
		result1 driver.UnspentTokensIterator
		result2 error
	}{result1, result2}
}

func (fake *OwnerWallet) RegisterRecipient(arg1 context.Context, arg2 *driver.RecipientData) error {
	fake.registerRecipientMutex.Lock()
	ret, specificReturn := fake.registerRecipientReturnsOnCall[len(fake.registerRecipientArgsForCall)]
	fake.registerRecipientArgsForCall = append(fake.registerRecipientArgsForCall, struct {
		arg1 context.Context
		arg2 *driver.RecipientData
	}{arg1, arg2})
	stub := fake.RegisterRecipientStub
	fakeReturns := fake.registerRecipientReturns
	fake.recordInvocation("RegisterRecipient", []interface{}{arg1, arg2})
	fake.registerRecipientMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *OwnerWallet) RegisterRecipientCallCount() int {
	fake.registerRecipientMutex.RLock()
	defer fake.registerRecipientMutex.RUnlock()
	return len(fake.registerRecipientArgsForCall)
}

func (fake *OwnerWallet) RegisterRecipientCalls(stub func(context.Context, *driver.RecipientData) error) {
	fake.registerRecipientMutex.Lock()
	defer fake.registerRecipientMutex.Unlock()
	fake.RegisterRecipientStub = stub
}

func (fake *OwnerWallet) RegisterRecipientArgsForCall(i int) (context.Context, *driver.RecipientData) {
	fake.registerRecipientMutex.RLock()
	defer fake.registerRecipientMutex.RUnlock()
	argsForCall := fake.registerRecipientArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *OwnerWallet) RegisterRecipientReturns(result1 error) {
	fake.registerRecipientMutex.Lock()
	defer fake.registerRecipientMutex.Unlock()
	fake.RegisterRecipientStub = nil
	fake.registerRecipientReturns = struct {
		result1 error
	}{result1}
}

func (fake *OwnerWallet) RegisterRecipientReturnsOnCall(i int, result1 error) {
	fake.registerRecipientMutex.Lock()
	defer fake.registerRecipientMutex.Unlock()
	fake.RegisterRecipientStub = nil
	if fake.registerRecipientReturnsOnCall == nil {
		fake.registerRecipientReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerRecipientReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *OwnerWallet) Remote() bool {
	fake.remoteMutex.Lock()
	ret, specificReturn := fake.remoteReturnsOnCall[len(fake.remoteArgsForCall)]
	fake.remoteArgsForCall = append(fake.remoteArgsForCall, struct {
	}{})
	stub := fake.RemoteStub
	fakeReturns := fake.remoteReturns
	fake.recordInvocation("Remote", []interface{}{})
	fake.remoteMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *OwnerWallet) RemoteCallCount() int {
	fake.remoteMutex.RLock()
	defer fake.remoteMutex.RUnlock()
	return len(fake.remoteArgsForCall)
}

func (fake *OwnerWallet) RemoteCalls(stub func() bool) {
	fake.remoteMutex.Lock()
	defer fake.remoteMutex.Unlock()
	fake.RemoteStub = stub
}

func (fake *OwnerWallet) RemoteReturns(result1 bool) {
	fake.remoteMutex.Lock()
	defer fake.remoteMutex.Unlock()
	fake.RemoteStub = nil
	fake.remoteReturns = struct {
		result1 bool
	}{result1}
}

func (fake *OwnerWallet) RemoteReturnsOnCall(i int, result1 bool) {
	fake.remoteMutex.Lock()
	defer fake.remoteMutex.Unlock()
	fake.RemoteStub = nil
	if fake.remoteReturnsOnCall == nil {
		fake.remoteReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.remoteReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *OwnerWallet) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *OwnerWallet) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.OwnerWallet = new(OwnerWallet)
